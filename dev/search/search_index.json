{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pytauri","title":"PyTauri","text":"<p>Tauri bindings for Python through Pyo3</p> <p></p> <p>Documentation: https://pytauri.github.io/pytauri/</p> <p>Source Code: https://github.com/pytauri/pytauri/</p> <p>This is a completely free and open-source project, but it is difficult to maintain without incentives and contributions from the community.</p> <p>If you think this project is helpful, consider giving it a star , it would be very helpful for my work and studies. \ud83e\udd7a\ud83d\udc49\ud83d\udc48</p>"},{"location":"#features","title":"Features","text":"<p>TL;DR</p> <p>You are hurry and just wanna see/run the demo? See examples/tauri-app.</p> <ul> <li>Need Rust compiler, but almost don't need to write Rust code!</li> <li>Or use <code>pytauri-wheel</code>, you won't need the Rust compiler, everything can be done in Python! Check out examples/tauri-app-wheel.</li> <li>Can be integrated with <code>tauri-cli</code> to build and package standalone executables!<ul> <li>Use <code>Cython</code> to protect your source code!</li> </ul> </li> <li>No IPC (inter-process communication) overhead, secure and fast, thanks to Pyo3!</li> <li> <p>Support Tauri official plugins(e.g., notification), and you can write your own plugins!</p> <p></p> </li> <li> <p>Natively support async python (<code>asyncio</code>, <code>trio</code> or <code>anyio</code>)</p> </li> <li>100% Type Completeness</li> <li> <p>Ergonomic API (and as close as possible to the Tauri Rust API)</p> <ul> <li>Automatically generated TypeScript types and client for IPC</li> <li> <p>Python</p> <pre><code>import sys\n\nfrom pydantic import BaseModel\nfrom pytauri import (\n    AppHandle,\n    Commands,\n)\nfrom pytauri_plugins.notification import NotificationExt\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person, app_handle: AppHandle) -&gt; Greeting:\n    notification_builder = NotificationExt.builder(app_handle)\n    notification_builder.show(title=\"Greeting\", body=f\"Hello, {body.name}!\")\n\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n</code></pre> </li> <li> <p>Frontend</p> <pre><code>import { pyInvoke } from \"tauri-plugin-pytauri-api\";\n// or: `const { pyInvoke } = window.__TAURI__.pytauri;`\n\nexport interface Person {\n    name: string;\n}\n\nexport interface Greeting {\n    message: string;\n}\n\nexport async function greet(body: Person): Promise&lt;Greeting&gt; {\n    return await pyInvoke(\"greet\", body);\n}\n</code></pre> </li> </ul> </li> <li> <p>Can be integrated with nicegui/gradio/FastAPI to achieve a full-stack Python development experience (i.g., without <code>Node.js</code>). See examples/nicegui-app.</p> </li> </ul>"},{"location":"#release","title":"Release","text":"<p>We follow Semantic Versioning 2.0.0.</p> <p>Rust and its Python bindings, PyTauri core and its plugins will keep the same <code>MAJOR.MINOR</code> version number.</p> name pypi crates.io npmjs \ud83d\udc49 core - - - pytauri pytauri-core tauri-plugin-pytauri \ud83d\udc49 wheel - - - pytauri-wheel \ud83d\udc49 utils - - - pyo3-utils codelldb"},{"location":"#philosophy","title":"Philosophy","text":""},{"location":"#for-pythoneer","title":"For Pythoneer","text":"<p>I hope <code>PyTauri</code> can become an alternative to pywebview and Pystray, leveraging Tauri's comprehensive features to offer Python developers a GUI framework and a batteries-included development experience similar to electron and PySide.</p> <p>PyTauri is inspired by FastAPI and Pydantic, aiming to offer a similar development experience.</p>"},{"location":"#for-rustacean","title":"For Rustacean","text":"<p>Through Pyo3, I hope Rust developers can better utilize the Python ecosystem (e.g., building AI GUI applications with PyTorch).</p> <p>Although Rust's lifetime and ownership system makes Rust code safer, Python's garbage collection (GC) will make life easier. \ud83d\ude06</p>"},{"location":"#used-by","title":"Used By","text":"<p>Although PyTauri is a fairly young project, a few people have used it to make cool projects:</p> <ul> <li>Digger Solo - AI powered file manager</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>PyTauri is a project that aims to provide Python bindings for Tauri, a cross-platform webview GUI library. <code>Tauri</code> is a trademark of the Tauri Program within the Commons Conservancy and PyTauri is not officially endorsed or supported by them. PyTauri is an independent and community-driven effort that respects the original goals and values of Tauri. PyTauri does not claim any ownership or affiliation with the Tauri Program.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the Apache License 2.0.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <ul> <li><code>Highlights</code> for the most attractive new features.</li> <li><code>BREAKING</code> for breaking changes.</li> <li><code>Added</code> for new features.</li> <li><code>Changed</code> for changes in existing functionality.</li> <li><code>Deprecated</code> for soon-to-be removed features.</li> <li><code>Removed</code> for now removed features.</li> <li><code>Fixed</code> for any bug fixes.</li> <li><code>Security</code> in case of vulnerabilities.</li> <li><code>Docs</code> for documentation changes.</li> <li><code>YANKED</code> for deprecated releases.</li> <li><code>Internal</code> for internal changes. Only for maintainers.</li> </ul> <p>Tip</p> <p>This homepage is used to provide a blog-like changelog and <code>BREAKING CHANGE</code> migration guide.</p> <p>You can expand sub-projects to view detailed changelogs.</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#highlights","title":"Highlights","text":""},{"location":"CHANGELOG/#generate-typescript-client-for-ipc","title":"Generate TypeScript Client for IPC","text":"<ul> <li>#179 - feat(pytauri): generate typescript client for IPC.</li> </ul> <p>See: https://pytauri.github.io/pytauri/0.7/usage/tutorial/gen-ts</p> <pre><code>@commands.command()\nasync def greet_to_person(body: Person) -&gt; str: ...\n</code></pre> <p>automatically generates the following TypeScript client code:</p> <pre><code>export async function greetToPerson(\n    body: Commands[\"greet_to_person\"][\"input\"],\n    options?: InvokeOptions\n): Promise&lt;Commands[\"greet_to_person\"][\"output\"]&gt; {\n    return await pyInvoke(\"greet_to_person\", body, options);\n}\n</code></pre>"},{"location":"CHANGELOG/#support-using-arbitrary-types-in-command","title":"Support using arbitrary types in <code>command</code>","text":"<ul> <li>#171 - feat(pytauri): support using arbitrary types in <code>command</code>.</li> </ul> <p>See: https://pytauri.github.io/pytauri/0.7/usage/concepts/ipc/#deserializing-the-body-using-arbitrary-types</p> <pre><code>from pydantic import RootModel\nfrom pytauri import Commands\n\ncommands = Commands()\n\nRootModelStr = RootModel[str]\n\n\n# \ud83d\ude2b \u274c\n@commands.command()\nasync def old(body: RootModelStr) -&gt; bytes:\n    return b\"null\"\n\n\n# \ud83d\ude07 \u2714\n@commands.command()\nasync def new(body: str) -&gt; None:\n    return\n</code></pre>"},{"location":"CHANGELOG/#breaking","title":"BREAKING","text":"<ul> <li> <p>#178 - feat(plugin-api)!: remove <code>rawPyInvoke</code> and <code>Channel</code>.</p> <p>Migration</p> <pre><code>-import { rawPyInvoke, Channel } from \"tauri-plugin-pytauri-api\";\n+import { pyInvoke } from \"tauri-plugin-pytauri-api\";\n+import { Channel } from \"@tauri-apps/api/core\";\n</code></pre> <p>Before <code>v0.7</code>, IPC between Python and the frontend always used <code>bytes</code>/<code>ArrayBuffer</code> for data transfer. <code>pyInvoke</code> and <code>Channel.addJsonListener</code> would force serialization and deserialization of input and output, while <code>rawPyInvoke</code> and <code>Channel.onmessage</code> would directly send and receive raw <code>ArrayBuffer</code> data. This mechanism has been improved in <code>v0.7</code>:</p> <ul> <li> <p>Now, <code>pyInvoke</code> automatically chooses whether to serialize based on your input type:</p> <ul> <li><code>ArrayBuffer</code>/<code>Uint8Array</code> will be sent directly to the backend.</li> <li>Other types (<code>any</code>) will be converted to <code>ArrayBuffer</code> using <code>JSON.stringify</code> and <code>TextEncoder</code> before being sent to the backend.</li> </ul> <p>Only the backend can decide whether to deserialize or accept the raw bytes data.</p> </li> <li> <p>Only the backend can decide whether to return deserialized JSON data or raw <code>ArrayBuffer</code> data:</p> <ul> <li>If <code>Command</code> returns a <code>bytes</code> type or Channel.send sends a <code>bytes</code> type, the frontend will receive an <code>ArrayBuffer</code>.</li> <li>If <code>Command</code> returns other types (<code>BaseModel</code>/<code>Any</code>) and Channel.send sends a <code>str</code> type, the frontend will receive automatically deserialized JSON data.</li> </ul> </li> </ul> <p>Therefore:</p> <ul> <li><code>pyInvoke</code> replaces <code>rawPyInvoke</code></li> <li><code>import { Channel } from \"@tauri-apps/api/core\"</code> replaces <code>import { Channel } from \"tauri-plugin-pytauri-api\"</code>.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#061","title":"0.6.1","text":""},{"location":"CHANGELOG/#highlights_1","title":"Highlights","text":""},{"location":"CHANGELOG/#rebranding","title":"Rebranding","text":"<p>#173 - docs: rebranding.</p> <p></p> <p>A branding overhaul with an updated logo and colors:</p> <ol> <li> <p>The shape is similar to shapes found in the Tauri logo.</p> <p>We have verified with the Tauri board and they are OK with this logo.</p> Comparison <p></p> </li> <li> <p>The updated brand color is a mix of the Python and Tauri blue.</p> </li> </ol> <p>Q: Changing the logo and branding color might confuse users that they have entered the wrong site</p> <p>While this might be true, we think PyTauri is not large enough yet to have this be a big issue. Either way I would suggest leaving this issue #170 up for a week and adding the banner above to the website to prepare users for the transition. An argument could also be made that a more professional looking icon attracts more users. Anyway, we will not change the logo (at least the color) again in the future.</p>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li> <p>#175 - fix(pytauri): bump <code>tauri-plugin-*</code> to fix rust docs build failures on <code>docs.rs</code>.</p> <p>See tauri-apps/tauri#13597 for details.</p> <ul> <li><code>tauri-plugin-opener = { version = \"2.3.0\" }</code></li> <li><code>tauri-plugin-clipboard-manager = { version = \"2.2.3\" }</code></li> <li><code>tauri-plugin-dialog = { version = \"2.2.2\" }</code></li> <li><code>tauri-plugin-fs = { version = \"2.3.0\" }</code></li> <li><code>tauri-plugin-notification = { version = \"2.2.3\" }</code></li> </ul> </li> </ul>"},{"location":"CHANGELOG/#060","title":"0.6.0","text":""},{"location":"CHANGELOG/#highlights_2","title":"Highlights","text":""},{"location":"CHANGELOG/#create-pytauri-app-template-generator","title":"<code>create-pytauri-app</code> template generator","text":"<ul> <li>#169 - docs: update docs for v0.6.0 .</li> </ul> <p>Since version <code>0.6</code>, create-pytauri-app is the recommended way to start a new PyTauri project, even if it is still in development.</p> Usage <p>Refer to uv and copier, run the following command:</p> <pre><code>uvx copier copy https://github.com/pytauri/create-pytauri-app .\n</code></pre> <p>This will initialize the project in the form of an interactive questionnaire:</p> <pre><code>\ud83c\udfa4 Project name\npytauri-app\n\ud83c\udfa4 Identifier\ncom.pytauri-app.app\n\ud83c\udfa4 Choose your UI template\nVue\n</code></pre> <p>However, we still recommend reading the entire \"Tutorial\" section, as it will help you understand all the details of pytauri.</p>"},{"location":"CHANGELOG/#tauri-plugin-dialog-bingings","title":"<code>tauri-plugin-dialog</code> bingings","text":"<ul> <li>#163 - feat(plugin): implement <code>tauri-plugin-dialog</code> bindings.</li> </ul> <p><code>tauri-plugin-dialog</code> has now been integrated into <code>pytauri</code> as the <code>plugin-dialog</code> gated feature.</p> Usage <p></p> <pre><code>from pytauri_plugins.dialog import DialogExt, MessageDialogButtons, MessageDialogKind\n\n@commands.command()\nasync def greet(\n    app_handle: AppHandle, webview_window: WebviewWindow\n) -&gt; bytes:\n    file_dialog_builder = DialogExt.file(app_handle)\n    file_dialog_builder.pick_files(\n        lambda files: print(f\"Files selected: {files}\"),\n        add_filter=(\"markdown\", [\"md\"]),\n        set_parent=webview_window,\n        set_title=\"Select a Markdown file\",\n    )\n\n    message_dialog_builder = DialogExt.message(app_handle, \"Hello!\")\n    message_dialog_builder.show(\n        lambda is_ok: print(f\"Dialog closed with: {is_ok}\"),\n        parent=webview_window,\n        buttons=MessageDialogButtons.OkCancelCustom(\"ok\", \"cancel\"),\n        kind=MessageDialogKind.Info,\n    )\n\n    return b\"null\"\n</code></pre>"},{"location":"CHANGELOG/#integrate-plugins-as-features","title":"Integrate plugins as features","text":"<ul> <li>#160 - feat(pytauri)!: integrate <code>plugin-notification</code> as a gated-feature of <code>pytauri</code>.</li> </ul> <p>The <code>rs/pytauri-plugin-notification</code> crate and the <code>py/pytauri-plugin-notification</code> package have been removed. Instead, use the <code>plugin-notification</code> feature of the <code>rs/pytauri</code> crate.</p> <p>For details, compare the <code>v0.5</code> and <code>v0.6</code> \"tutorial/using-plugins\" documentation.</p> Migration <pre><code># src-tauri/Cargo.toml\n\n[dependencies]\n-pytauri-plugin-notification = ...\n+pytauri = { version = \"...\", features = [\"plugin-notification\"] }\n</code></pre> <pre><code>// src-tauri/src/lib.rs\n\nmod ext_mod {\n-    #[pymodule_export]\n-    use pytauri_plugin_notification::notification;\n}\n</code></pre> <pre><code># src-tauri/pyproject.toml\n\n[project]\ndependencies = [\n-    pytauri-plugin-notification = ...\n]\n</code></pre> <pre><code># src-tauri/python/__init__.py\n\n-from pytauri_plugin_notification import NotificationExt\n+from pytauri_plugins.notification import NotificationExt\n</code></pre>"},{"location":"CHANGELOG/#breaking_1","title":"BREAKING","text":"<ul> <li> <p>#166 - fix(standalone)!: standalone binary not working on MacOS.</p> Patch <code>install_name</code> for <code>libpython3.*.dylib</code> of <code>python-build-standalone</code> <p>See: https://github.com/pytauri/pytauri/issues/99#issuecomment-2704556726.</p> <p>The <code>install_name</code> of <code>libpython3.*.dylib</code> built by <code>python-build-standalone</code> does not include <code>@rpath</code>, which makes the <code>rpath</code> set for the executable ineffective.</p> <p>Migration</p> <p>Until this is fixed upstream in <code>python-build-standalone</code>, you need to manually patch the <code>install_name</code>:</p> <pre><code>install_name_tool -id '@rpath/libpython3.13.dylib' /the/path/to/pyembed/python/lib/libpython3.13.dylib\n</code></pre> Do not create more than one <code>App</code> instance <p>See: https://github.com/tauri-apps/tauri/issues/12934</p> <p><code>tauri</code> does not allow creating more than one <code>App</code> instance per process. Previously, we were unaware of this limitation and suggested creating a <code>sample_app</code> to obtain the <code>resource_dir</code>, which subsequently caused a panic in <code>App</code> in <code>__init__.py</code>.</p> <p>Migration</p> <p>https://github.com/pytauri/create-pytauri-app/pull/1/commits/6813b7df4211d711fc962f251e7bedeb9a2378d0</p> </li> <li> <p>#161 - refactor(pytauri)!: refactor <code>BuilderArgs</code> to <code>TypedDict</code>.</p> Migration <pre><code>app = builder_factory().build(\n-    BuilderArgs(\n-        context=context_factory(),\n-        invoke_handler=commands.generate_handler(portal),\n-    )\n+    context=context_factory(),\n+    invoke_handler=commands.generate_handler(portal),\n)\n</code></pre> </li> <li> <p>#157 - feat(pytauri)!: <code>Position.Physical(x, y)</code> -&gt; <code>Position.Physical((x, y))</code>.</p> <p>These APIs have changed:</p> <ul> <li><code>Position.Physical</code></li> <li><code>Position.Logical</code></li> <li><code>Size.Physical</code></li> <li><code>Size.Logical</code></li> </ul> Migration <pre><code>from pytauri import Position, PositionType, Size, SizeType\n\ndef foo(pos: PositionType, size: SizeType) -&gt; None:\n    match pos:\n-        case Position.Physical(x, y):\n+        case Position.Physical((x, y)):\n            print(f\"Physical position: {x}, {y}\")\n-        case Position.Logical(x, y):\n+        case Position.Logical((x, y)):\n            print(f\"Logical position: {x}, {y}\")\n    match size:\n-        case Size.Physical(w, h):\n+        case Size.Physical((w, h)):\n            print(f\"Physical size: {w}, {h}\")\n-        case Size.Logical(w, h):\n+        case Size.Logical((w, h)):\n            print(f\"Logical size: {w}, {h}\")\n\n-foo(pos=Position.Physical(1, 2), size=Size.Physical(3, 4))\n+foo(pos=Position.Physical((1, 2)), size=Size.Physical((3, 4)))\n</code></pre> </li> </ul>"},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li> <p>#157 - feat(pytauri): fully implement <code>tauri::RunEvent</code> bindings.</p> <ul> <li> <p><code>mod tauri::</code></p> <ul> <li><code>Theme</code></li> <li><code>CloseRequestApi</code></li> <li><code>ExitRequestApi</code></li> <li><code>DragDropEvent</code> (<code>DragDropEventType</code>)</li> <li><code>WebviewEvent</code> (<code>WebviewEventType</code>)</li> <li><code>WindowEvent</code> (<code>WindowEventType</code>)</li> <li><code>RunEvent::{ExitRequested::api, WebviewEvent::event, WindowEvent::event}</code> fields</li> <li><code>webview::WebviewWindow::{on_webview_event, on_window_event}</code> methods</li> <li><code>AppHandle::set_theme</code> and <code>webview::WebviewWindow::{set_theme, theme}</code> methods</li> </ul> </li> <li> <p>add <code>_NonExhaustive</code> field to all <code>#[non_exhaustive]</code> <code>enum</code>s</p> </li> </ul> Usage <pre><code>from pytauri import AppHandle, Manager, WindowEvent, WindowEventType\n\n\ndef register_window_event_handler(app_handle: AppHandle):\n    webview_window = Manager.get_webview_window(app_handle, \"main\")\n    assert webview_window is not None\n\n    close_requested = False\n\n    def window_event_handler(event: WindowEventType) -&gt; None:\n        nonlocal close_requested\n        match event:\n            case WindowEvent.CloseRequested(api=api):\n                if not close_requested:\n                    print(\"Preventing window closing\")\n                    api.prevent_close()\n                    close_requested = True\n            case WindowEvent.Focused(focused):\n                print(f\"Window focused: {focused}\")\n            case WindowEvent.Moved((x, y)):\n                print(f\"Moved to ({x}, {y})\")\n            case _:\n                pass\n\n    webview_window.on_window_event(window_event_handler)\n</code></pre> </li> <li> <p>#158 - chore: bump <code>pyo3</code> to <code>0.25</code>.</p> </li> </ul>"},{"location":"CHANGELOG/#050","title":"0.5.0","text":""},{"location":"CHANGELOG/#highlights_3","title":"Highlights","text":""},{"location":"CHANGELOG/#wheel-on-windows-arm64","title":"Wheel on Windows Arm64","text":"<ul> <li>#139 - feat: add support for the <code>windows-11-arm</code> platform wheel.</li> </ul> <p>You can now install <code>pytauri-wheel</code> from PyPI on Windows 11 Arm64.</p>"},{"location":"CHANGELOG/#using-unreleased-commits","title":"Using Unreleased Commits","text":"<ul> <li>#147 - feat: support installation from git repository.</li> </ul> <p>See: https://pytauri.github.io/pytauri/0.5/usage/using-unreleased-commits/</p>"},{"location":"CHANGELOG/#accessing-the-request-headers","title":"Accessing the request headers","text":"<ul> <li>#136 - feat(pytauri): accessing the request headers in <code>Commands</code>.</li> </ul> <p>See: https://pytauri.github.io/pytauri/0.5/usage/concepts/ipc/#accessing-request-headers</p>"},{"location":"CHANGELOG/#protect-source-code","title":"Protect source code","text":"<ul> <li>#134 - docs: add tutorial on using <code>Cython</code> to protect source code.</li> </ul> <p>See: https://pytauri.github.io/pytauri/0.5/usage/tutorial/build-standalone-cython/</p>"},{"location":"CHANGELOG/#breaking_2","title":"BREAKING","text":"<ul> <li>#136 - <code>tauri v2.5</code> requires upgrading <code>@tauri-apps/api: ^2.5</code> and <code>tauri-plugin-pytauri-api: ^0.5</code>.</li> <li>#141 - feat(pytauri)!: <code>pytauri.path.PathResolver</code> now returns a <code>pathlib.Path</code> object instead of a <code>str</code>.</li> <li> <p>#133 - fix(pytauri)!: make <code>BuilderArgs.invoke_handler</code> as required parameter for #110.</p> <p>If you do not specify <code>invoke_handler</code>, <code>pytauri</code> will not register the <code>tauri-plugin-pytauri</code> plugin, which means you cannot use <code>pyInvoke</code> in the frontend to call <code>Commands</code> (you will receive an error like \"plugin pytauri not found\"). If this is indeed the behavior you expect, explicitly pass <code>None</code>.</p> </li> </ul>"},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>#141 - chore: bump <code>pyo3</code> to <code>0.24.1</code>.</li> <li>#124 - #136 - chore: bump <code>tauri</code> dependencies:<ul> <li><code>tauri</code> to <code>2.5.1</code></li> <li><code>tauri-utils</code> to <code>~2.4</code></li> <li><code>tauri-build</code> to <code>2.2</code></li> <li><code>tauri-plugin</code> to <code>2.2</code></li> <li><code>tauri-plugin-notification</code> to <code>2.2</code></li> <li><code>tauri-plugin-opener</code> to <code>2.2</code></li> <li><code>@tauri-apps/api</code> to <code>^2.5</code></li> <li><code>@tauri-apps/plugin-opener</code> to <code>^2.2</code></li> <li><code>@tauri-apps/plugin-dialog</code> to <code>^2.2</code></li> </ul> </li> </ul>"},{"location":"CHANGELOG/#docs","title":"Docs","text":"<ul> <li>#124 - docs: update example to use <code>App.run_return</code> instead of <code>App.run</code>, allowing cleanup tasks to be performed after the app exits (e.g., shutting down the <code>nicegui</code> server) and retrieving the exit code.</li> </ul>"},{"location":"CHANGELOG/#040","title":"0.4.0","text":""},{"location":"CHANGELOG/#highlights_4","title":"Highlights","text":""},{"location":"CHANGELOG/#precompiled-python-wheel-goodbye-rust-compiler","title":"Precompiled python wheel (goodbye Rust compiler)","text":"<ul> <li>#117 - docs: add usage docs for <code>pytauri-wheel</code></li> <li>#108 - feat: initial precompiled python wheel support</li> </ul> <p>In <code>v0.4.0</code>, we have introduced an exciting new feature: precompiled Python wheel support! \ud83c\udf89</p> <p>This means you can use PyTauri without writing any Rust code or needing a Rust compiler.</p> <p>This allows you to perform full-stack development in pure Python (like <code>pywebview</code> but battery-included \ud83e\udd13).</p> <p>Please refer to the PyTauri Wheel documentation for more information.</p>"},{"location":"CHANGELOG/#new-logo-for-pytauri","title":"New logo for PyTauri","text":"<p>Thanks to @ISOR3X in #111! PyTauri now has its own logo \ud83c\udf89:</p> <p></p> <p>It is indeed a snake, but not eating a bean, or perhaps it was not intended to be. It is more so a combination of the Tauri logo (two dots with rings around them) and the Python logo (the snake, specifically the head). The left part is more intended to visualize the snake curling around. Perhaps it is a bit too abstract.</p>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>#63 - chore: bump <code>tauri</code> to <code>v2.3</code>.</li> </ul>"},{"location":"CHANGELOG/#internal","title":"Internal","text":"<ul> <li>#119 - ci(rs/release): add <code>--no-verify</code> to <code>cargo publish</code> so that we can release parallelly.</li> <li>#113 - ci: add <code>macos-latest</code> os in <code>lint-test</code> CI.</li> <li>#111 - docs: added PyTauri logo and updated documentation colors</li> <li>#103 - chore: transfer repo to <code>pytauri</code> org.</li> </ul>"},{"location":"CHANGELOG/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/#highlights_5","title":"Highlights","text":"<ul> <li> <p>menu and tray python API bindings, see <code>pytauri</code> changelog for more details.</p> tray menu </li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>#79 - bump <code>rust-version = \"1.82\"</code></li> </ul>"},{"location":"CHANGELOG/#docs_1","title":"Docs","text":"<ul> <li>#88 - docs: add rust api reference section.</li> <li>#85 - docs: add concepts <code>IPC</code> and <code>using multiprocessing</code> sections.</li> <li>#80 - <code>example/nicegui-app</code>:<ul> <li>Use <code>BuilderArgs.setup</code> for initialization instead of listening to the <code>RunEvent.Ready</code> event.</li> <li>Rewrite the <code>FrontServer</code> <code>startup</code>/<code>shutdown</code> event hook logic.</li> <li>Modularize the code.</li> </ul> </li> <li>#79 - <code>example/nicegui-app</code>:<ul> <li>use <code>tray</code> and <code>menu</code> feature</li> <li>use <code>python3.10</code> <code>match</code> statement instead of <code>if-else</code> statement</li> <li>bump <code>requires-python = \"&gt;=3.10\"</code></li> </ul> </li> </ul>"},{"location":"CHANGELOG/#internal_1","title":"Internal","text":"<ul> <li>#81 - ci: add <code>clear-cache.yml</code> workflow.</li> </ul>"},{"location":"CHANGELOG/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/#breaking_3","title":"BREAKING","text":"<ul> <li>#70 - feat(notification): removed <code>NotificationBuilderArgs</code>.     See <code>CHANGELOG.md</code> of <code>py/pytauri-plugin-notification</code> for how to migrate.</li> <li>#57 - refactor(py/pytauri): remove <code>RunEventEnum</code>, use matched <code>RunEvent</code> directly.     See <code>CHANGELOG.md</code> of <code>py/pytauri</code> for how to migrate.</li> <li>#56 - perf(pytauri): all IPC methods that previously accepted <code>bytearray</code> as a parameter now only accept <code>bytes</code> as a parameter.</li> <li>#52 - refactor(standalone)!: new API for preparing python interpreter.     The <code>pytauri::standalone</code> module has been completely rewritten.     Previously, you used <code>prepare_freethreaded_python_with_executable</code> and <code>append_ext_mod</code>. Now, you need to use <code>PythonInterpreterBuilder</code>.     See the <code>pytauri</code> crate rust API docs and tutorial (examples/tauri-app) <code>main.rs</code> code for more information on how to migrate.</li> </ul>"},{"location":"CHANGELOG/#docs_2","title":"Docs","text":"<ul> <li>#60 - update <code>examples</code> <code>main.rs</code> to remove <code>resource_dir()</code> UNC path prefix <code>\\\\?\\</code> for <code>PythonInterpreterEnv::Standalone</code>. Fix pallets/jinja#1675 for <code>nicegui-app</code> standalone example.</li> <li>#55 - Add <code>integrate with nicegui</code> example <code>nicegui-app</code>. See <code>examples/nicegui-app</code>.</li> <li>#52 - update <code>examples/tauri-app</code> <code>main.rs</code> for new API to prepare python interpreter.</li> <li>#52 - add the usage of <code>multiprocessing.freeze_support</code> in <code>examples/tauri-app</code> <code>__main__.py</code>.</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>#46 - bump <code>tauri</code> to <code>v2.2</code></li> </ul>"},{"location":"CHANGELOG/#internal_2","title":"Internal","text":"<ul> <li>#83 - chore: bump <code>pyo3</code> to <code>v0.23.4</code> in <code>Cargo.lock</code> to fix PyO3/pyo3#4828.</li> <li>#64 - test: add integration tests for <code>command</code> and <code>channel</code> ipc</li> </ul>"},{"location":"CHANGELOG/#010-beta","title":"0.1.0-beta","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/","title":"tauri-plugin-pytauri-api","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#breaking","title":"BREAKING","text":"<ul> <li> <p>#178 - feat(plugin-api)!: remove <code>rawPyInvoke</code> and <code>Channel</code>.</p> <p>Migration</p> <pre><code>-import { rawPyInvoke, Channel } from \"tauri-plugin-pytauri-api\";\n+import { pyInvoke } from \"tauri-plugin-pytauri-api\";\n+import { Channel } from \"@tauri-apps/api/core\";\n</code></pre> <p>Before <code>v0.7</code>, IPC between Python and the frontend always used <code>bytes</code>/<code>ArrayBuffer</code> for data transfer. <code>pyInvoke</code> and <code>Channel.addJsonListener</code> would force serialization and deserialization of input and output, while <code>rawPyInvoke</code> and <code>Channel.onmessage</code> would directly send and receive raw <code>ArrayBuffer</code> data. This mechanism has been improved in <code>v0.7</code>:</p> <ul> <li> <p>Now, <code>pyInvoke</code> automatically chooses whether to serialize based on your input type:</p> <ul> <li><code>ArrayBuffer</code>/<code>Uint8Array</code> will be sent directly to the backend.</li> <li>Other types (<code>any</code>) will be converted to <code>ArrayBuffer</code> using <code>JSON.stringify</code> and <code>TextEncoder</code> before being sent to the backend.</li> </ul> <p>Only the backend can decide whether to deserialize or accept the raw bytes data.</p> </li> <li> <p>Only the backend can decide whether to return deserialized JSON data or raw <code>ArrayBuffer</code> data:</p> <ul> <li>If <code>Command</code> returns a <code>bytes</code> type or Channel.send sends a <code>bytes</code> type, the frontend will receive an <code>ArrayBuffer</code>.</li> <li>If <code>Command</code> returns other types (<code>BaseModel</code>/<code>Any</code>) and Channel.send sends a <code>str</code> type, the frontend will receive automatically deserialized JSON data.</li> </ul> </li> </ul> <p>Therefore:</p> <ul> <li><code>pyInvoke</code> replaces <code>rawPyInvoke</code></li> <li><code>import { Channel } from \"@tauri-apps/api/core\"</code> replaces <code>import { Channel } from \"tauri-plugin-pytauri-api\"</code>.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#060","title":"0.6.0","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#050","title":"0.5.0","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#added","title":"Added","text":"<ul> <li> <p>#136 - feat(pytauri): accessing the request headers in <code>Commands</code>:</p> <p>Added <code>options?: InvokeOptions</code> parameter to <code>rawPyInvoke</code> and <code>pyInvoke</code>.</p> </li> </ul>"},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#040","title":"0.4.0","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#added_1","title":"Added","text":"<ul> <li>#50 - feat: add <code>class Channel extends TauriChannel&lt;ArrayBuffer&gt;</code> for pytauri channels ipc.</li> </ul>"},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#docs","title":"Docs","text":"<ul> <li>#50 - add tsdoc for all classes and functions.</li> </ul>"},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/py/codelldb/","title":"codelldb","text":""},{"location":"CHANGELOG/py/codelldb/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/py/codelldb/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/py/pyo3-utils/","title":"pyo3-utils","text":""},{"location":"CHANGELOG/py/pyo3-utils/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/py/pyo3-utils/#010-beta1","title":"0.1.0-beta.1","text":""},{"location":"CHANGELOG/py/pyo3-utils/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/py/pytauri-wheel/","title":"pytauri-wheel","text":""},{"location":"CHANGELOG/py/pytauri-wheel/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/py/pytauri-wheel/#fixed","title":"Fixed","text":"<ul> <li> <p>#175 - fix: bump <code>tauri-plugin-*</code> to fix rust docs build failures on <code>docs.rs</code>.</p> <p>See tauri-apps/tauri#13597 for details.</p> <ul> <li><code>tauri-plugin-opener = { version = \"2.3.0\" }</code></li> <li><code>tauri-plugin-clipboard-manager = { version = \"2.2.3\" }</code></li> <li><code>tauri-plugin-dialog = { version = \"2.2.2\" }</code></li> <li><code>tauri-plugin-fs = { version = \"2.3.0\" }</code></li> <li><code>tauri-plugin-notification = { version = \"2.2.3\" }</code></li> </ul> </li> </ul>"},{"location":"CHANGELOG/py/pytauri-wheel/#060","title":"0.6.0","text":""},{"location":"CHANGELOG/py/pytauri-wheel/#added","title":"Added","text":"<ul> <li>#165 - feat: enable <code>tauri-plugin-notification</code> and integrate <code>pytauri_plugins</code>.</li> </ul>"},{"location":"CHANGELOG/py/pytauri-wheel/#050","title":"0.5.0","text":""},{"location":"CHANGELOG/py/pytauri-wheel/#highlights","title":"Highlights","text":"<ul> <li>#139 - feat: add support for the <code>windows-11-arm</code> platform wheel.</li> </ul>"},{"location":"CHANGELOG/py/pytauri-wheel/#040","title":"0.4.0","text":"<p>the first release</p>"},{"location":"CHANGELOG/py/pytauri/","title":"pytauri","text":""},{"location":"CHANGELOG/py/pytauri/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/py/pytauri/#added","title":"Added","text":"<ul> <li>#179 - feat(pytauri): generate typescript client for IPC.<ul> <li><code>pytauri.ipc.Commands</code><ul> <li><code>__init__(*, experimental_gen_ts)</code> parameter</li> <li><code>def experimental_gen_ts</code></li> <li><code>def experimental_gen_ts_background</code></li> </ul> </li> </ul> </li> <li> <p>#178 - feat(plugin-api)!: remove <code>rawPyInvoke</code> and <code>Channel</code>.</p> <p>Channel.send, Invoke.resolve and InvokeResolver.resolve now can send <code>Union[bytes, str]</code>:</p> <ul> <li>If <code>str</code>, it will be deserialized as JSON on the frontend.</li> <li>If <code>bytes</code>, it will be sent as <code>ArrayBuffer</code> to the frontend.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/py/pytauri/#060","title":"0.6.0","text":""},{"location":"CHANGELOG/py/pytauri/#breaking","title":"BREAKING","text":"<ul> <li>#161 - refactor(pytauri)!: refactor <code>BuilderArgs</code> to <code>TypedDict</code>.</li> <li>#157 - feat!: <code>Position.Physical(x, y)</code> -&gt; <code>Position.Physical((x, y))</code>. See home <code>/CHANGELOG</code> for more details.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#added_1","title":"Added","text":"<ul> <li>#163 - feat(plugin): implement <code>tauri-plugin-dialog</code> bindings.</li> <li> <p>#160 - feat!: integrate <code>plugin-notification</code> as a gated-feature of <code>pytauri</code>.</p> <p>Added: <code>pytauri_plugins::notification::NotificationBuilderArgs</code>.</p> </li> <li> <p>#157 - feat: fully implement <code>tauri::RunEvent</code> bindings.</p> </li> </ul>"},{"location":"CHANGELOG/py/pytauri/#fixed","title":"Fixed","text":"<ul> <li> <p>#157 - fix(typing): namedtuple member name can't start with underscore.</p> <p>ref: https://github.com/python/typing/pull/1979#issuecomment-2889160095</p> <p>bump <code>pyright</code> to <code>^1.1.400</code></p> </li> </ul>"},{"location":"CHANGELOG/py/pytauri/#050","title":"0.5.0","text":""},{"location":"CHANGELOG/py/pytauri/#breaking_1","title":"BREAKING","text":"<ul> <li>#141 - feat!: <code>pytauri.path.PathResolver</code> now returns a <code>pathlib.Path</code> object instead of a <code>str</code>.</li> <li>#133 - fix(pytauri)!: make <code>BuilderArgs.invoke_handler</code> as required parameter for #110.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#added_2","title":"Added","text":"<ul> <li> <p>#136 - feat(pytauri): accessing the request headers in <code>Commands</code>:</p> <p>Added <code>ipc.Headers</code>, <code>ipc.ParametersType.headers</code> and <code>ipc.ArgumentsType.headers</code>.</p> </li> <li> <p>#124 - feat: introduce <code>App::run_return</code>:</p> <p>Unlike <code>App::run</code>, which terminates the entire process, <code>App::run_return</code> allows you to perform cleanup tasks after the app exits. For example, you can use <code>sys.exit(app.run_return())</code> to gracefully finalize the Python interpreter with an exit code.</p> </li> </ul>"},{"location":"CHANGELOG/py/pytauri/#deprecated","title":"Deprecated","text":"<ul> <li>#124 - fix: deprecate <code>App::run_iteration</code>.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#040","title":"0.4.0","text":""},{"location":"CHANGELOG/py/pytauri/#added_3","title":"Added","text":"<ul> <li>#62 - feat: add <code>path::PathResolver</code>, <code>Manager::path</code>.</li> <li>#61 - feat: add <code>Emitter</code>, <code>EventTarget</code>, <code>EventTargetType</code>, <code>ImplEmitter</code> for Event System.</li> <li>#63 - feat: add <code>Url</code> and <code>webview::WebviewWindow::navigate</code>.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/py/pytauri/#added_4","title":"Added","text":"<ul> <li>#83 - feat: add <code>def Context.set_assets</code> and <code>class Assets</code> to allow using custom assets (e.g, loading from memory/disk).</li> <li>#80 - feat: <code>BuilderArgs</code>:<ul> <li>add <code>BuilderArgs::setup</code> to support tauri app setup hook.</li> <li><code>BuilderArgs::context</code> now can be <code>Position and Keyword</code> arguments.</li> </ul> </li> <li>#79 - feat: implement tauri <code>tray</code> feature:     enable <code>tauri/tray-icon</code> feature<ul> <li><code>mod tauri::</code><ul> <li><code>Rect</code></li> <li><code>Size</code></li> <li><code>enum RunEvent::{MenuEvent, TrayIconEvent}</code></li> <li><code>AppHandle::{run_on_main_thread, exit, restart, on_tray_icon_event, tray_by_id, remove_tray_by_id, default_window_icon, invoke_key}</code></li> </ul> </li> <li><code>mod tauri::tray</code></li> <li><code>mod webview::</code><ul> <li><code>WebviewWindow::{run_on_main_thread, set_icon}</code></li> </ul> </li> </ul> </li> <li>#75 - feat: implement tauri <code>menu</code> feature:<ul> <li><code>mod tauri::</code><ul> <li><code>AppHandle::{on_menu_event, menu, set_menu, remove_menu, hide_menu, show_menu}</code></li> <li><code>Position</code></li> <li><code>PositionType</code></li> </ul> </li> <li><code>mod tauri::menu</code></li> <li><code>mod tauri::image</code></li> <li><code>mod tauri::window</code></li> <li><code>mod tauri::webview</code><ul> <li><code>WebviewWindow::{on_menu_event, menu, set_menu, remove_menu, hide_menu, show_menu, is_menu_visible, popup_menu, popup_menu_at}</code></li> <li><code>Webview::window</code></li> </ul> </li> </ul> </li> <li>#75 - feat: add <code>pillow &gt;= 11.1</code> as dependency.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#changed","title":"Changed","text":"<ul> <li>#76 - perf: use <code>pyo3::intern!</code> in <code>Invoke::bind_to</code> for commands <code>IPC</code> performance.</li> <li>#75 - perf: all methods of <code>WebviewWindow</code> will release the <code>GIL</code> now.</li> <li>#75 - perf: <code>App::{run, run_iteration}</code> will use a singleton <code>Py&lt;AppHandle&gt;</code> as an argument instead of fetching it from <code>tauri::State</code> each loop.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#internal","title":"Internal","text":"<ul> <li>#79 - <code>ffi.ipc.JavaScriptChannelId.from_str</code> becomes <code>staticmethod</code> from <code>classmethod</code>.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/py/pytauri/#breaking_2","title":"BREAKING","text":"<ul> <li> <p>#57 - refactor: remove <code>RunEventEnum</code>, use matched <code>RunEvent</code> directly.     Previously:</p> <pre><code>def callback(app_handle: AppHandle, run_event: RunEvent) -&gt; None:\n    run_event_enum: RunEventEnumType = run_event.match_ref()\n    match run_event_enum:\n        case RunEventEnum.Ready: ...\n\napp.run(callback)\n</code></pre> <p>Now:</p> <pre><code>def callback(app_handle: AppHandle, run_event: RunEventType) -&gt; None:\n    match run_event:\n        case RunEvent.Ready: ...\n\napp.run(callback)\n</code></pre> </li> <li> <p>#56 - perf: all IPC methods that previously accepted <code>bytearray</code> as a parameter now only accept <code>bytes</code> as a parameter.</p> </li> </ul>"},{"location":"CHANGELOG/py/pytauri/#added_5","title":"Added","text":"<ul> <li>#50 - feat: add <code>ipc::Channel</code>, <code>ipc::JavaScriptChannelId</code>, <code>webview::Webview</code>, <code>webview::WebviewWindow::as_ref::&lt;webview&gt;</code> for channels ipc.</li> <li>#46 - feat: add <code>webview::WebviewWindow</code>, <code>Manager</code>, <code>ImplManager</code>, <code>App::handle</code>.</li> <li>#48 - feat: accessing the <code>WebviewWindow</code> in <code>Commands</code>.</li> <li>#49 - feat: add <code>Event</code>, <code>EventId</code>, <code>Listener</code>, <code>ImplListener</code> for Event System.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#internal_1","title":"Internal","text":"<ul> <li>#54<ul> <li>feat: import the extension module from <code>sys.modules[\"__pytauri_ext_mod__\"]</code> if on standalone mode (<code>sys._pytauri_standalone</code>).</li> <li>feat: support specifying <code>entry_point</code> package name which be used to import the extension module via <code>os.environ[\"_PYTAURI_DIST\"]</code> (only for non-standalone mode).</li> </ul> </li> </ul>"},{"location":"CHANGELOG/py/pytauri/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/rs/pyo3-utils/","title":"pyo3-utils","text":""},{"location":"CHANGELOG/rs/pyo3-utils/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/rs/pyo3-utils/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/rs/pyo3-utils/#added","title":"Added","text":"<ul> <li> <p>#160 - feat: added unstable mod <code>from_py_dict</code>.</p> <p>Refer to PyO3/pyo3#5163.</p> </li> <li> <p>#158 - chore: bump <code>pyo3</code> to <code>0.25</code>.</p> </li> </ul>"},{"location":"CHANGELOG/rs/pyo3-utils/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/rs/pyo3-utils/#added_1","title":"Added","text":"<ul> <li>#141 - chore: bump <code>pyo3</code> to <code>0.24.1</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pyo3-utils/#010","title":"0.1.0","text":""},{"location":"CHANGELOG/rs/pyo3-utils/#docs","title":"Docs","text":"<ul> <li>#57 - add documentation to <code>mod py_match</code> indicating it should only be used for <code>state-machine-like</code> <code>enum</code>, not for <code>Union-like</code> <code>enum</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pyo3-utils/#internal","title":"Internal","text":"<ul> <li>#79 - refactor: use <code>rust v1.82</code> feature <code>Omitting empty types in pattern matching</code> in place of <code>Result&lt;T, Infallible&gt;::unwrap</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pyo3-utils/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/rs/pytauri-core/","title":"pytauri-core","text":""},{"location":"CHANGELOG/rs/pytauri-core/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/rs/pytauri-core/#added","title":"Added","text":"<ul> <li> <p>#178 - feat(plugin-api)!: remove <code>rawPyInvoke</code> and <code>Channel</code>.</p> <p>Channel.send, Invoke.resolve and InvokeResolver.resolve now can send <code>Union[bytes, str]</code>:</p> <ul> <li>If <code>str</code>, it will be deserialized as JSON on the frontend.</li> <li>If <code>bytes</code>, it will be sent as <code>ArrayBuffer</code> to the frontend.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#061","title":"0.6.1","text":"<ul> <li>#175 - fix(pytauri): bump <code>tauri-plugin-*</code> to fix rust docs build failures on <code>docs.rs</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#060","title":"0.6.0","text":""},{"location":"CHANGELOG/rs/pytauri-core/#breaking","title":"BREAKING","text":"<ul> <li>#163 - refactor: <code>ext_mod::Url</code> -&gt; <code>ext_mod::Url&lt;'a'&gt;</code> and removed the implementations of <code>Deref</code> and <code>DerefMut</code>.</li> <li>#157 - feat!: <code>Position.Physical(x, y)</code> -&gt; <code>Position.Physical((x, y))</code>. See home <code>/CHANGELOG</code> for more details.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#added_1","title":"Added","text":"<ul> <li>#163 - feat(plugin): implement <code>tauri-plugin-dialog</code> bindings.</li> <li> <p>#160 - feat!: integrate <code>plugin-notification</code> as a gated-feature of <code>pytauri</code>.</p> <p>Added: <code>pytauri_plugins::notification::NotificationBuilderArgs</code>.</p> </li> <li> <p>#157 - feat: fully implement <code>tauri::RunEvent</code> bindings.</p> </li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#internal","title":"Internal","text":"<ul> <li>#155 - refactor: modularize <code>ext_mod_impl::self</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#050","title":"0.5.0","text":""},{"location":"CHANGELOG/rs/pytauri-core/#breaking_1","title":"BREAKING","text":"<ul> <li>#141 - feat!: <code>pytauri.path.PathResolver</code> now returns a <code>pathlib.Path</code> object instead of a <code>str</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#added_2","title":"Added","text":"<ul> <li>#136 - feat(pytauri): accessing the request headers in <code>Commands</code>.</li> <li>#124 - feat: introduce <code>App::run_return</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#deprecated","title":"Deprecated","text":"<ul> <li>#124 - fix: deprecate <code>App::run_iteration</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#040","title":"0.4.0","text":""},{"location":"CHANGELOG/rs/pytauri-core/#added_3","title":"Added","text":"<ul> <li>#62 - feat: add <code>path::PathResolver</code>, <code>Manager::path</code>.</li> <li>#61 - feat: add <code>Emitter</code>, <code>EventTarget</code>, <code>EventTargetType</code>, <code>ImplEmitter</code> for Event System.</li> <li>#63 - feat: add <code>Url</code> and <code>webview::WebviewWindow::navigate</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/rs/pytauri-core/#breaking_2","title":"BREAKING","text":"<ul> <li>#80 - refactor: <code>trait PyAppHandleExt</code> is now sealed and no longer has generic parameters.</li> <li>#79 - pref: the fields of <code>enum RunEvent</code> <code>struct</code> variants become <code>Py&lt;T&gt;</code> types from rust types.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#added_4","title":"Added","text":"<ul> <li>#83 - feat: add <code>Context::set_assets</code> to allow using custom assets (e.g, loading from memory/disk).</li> <li>#80 - feat: add <code>PyAppHandleExt::get_or_init_py_app_handle</code>, and the methods return <code>&amp;Py&lt;AppHandle&gt;</code> instead of <code>impl Deref&lt;Target = Py&lt;AppHandle&gt;&gt;</code> now.</li> <li>#79 - feat: implement tauri <code>tray</code> feature:     enable <code>tauri/tray-icon</code> feature<ul> <li><code>mod tauri::</code><ul> <li><code>Rect</code></li> <li><code>Size</code></li> <li><code>enum RunEvent::{MenuEvent, TrayIconEvent}</code></li> <li><code>AppHandle::{run_on_main_thread, exit, restart, on_tray_icon_event, tray_by_id, remove_tray_by_id, default_window_icon, invoke_key}</code></li> </ul> </li> <li><code>mod tauri::tray</code></li> <li><code>mod webview::</code><ul> <li><code>WebviewWindow::{run_on_main_thread, set_icon}</code></li> </ul> </li> </ul> </li> <li>#75 - feat: implement tauri <code>menu</code> feature:<ul> <li><code>mod tauri::</code><ul> <li><code>AppHandle::{on_menu_event, menu, set_menu, remove_menu, hide_menu, show_menu}</code></li> <li><code>Position</code></li> <li><code>PositionType</code></li> </ul> </li> <li><code>mod tauri::menu</code></li> <li><code>mod tauri::image</code></li> <li><code>mod tauri::window</code></li> <li><code>mod tauri::webview</code><ul> <li><code>WebviewWindow::{on_menu_event, menu, set_menu, remove_menu, hide_menu, show_menu, is_menu_visible, popup_menu, popup_menu_at}</code></li> <li><code>Webview::window</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#changed","title":"Changed","text":"<ul> <li>#86 - pref: use <code>Cow&lt;'_, [u8]&gt;</code> instead of <code>Vec&lt;u8&gt;</code> as <code>pymehtods</code>/<code>pyfunction</code> and <code>extract</code> parameters to improve performance.     see PyO3/pyo3#3310 and PyO3/pyo3#2888 for more details.</li> <li>#79 - perf: almost all of pyo3 <code>pymethods</code> will release the <code>GIL</code> now.</li> <li>#76 - perf: use <code>pyo3::intern!</code> in <code>Invoke::bind_to</code> for commands <code>IPC</code> performance.</li> <li>#75 - perf: all methods of <code>WebviewWindow</code> will release the <code>GIL</code> now.</li> <li>#75 - perf: <code>App::{run, run_iteration}</code> will use a singleton <code>Py&lt;AppHandle&gt;</code> as an argument instead of fetching it from <code>tauri::State</code> each loop.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#internal_1","title":"Internal","text":"<ul> <li>#83 - refactor: add trait <code>utils::PyResultExt</code> to handle unraisable <code>PyErr</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/rs/pytauri-core/#breaking_3","title":"BREAKING","text":"<ul> <li>#57 - refactor: remove <code>RunEventEnum</code>, use matched <code>RunEvent</code> directly.</li> <li>#56 - perf: <code>Invoke::bind_to</code> now returns <code>[Self::BODY_KEY]</code>: <code>PyBytes</code> instead of <code>PyByteArray</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#added_5","title":"Added","text":"<ul> <li>#50 - feat: add <code>ipc::Channel</code>, <code>ipc::JavaScriptChannelId</code>, <code>webview::Webview</code>, <code>webview::WebviewWindow::as_ref::&lt;webview&gt;</code> for channels ipc.</li> <li>#46 - feat: add <code>webview::WebviewWindow</code>, <code>Manager</code>, <code>ImplManager</code>, <code>App::handle</code>.</li> <li>#48 - feat: accessing the <code>WebviewWindow</code> in <code>Commands</code>.</li> <li>#49 - feat: add <code>Event</code>, <code>EventId</code>, <code>Listener</code>, <code>ImplListener</code> for Event System.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#010-beta1","title":"0.1.0-beta.1","text":""},{"location":"CHANGELOG/rs/pytauri-core/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/rs/pytauri/","title":"pytauri","text":""},{"location":"CHANGELOG/rs/pytauri/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/rs/pytauri/#061","title":"0.6.1","text":"<ul> <li>#175 - fix(pytauri): bump <code>tauri-plugin-*</code> to fix rust docs build failures on <code>docs.rs</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#060","title":"0.6.0","text":""},{"location":"CHANGELOG/rs/pytauri/#breaking","title":"BREAKING","text":"<ul> <li>#161 - refactor(pytauri)!: refactor <code>BuilderArgs</code> to <code>TypedDict</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#added","title":"Added","text":"<ul> <li>#160 - feat!: integrate <code>plugin-notification</code> as a gated-feature of <code>pytauri</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#fixed","title":"Fixed","text":"<ul> <li>#159 - fix(standalone): explicitly pass <code>PyString</code> to <code>multiprocessing.set_executable</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#050","title":"0.5.0","text":""},{"location":"CHANGELOG/rs/pytauri/#breaking_1","title":"BREAKING","text":"<ul> <li>#133 - fix(pytauri)!: make <code>BuilderArgs.invoke_handler</code> as required parameter for #110.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#040","title":"0.4.0","text":""},{"location":"CHANGELOG/rs/pytauri/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/rs/pytauri/#added_1","title":"Added","text":"<ul> <li>#80 - feat: <code>BuilderArgs</code>:<ul> <li>add <code>BuilderArgs::setup</code> to support tauri app setup hook.</li> <li><code>BuilderArgs::context</code> now can be <code>Position and Keyword</code> arguments.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/rs/pytauri/#breaking_2","title":"BREAKING","text":"<ul> <li>#52 - refactor(standalone)!: new API for preparing python interpreter.     The <code>pytauri::standalone</code> module has been completely rewritten.     Previously, you used <code>prepare_freethreaded_python_with_executable</code> and <code>append_ext_mod</code>. Now, you need to use <code>PythonInterpreterBuilder</code>.     See the <code>pytauri</code> crate rust API docs and tutorial (examples/tauri-app) <code>main.rs</code> code for more information on how to migrate.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#added_2","title":"Added","text":"<ul> <li>#60 - feat: re-export <code>dunce::simplified</code> to remove <code>resource_dir()</code> UNC path prefix <code>\\\\?\\</code> for <code>PythonInterpreterEnv::Standalone</code>. Fix pallets/jinja#1675 for <code>nicegui-app</code> standalone example.</li> <li>#51 - feat: support <code>multiprocessing</code> for standalone app.<ul> <li>For standalone app:<ul> <li>set <code>sys.executable</code> to the actual python interpreter executable path.</li> <li>set <code>sys.argv</code> to <code>std::env::args_os()</code>.</li> <li>set <code>sys.frozen</code> to <code>True</code>.</li> <li>call <code>multiprocessing.set_start_method</code> with<ul> <li>windows: <code>spawn</code></li> <li>unix: <code>fork</code></li> </ul> </li> <li>call <code>multiprocessing.set_executable</code> with <code>std::env::current_exe()</code>.</li> </ul> </li> <li>Add <code>fn is_forking</code> for checking if the app is spawned by <code>multiprocessing</code>.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#internal","title":"Internal","text":"<ul> <li>#54 - feat: export the extension module to <code>sys.modules[\"__pytauri_ext_mod__\"]</code> if on standalone mode.</li> <li>#52 - feat: set <code>sys._pytauri_standalone=True</code> when run on standalone app (i.e., launch from rust).</li> <li>#51 - refactor: use <code>Python::run</code> with <code>locals</code> as arguments to execute <code>_append_ext_mod.py</code> for better performance.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/","title":"tauri-plugin-pytauri","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#060","title":"0.6.0","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#050","title":"0.5.0","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#040","title":"0.4.0","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#added","title":"Added","text":"<ul> <li>Update bound <code>tauri-plugin-pytauri-api</code> to <code>v0.2.0</code>. See it's <code>CHANGELOG.md</code> for more details.</li> </ul>"},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"CONTRIBUTING/#environment-setup","title":"Environment setup","text":"<p>Make sure you have installed <code>Rust</code>, <code>Python</code>, <code>uv</code>, <code>Node.js</code>, <code>pnpm</code>, <code>tauri-cli</code> and Tauri Prerequisites as documented.</p> <p>Also, you need <code>bash</code>. If you are on Windows, you can use Git for Windows.</p> <p>Fork the pytauri repository on GitHub.</p> <pre><code>#!/bin/bash\n\n# clone your fork locally\ngit clone git@github.com:your_name_here/pytauri.git\ncd pytauri\n# create a branch for local development\ngit checkout -b branch-name\n\n# install dev dependencies and build frontend assets\npnpm install\npnpm -r run build\n\n# activate virtual environment\nuv venv --python-preference=only-system\nsource .venv/bin/activate\n# or Windows: `source .venv/Scripts/activate`\n\n# install dev dependencies and tools\nuv sync\n\n# Init pre-commit (installed by `uv sync`)\n# https://pre-commit.com/#3-install-the-git-hook-scripts\npre-commit install\npre-commit run --all-files\n</code></pre> <p>That's all! Now, you can start to develop.</p>"},{"location":"CONTRIBUTING/#ide-setup","title":"IDE setup","text":"<p>We strongly recommend using <code>VSCode</code> with the extensions in <code>.vscode/extensions.json</code>.</p> <p>These extensions will help you to format, lint, type-check, and debug your code.</p>"},{"location":"CONTRIBUTING/#debug","title":"Debug","text":"<p>TODO</p> <ul> <li>check <code>.vscode/launch.json</code> and codelldb for debugging <code>py/rs</code> from python.</li> <li>check vscode/python-debugging for debugging <code>py/rs</code> from rust.</li> </ul>"},{"location":"CONTRIBUTING/#source-code","title":"Source code","text":"<ul> <li>python: members in <code>/pyproject.toml</code></li> <li>rust: menbers in <code>/Cargo.toml</code></li> <li>frontend: members in <code>/package.json</code></li> </ul>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>We use pytest and <code>cargo test</code> to test our code.</p>"},{"location":"CONTRIBUTING/#documentation","title":"Documentation","text":""},{"location":"CONTRIBUTING/#python-and-toturial","title":"Python and Toturial","text":"<p>We use mkdocs, mkdocs-material, mkdocstrings and mike to build our documentation.</p> <p>The documentation source code is in <code>docs/</code>, <code>docs_src/</code>, <code>mkdocs.yml</code>, and <code>utils/</code> (check <code>mkdocs.yml</code> to find others).</p> <p>Live-reloading main docs:</p> <pre><code>mkdocs serve\n</code></pre> <p>Live-reloading versioned docs:</p> <pre><code>mike serve\n</code></pre> <p>Docs references</p> <ul> <li>mkdocs/getting-started</li> <li>mkdocs-material/getting-started</li> <li>mkdocstrings/usage</li> </ul> <p>Tip</p> <p>We use <code>Google</code> style to write python docstrings, please refer to:</p> <ul> <li>mkdocstrings-python's documentation</li> <li>Napoleon's documentation</li> <li>Griffe's documentation</li> </ul>"},{"location":"CONTRIBUTING/#rust","title":"Rust","text":"<pre><code>cargo doc\n</code></pre>"},{"location":"CONTRIBUTING/#frontend","title":"Frontend","text":"<p>TODO</p>"},{"location":"CONTRIBUTING/#pr","title":"PR","text":"<ul> <li>PRs should target the <code>main</code> branch.</li> <li>Keep branches up to date by <code>rebase</code> before merging.</li> <li>Do not add multiple unrelated things in same PR.</li> <li>Do not submit PRs where you just take existing lines and reformat them without changing what they do.</li> <li>Do not change other parts of the code that are not yours for formatting reasons.</li> <li>Do not use your clone's main branch to make a PR - create a branch and PR that.</li> </ul>"},{"location":"CONTRIBUTING/#edit-changelogmd","title":"Edit <code>CHANGELOG.md</code>","text":"<p>If you have made the corresponding changes, please record them in <code>CHANGELOG.md</code>.</p>"},{"location":"CONTRIBUTING/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow Conventional Commits, or <code>pre-commit</code> will reject your commit.</p> <p>Info</p> <p>If you don't know how to finish these, it's okay, feel free to initiate a PR, we will help you continue.</p>"},{"location":"CONTRIBUTING/#ci-checks","title":"CI checks","text":"<p>We will check your commits on GitHub Actions, and your PR will only be merged if it passes the CI checks.</p> <p>You can run these checks locally by executing <code>pre-commit run --all-files</code> in bash.</p> <p>Usually, you don't need to do this manually, because <code>pre-commit</code> will automatically run these checks on each commit as long as you have installed the git hooks via <code>pre-commit install</code>.</p> <p>Tip</p> <p>Some slow checks are not run locally by default. If you really want to run them, pass <code>--hook-stage=manual</code>. You can also look at <code>.pre-commit-config.yaml</code> and run the individual checks yourself if you prefer.</p>"},{"location":"CONTRIBUTING/#_1","title":"\ud83d\ude22","text":"<p>Warning</p> <p>The following \ud83d\udc47 content is for the maintainers of this project, may be you don't need to read it.</p>"},{"location":"CONTRIBUTING/#deploy-docs","title":"Deploy Docs","text":"<p>please refer to <code>.github/workflows/docs.yml</code>.</p> <ul> <li>Every push to the <code>main</code> branch will trigger the <code>dev</code> version docs deployment.</li> <li> <p>Every <code>v*</code> semver tag will trigger the corresponding version docs deployment.</p> <p>Warning</p> <ul> <li>Remember update <code>CHANGELOG.md</code> before pushing the version docs tag!</li> <li>Remember make a Github Release (not package release) manually for the version docs deployment!</li> </ul> </li> </ul>"},{"location":"CONTRIBUTING/#pr-checks","title":"PR Checks","text":"<p>please refer to <code>.github/workflows/lint-test.yml</code>.</p> <ul> <li>Every PR push will trigger the CI checks.</li> </ul>"},{"location":"CONTRIBUTING/#publish-and-release","title":"Publish and Release \ud83d\ude80","text":"<p>Please refer to <code>.github/workflows/publish-*.yml</code>.</p> <ul> <li>Every <code>py|rs|js/package-name/v*</code> semver tag will trigger the corresponding package publish.</li> </ul> <p>First, check-out to a new branch, edit <code>CHANGELOG.md</code> to record the changes and bump the version.</p> <p>Warning</p> <p>Remember also update the dependencies version for workspace members.</p> <p>Then, push the new branch with the signed tag to GitHub, and create a PR to the <code>main</code> branch.</p> <p>Again, the tag must be signed!!!</p> <p>Warning</p> <p>The <code>bump version</code> PR must have only one commit with the corresponding tag; otherwise, it will be rejected.</p> <p>Review the PR, if it's ok, rebase it to <code>main</code> branch in local.</p> <p>DO NOT rebase with tag on GitHub.</p> <p>Refer to:</p> <p>https://docs.github.com/authentication/managing-commit-signature-verification/about-commit-signature-verification#signature-verification-for-rebase-and-merge</p> <p>When you use this option, GitHub creates modified commits using the original commit data and content.</p> <p>This will cause the commits merged into main to be inconsistent with the tagged commits.</p> <p>If you unfortunately do this, you must delete the tag and re-tag the merged commit.</p> <p>Check if everything is ok, for example:</p> <ul> <li>check if the tag is on the <code>main</code> branch.</li> <li>check if the version specified by the tag is correct.</li> <li>check if the dependencies version of workspace members are updated.</li> <li>check if the link in <code>CHANGELOG.md</code> is correct.</li> </ul> <p>If so, make a <code>approve</code> in environment <code>pypi</code>/<code>crates-io</code>/<code>npmjs</code> for the workflow.</p> <p>After that, the <code>publish-*.yml</code> workflow will build and publish the package.</p> <p>Finally, edit the <code>draft release</code> created by <code>publish-*.yml</code> workflow, and publish the release.</p>"},{"location":"reference/rs/","title":"Rust API Reference","text":"<p>It's available on <code>docs.rs</code>, click following badges.</p> name link \ud83d\udc49 core - pytauri pytauri-core tauri-plugin-pytauri \ud83d\udc49 utils - pyo3-utils"},{"location":"reference/py/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pyo3_utils</li> <li>codelldb</li> <li>pytauri<ul> <li>ffi<ul> <li>image</li> <li>ipc</li> <li>lib</li> <li>menu</li> <li>path</li> <li>tray</li> <li>webview</li> <li>window</li> </ul> </li> <li>image</li> <li>ipc</li> <li>menu</li> <li>path</li> <li>tray</li> <li>webview</li> <li>window</li> </ul> </li> <li>pytauri_plugins<ul> <li>dialog<ul> <li>ffi</li> </ul> </li> <li>notification<ul> <li>ffi</li> </ul> </li> </ul> </li> <li>pytauri_wheel<ul> <li>lib</li> </ul> </li> </ul>"},{"location":"reference/py/codelldb/","title":"codelldb","text":""},{"location":"reference/py/codelldb/#codelldb","title":"codelldb","text":"<p>Launch CodeLLDB in debugpy to debug rust code.</p>"},{"location":"reference/py/codelldb/#codelldb--usage","title":"Usage","text":"<p>Tip</p> <p>This package only depends on the Python standard library, so you can integrate it freely.</p>"},{"location":"reference/py/codelldb/#codelldb--configuring-codelldb-rpc-server","title":"Configuring CodeLLDB rpc server","text":"<p>Please refer to the CodeLLDB documentation to set up the rpc server, and add the following content to <code>.vscode/settings.json</code>:</p> <pre><code>{\n  \"lldb.rpcServer\": {\n    \"host\": \"127.0.0.1\",\n    \"port\": 9552,\n    \"token\": \"secret\",\n  }\n}\n</code></pre>"},{"location":"reference/py/codelldb/#codelldb--configuring-python-debugger","title":"Configuring Python Debugger","text":"<p>Please refer to the Python Debugger documentation, and add the following content to <code>.vscode/launch.json</code>:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"python.debug\",\n            \"type\": \"debugpy\",\n            \"purpose\": [\n                \"debug-in-terminal\"\n            ],\n            \"console\": \"integratedTerminal\",\n            \"request\": \"launch\",\n            // see: &lt;https://code.visualstudio.com/docs/python/debugging#_set-configuration-options&gt;\n            \"module\": \"pytauri_demo\", // your module name\n            \"args\": [], // whatever you want\n            // following env vars will be used by `codelldb` package\n            \"env\": {\n                \"VSCODE_RUST_DEBUG\": \"${input:rustDebug}\",\n                // keep the following env vars in sync with `.vscode/settings.json`\n                \"VSCODE_LLDB_RPC_SERVER_HOST\": \"127.0.0.1\",\n                \"VSCODE_LLDB_RPC_SERVER_PORT\": \"9552\",\n                \"VSCODE_LLDB_RPC_SERVER_TOKEN\": \"secret\",\n            },\n        }\n    ],\n    // see: &lt;https://code.visualstudio.com/docs/editor/variables-reference#_input-variables&gt;\n    \"inputs\": [\n        {\n            \"type\": \"pickString\",\n            \"id\": \"rustDebug\",\n            \"description\": \"Whether to enable Rust debugging\",\n            \"options\": [\n                {\n                    \"label\": \"Enabled\",\n                    \"value\": \"1\"\n                },\n                {\n                    \"label\": \"Disabled\",\n                    \"value\": \"0\"\n                }\n            ],\n            \"default\": \"0\"\n        },\n    ]\n}\n</code></pre>"},{"location":"reference/py/codelldb/#codelldb--multi-target-debugging","title":"Multi-target debugging","text":"<p>When starting Python Debugger via <code>F5</code>, you will see a selection box, choose <code>Enabled</code> to enable Rust debugging.</p> <p>Functions:</p> Name Description <code>debug</code> <p>Launch CodeLLDB to debug rust code.</p>"},{"location":"reference/py/codelldb/#codelldb.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['debug']\n</code></pre>"},{"location":"reference/py/codelldb/#codelldb.VSCODE_RUST_DEBUG_VARNAME","title":"VSCODE_RUST_DEBUG_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_RUST_DEBUG_VARNAME = 'VSCODE_RUST_DEBUG'\n</code></pre> <p>Whether to enable Rust debugging, set to <code>1</code> to enable, <code>0</code> to disable.</p>"},{"location":"reference/py/codelldb/#codelldb.VSCODE_LLDB_RPC_SERVER_HOST_VARNAME","title":"VSCODE_LLDB_RPC_SERVER_HOST_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_LLDB_RPC_SERVER_HOST_VARNAME = 'VSCODE_LLDB_RPC_SERVER_HOST'\n</code></pre> <p>The host of the CodeLLDB rpc server.</p>"},{"location":"reference/py/codelldb/#codelldb.VSCODE_LLDB_RPC_SERVER_PORT_VARNAME","title":"VSCODE_LLDB_RPC_SERVER_PORT_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_LLDB_RPC_SERVER_PORT_VARNAME = 'VSCODE_LLDB_RPC_SERVER_PORT'\n</code></pre> <p>The port of the CodeLLDB rpc server.</p>"},{"location":"reference/py/codelldb/#codelldb.VSCODE_LLDB_RPC_SERVER_TOKEN_VARNAME","title":"VSCODE_LLDB_RPC_SERVER_TOKEN_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_LLDB_RPC_SERVER_TOKEN_VARNAME = 'VSCODE_LLDB_RPC_SERVER_TOKEN'\n</code></pre> <p>The secret token of the CodeLLDB rpc server.</p>"},{"location":"reference/py/codelldb/#codelldb.DEFAULT_HOST","title":"DEFAULT_HOST  <code>module-attribute</code>","text":"<pre><code>DEFAULT_HOST = '127.0.0.1'\n</code></pre>"},{"location":"reference/py/codelldb/#codelldb.DebugError","title":"DebugError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"reference/py/codelldb/#codelldb.debug","title":"debug","text":"<pre><code>debug() -&gt; None\n</code></pre> <p>Launch CodeLLDB to debug rust code.</p> <p>If the value indicated by VSCODE_RUST_DEBUG_VARNAME is not <code>1</code>, this is a no-op.</p> <p>Raises:</p> Type Description <code>DebugError</code> <p>If the provided environment variables cannot be correctly parsed.</p> Note <p>If failed to connect to the lldb rpc server, a warning message will be logged instead of raising an exception.</p> Source code in <code>python/codelldb/src/codelldb/__init__.py</code> <pre><code>def debug() -&gt; None:\n    \"\"\"Launch CodeLLDB to debug rust code.\n\n    If the value indicated by [VSCODE_RUST_DEBUG_VARNAME][codelldb.VSCODE_RUST_DEBUG_VARNAME] is not `1`, this is a no-op.\n\n    Raises:\n        DebugError: If the provided environment variables cannot be correctly parsed.\n\n    Note:\n        If failed to connect to the lldb rpc server, a warning message will be logged instead of raising an exception.\n    \"\"\"\n    vscode_rust_debug = getenv(VSCODE_RUST_DEBUG_VARNAME)\n    if vscode_rust_debug != \"1\":\n        return\n\n    _logger.info(f\"'{VSCODE_RUST_DEBUG_VARNAME}' is set, enabling rust debug mode\")\n\n    lldb_rpc_server_cfg = _get_lldb_rpc_server_cfg()\n\n    host = lldb_rpc_server_cfg[\"host\"]\n    port = lldb_rpc_server_cfg[\"port\"]\n    token = lldb_rpc_server_cfg[\"token\"]\n\n    token_data = f\"token: {token}\" if token else \"\"\n    # See: &lt;https://github.com/vadimcn/codelldb/blob/v1.10.0/MANUAL.md#rpc-server&gt;\n    # Line-oriented YAML Syntax: &lt;https://github.com/vadimcn/codelldb/blob/v1.10.0/MANUAL.md#debugging-externally-launched-code&gt;\n    # Arg: &lt;https://github.com/vadimcn/codelldb/blob/v1.10.0/MANUAL.md#attaching-to-a-running-process&gt;\n    rpc_data = dedent(f\"\"\"\\\n        name: \"rust.debug\"\n        type: \"lldb\"\n        request: \"attach\"\n        pid: {getpid()}\n        sourceLanguages:\n            - rust\n            - c\n            - cpp\n        {token_data}\n    \"\"\")\n\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((host, port))\n\n        s.sendall(rpc_data.encode(\"utf-8\"))\n\n        s.shutdown(socket.SHUT_WR)\n\n        response = s.recv(1024)\n\n        if not response:\n            _logger.warning(\n                \"Failed to get response from lldb rpc server, \"\n                \"maybe the rpc `token` is not correct.\"\n            )\n            return\n\n        try:\n            response = json.loads(response)\n            assert isinstance(response, dict)\n        except Exception as e:\n            _logger.warning(\n                f\"Failed to parse response from lldb rpc server: {response}\", exc_info=e\n            )\n            return\n\n        if response.get(\"success\") is not True:  # pyright: ignore[reportUnknownMemberType]\n            _logger.warning(\n                f\"Seems like lldb rpc server failed to attach to the process: {response}\"\n            )\n            return\n</code></pre>"},{"location":"reference/py/pyo3_utils/","title":"pyo3_utils","text":""},{"location":"reference/py/pyo3_utils/#pyo3_utils","title":"pyo3_utils","text":"<p>Python integration for the <code>pyo3-utils</code> crate.</p> <p>Classes:</p> Name Description <code>PyMatchRefMixin</code> <p>Rust <code>match &amp;self</code> for Python.</p> <code>PyMatchMutMixin</code> <p>Rust <code>match &amp;mut self</code> for Python.</p> <code>PyMatchIntoMixin</code> <p>Rust <code>match self</code> for Python.</p>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['PyMatchIntoMixin', 'PyMatchMutMixin', 'PyMatchRefMixin']\n</code></pre>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchRefMixin","title":"PyMatchRefMixin","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Rust <code>match &amp;self</code> for Python.</p> <p>This class is only used to provide type annotations, the actual implementation of the methods is handled by the pyo3 extension module.</p> Note <p>This class can only be used when <code>TYPE_CHECKING</code>.</p> <p>Methods:</p> Name Description <code>match_ref</code> <p>Equivalent to <code>match &amp;self</code> in Rust.</p>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchRefMixin.match_ref","title":"match_ref","text":"<pre><code>match_ref() -&gt; _T\n</code></pre> <p>Equivalent to <code>match &amp;self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_ref(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match &amp;self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchMutMixin","title":"PyMatchMutMixin","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Rust <code>match &amp;mut self</code> for Python.</p> <p>This class is only used to provide type annotations, the actual implementation of the methods is handled by the pyo3 extension module.</p> Note <p>This class can only be used when <code>TYPE_CHECKING</code>.</p> <p>Methods:</p> Name Description <code>match_mut</code> <p>Equivalent to <code>match &amp;mut self</code> in Rust.</p>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchMutMixin.match_mut","title":"match_mut","text":"<pre><code>match_mut() -&gt; _T\n</code></pre> <p>Equivalent to <code>match &amp;mut self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_mut(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match &amp;mut self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchIntoMixin","title":"PyMatchIntoMixin","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Rust <code>match self</code> for Python.</p> <p>This class is only used to provide type annotations, the actual implementation of the methods is handled by the pyo3 extension module.</p> Note <p>This class can only be used when <code>TYPE_CHECKING</code>.</p> <p>Methods:</p> Name Description <code>match_into</code> <p>Equivalent to <code>match self</code> in Rust.</p>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchIntoMixin.match_into","title":"match_into","text":"<pre><code>match_into() -&gt; _T\n</code></pre> <p>Equivalent to <code>match self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_into(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/","title":"pytauri","text":""},{"location":"reference/py/pytauri/#pytauri","title":"pytauri","text":"<p>tauri::self</p> <p>Modules:</p> Name Description <code>ffi</code> <p>Original FFI interface module.</p> <code>image</code> <p>tauri::image</p> <code>ipc</code> <p>tauri::ipc</p> <code>menu</code> <p>tauri::menu</p> <code>path</code> <p>tauri::path</p> <code>tray</code> <p>tauri::tray</p> <code>webview</code> <p>tauri::webview</p> <code>window</code> <p>tauri::window</p> <p>Classes:</p> Name Description <code>App</code> <p>Tauri::app</p> <code>AppHandle</code> <p>tauri::AppHandle</p> <code>Assets</code> <p>tauri::Assets</p> <code>Builder</code> <p>tauri::Builder</p> <code>BuilderArgs</code> <p>tauri::Builder</p> <code>CloseRequestApi</code> <p>tauri::CloseRequestApi</p> <code>Context</code> <p>tauri::Context</p> <code>DragDropEvent</code> <p>tauri::DragDropEvent</p> <code>Event</code> <p>tauri::Event</p> <code>EventTarget</code> <p>tauri::EventTarget</p> <code>ExitRequestApi</code> <p>tauri::ExitRequestApi</p> <code>Listener</code> <p>tauri::Listener</p> <code>Manager</code> <p>tauri::Manager</p> <code>Position</code> <p>tauri::Position</p> <code>Rect</code> <p>tauri::Rect</p> <code>RunEvent</code> <p>tauri::RunEvent</p> <code>Size</code> <p>tauri::Size</p> <code>Theme</code> <p>tauri::Theme</p> <code>WebviewEvent</code> <p>tauri::WebviewEvent</p> <code>WindowEvent</code> <p>tauri::WindowEvent</p> <code>Commands</code> <p>This class provides features similar to tauri::generate_handler.</p> <code>Emitter</code> <p>tauri::Emitter</p> <p>Functions:</p> Name Description <code>builder_factory</code> <p>A factory function for creating a <code>Builder</code> instance.</p> <code>context_factory</code> <p>A factory function for creating a <code>Context</code> instance.</p> <p>Attributes:</p> Name Type Description <code>EXT_MOD</code> <code>ModuleType</code> <p>The extension module of <code>pytauri</code> app.</p> <code>DragDropEventType</code> <p>See DragDropEvent for details.</p> <code>EventId</code> <p>tauri::EventId</p> <code>EventTargetType</code> <p>See EventTarget for details.</p> <code>ImplEmitter</code> <code>ImplListener</code> <code>ImplManager</code> <code>PositionType</code> <p>See Position for details.</p> <code>RunEventType</code> <p>See RunEvent for details.</p> <code>SizeType</code> <p>See Size for details.</p> <code>Url</code> <p>tauri::Url</p> <code>WebviewEventType</code> <p>See WebviewEvent for details.</p> <code>WindowEventType</code> <p>See WindowEvent for details.</p>"},{"location":"reference/py/pytauri/#pytauri.EXT_MOD","title":"EXT_MOD  <code>module-attribute</code>","text":"<pre><code>EXT_MOD: ModuleType\n</code></pre> <p>The extension module of <code>pytauri</code> app.</p> <p>It will be loaded from <code>entry_points(group=\"pytauri\", name=\"ext_mod\")</code>.</p> <p>Usually you don't need to use it, unless you want to write plugins for <code>pytauri</code>.</p>"},{"location":"reference/py/pytauri/#pytauri.DragDropEventType","title":"DragDropEventType  <code>module-attribute</code>","text":"<pre><code>DragDropEventType = TypeAliasType('DragDropEventType', Union[Enter, Over, Drop, Leave, _NonExhaustive])\n</code></pre> <p>See DragDropEvent for details.</p>"},{"location":"reference/py/pytauri/#pytauri.EventId","title":"EventId  <code>module-attribute</code>","text":"<pre><code>EventId = NewType('EventId', int)\n</code></pre> <p>tauri::EventId</p>"},{"location":"reference/py/pytauri/#pytauri.EventTargetType","title":"EventTargetType  <code>module-attribute</code>","text":"<pre><code>EventTargetType = TypeAliasType('EventTargetType', Union[Any, AnyLabel, App, Window, Webview, WebviewWindow, _NonExhaustive])\n</code></pre> <p>See EventTarget for details.</p>"},{"location":"reference/py/pytauri/#pytauri.ImplEmitter","title":"ImplEmitter  <code>module-attribute</code>","text":"<pre><code>ImplEmitter = ImplManager\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.ImplListener","title":"ImplListener  <code>module-attribute</code>","text":"<pre><code>ImplListener = ImplManager\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.ImplManager","title":"ImplManager  <code>module-attribute</code>","text":"<pre><code>ImplManager = TypeAliasType('ImplManager', Union[App, AppHandle, 'WebviewWindow'])\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.PositionType","title":"PositionType  <code>module-attribute</code>","text":"<pre><code>PositionType = TypeAliasType('PositionType', Union[Physical, Logical])\n</code></pre> <p>See Position for details.</p>"},{"location":"reference/py/pytauri/#pytauri.RunEventType","title":"RunEventType  <code>module-attribute</code>","text":"<pre><code>RunEventType = TypeAliasType('RunEventType', Union[Exit, ExitRequested, WindowEvent, WebviewEvent, Ready, Resumed, MainEventsCleared, MenuEvent, TrayIconEvent, _NonExhaustive])\n</code></pre> <p>See RunEvent for details.</p>"},{"location":"reference/py/pytauri/#pytauri.SizeType","title":"SizeType  <code>module-attribute</code>","text":"<pre><code>SizeType = TypeAliasType('SizeType', Union[Physical, Logical])\n</code></pre> <p>See Size for details.</p>"},{"location":"reference/py/pytauri/#pytauri.Url","title":"Url  <code>module-attribute</code>","text":"<pre><code>Url = TypeAliasType('Url', str)\n</code></pre> <p>tauri::Url</p>"},{"location":"reference/py/pytauri/#pytauri.WebviewEventType","title":"WebviewEventType  <code>module-attribute</code>","text":"<pre><code>WebviewEventType = TypeAliasType('WebviewEventType', Union[DragDrop, _NonExhaustive])\n</code></pre> <p>See WebviewEvent for details.</p>"},{"location":"reference/py/pytauri/#pytauri.WindowEventType","title":"WindowEventType  <code>module-attribute</code>","text":"<pre><code>WindowEventType = TypeAliasType('WindowEventType', Union[Resized, Moved, CloseRequested, Destroyed, Focused, ScaleFactorChanged, DragDrop, ThemeChanged, _NonExhaustive])\n</code></pre> <p>See WindowEvent for details.</p>"},{"location":"reference/py/pytauri/#pytauri.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['EXT_MOD', 'App', 'AppHandle', 'Assets', 'Builder', 'BuilderArgs', 'CloseRequestApi', 'Commands', 'Context', 'DragDropEvent', 'DragDropEventType', 'Emitter', 'Event', 'EventId', 'EventTarget', 'EventTargetType', 'ExitRequestApi', 'ImplEmitter', 'ImplListener', 'ImplManager', 'Listener', 'Manager', 'Position', 'PositionType', 'Rect', 'RunEvent', 'RunEventType', 'Size', 'SizeType', 'Theme', 'Url', 'WebviewEvent', 'WebviewEventType', 'WindowEvent', 'WindowEventType', 'builder_factory', 'context_factory']\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.App","title":"App","text":"<p>Tauri::app</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>run</code> <p>Consume and run this app, will block until the app is exited.</p> <code>run_return</code> <p>Consume and run this application, returning its intended exit code.</p> <code>run_iteration</code> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <code>cleanup_before_exit</code> <p>Runs necessary cleanup tasks before exiting the process.</p> <code>handle</code> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p>"},{"location":"reference/py/pytauri/#pytauri.App.run","title":"run","text":"<pre><code>run(callback: Optional[_AppRunCallbackType] = None) -&gt; NoReturn\n</code></pre> <p>Consume and run this app, will block until the app is exited.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each event. It will be called on the same thread that the app was created on, so you should not block in this function.</p> <code>None</code> <p>Note</p> <p>This function will call <code>std::process::exit</code> at the end to terminate the entire process, which means the Python interpreter cannot be properly finalized. If this is a problem for you, please use pytauri.App.run_return.</p> <p>Warning</p> <p>If <code>callback</code> is specified, it must not raise an exception, otherwise it is logical undefined behavior, and in most cases, the program will panic.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; NoReturn:\n    \"\"\"Consume and run this app, will block until the app is exited.\n\n    Args:\n        callback: a callback function that will be called on each event.\n            It will be called on the same thread that the app was created on,\n            so you should not block in this function.\n\n    !!! note\n        This function will call `std::process::exit` at the end to terminate the entire process,\n        which means the Python interpreter cannot be properly finalized.\n        If this is a problem for you, please use [pytauri.App.run_return][].\n\n    !!! warning\n        If `callback` is specified, it must not raise an exception,\n        otherwise it is logical undefined behavior, and in most cases, the program will panic.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.App.run(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/#pytauri.App.run_return","title":"run_return","text":"<pre><code>run_return(callback: Optional[_AppRunCallbackType] = None) -&gt; int\n</code></pre> <p>Consume and run this application, returning its intended exit code.</p> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_return(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; int:\n    \"\"\"Consume and run this application, returning its intended exit code.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.App.run_iteration","title":"run_iteration  <code>deprecated</code>","text":"<pre><code>run_iteration(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> Deprecated <p>When called in a loop (as suggested by the name), this function will busy-loop.             To re-gain control of control flow after the app has exited, use <code>App::run_return</code> instead.             See https://docs.rs/tauri/latest/tauri/struct.App.html#method.run_iteration for more details.</p> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each iteration.</p> <code>None</code> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> <p>Tip</p> <p>Approximately 2ms per calling in debug mode.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@deprecated(\n    \"\"\"When called in a loop (as suggested by the name), this function will busy-loop.\n    To re-gain control of control flow after the app has exited, use `App::run_return` instead.\n    See &lt;https://docs.rs/tauri/latest/tauri/struct.App.html#method.run_iteration&gt; for more details.\"\"\",\n    category=None,\n)\ndef run_iteration(\n    self, callback: Optional[_AppRunCallbackType] = None, /\n) -&gt; None:\n    \"\"\"Run this app iteratively without consuming it, calling `callback` on each iteration.\n\n    Args:\n        callback: a callback function that will be called on each iteration.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n\n    !!! tip\n        Approximately 2ms per calling in debug mode.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.App.run_iteration(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/#pytauri.App.cleanup_before_exit","title":"cleanup_before_exit","text":"<pre><code>cleanup_before_exit() -&gt; None\n</code></pre> <p>Runs necessary cleanup tasks before exiting the process.</p> <p>You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def cleanup_before_exit(self, /) -&gt; None:\n    \"\"\"Runs necessary cleanup tasks before exiting the process.\n\n    **You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.**\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.App.handle","title":"handle","text":"<pre><code>handle() -&gt; AppHandle\n</code></pre> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def handle(self, /) -&gt; \"AppHandle\":\n    \"\"\"Get a handle to this app, which can be used to interact with the app from another thread.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle","title":"AppHandle","text":"<p>tauri::AppHandle</p> <p>Methods:</p> Name Description <code>run_on_main_thread</code> <p>Runs the given closure on the main thread.</p> <code>exit</code> <code>restart</code> <code>on_menu_event</code> <p>Registers a global menu event listener.</p> <code>on_tray_icon_event</code> <p>Registers a global tray icon menu event listener.</p> <code>tray_by_id</code> <code>remove_tray_by_id</code> <code>set_theme</code> <code>default_window_icon</code> <p>Returns the default window icon.</p> <code>menu</code> <code>set_menu</code> <code>remove_menu</code> <code>hide_menu</code> <code>show_menu</code> <code>invoke_key</code>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.run_on_main_thread","title":"run_on_main_thread","text":"<pre><code>run_on_main_thread(handler: Callable[[], object]) -&gt; None\n</code></pre> <p>Runs the given closure on the main thread.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_on_main_thread(self, handler: Callable[[], object], /) -&gt; None:\n    \"\"\"Runs the given closure on the main thread.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.exit","title":"exit","text":"<pre><code>exit(exit_code: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def exit(self, exit_code: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.restart","title":"restart","text":"<pre><code>restart() -&gt; Never\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def restart(self, /) -&gt; Never: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[Self, MenuEvent], None]) -&gt; None\n</code></pre> <p>Registers a global menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[\"Self\", \"MenuEvent\"], None], /\n) -&gt; None:\n    \"\"\"Registers a global menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.on_tray_icon_event","title":"on_tray_icon_event","text":"<pre><code>on_tray_icon_event(handler: Callable[[Self, TrayIconEventType], None]) -&gt; None\n</code></pre> <p>Registers a global tray icon menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_tray_icon_event(\n    self, handler: Callable[[Self, TrayIconEventType], None], /\n) -&gt; None:\n    \"\"\"Registers a global tray icon menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.tray_by_id","title":"tray_by_id","text":"<pre><code>tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.remove_tray_by_id","title":"remove_tray_by_id","text":"<pre><code>remove_tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.set_theme","title":"set_theme","text":"<pre><code>set_theme(theme: Optional[Theme]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_theme(self, theme: Optional[\"Theme\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.default_window_icon","title":"default_window_icon","text":"<pre><code>default_window_icon() -&gt; Optional[Image]\n</code></pre> <p>Returns the default window icon.</p> <p>Warning</p> <p>Each time you call this function, a new image instance will be created. So you should cache the result if you need to use it multiple times.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def default_window_icon(self, /) -&gt; Optional[Image]:\n    \"\"\"Returns the default window icon.\n\n    !!! warning\n        Each time you call this function, a new image instance will be created.\n        So you should cache the result if you need to use it multiple times.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.menu","title":"menu","text":"<pre><code>menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Menu) -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_menu(self, menu: Menu, /) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.remove_menu","title":"remove_menu","text":"<pre><code>remove_menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.hide_menu","title":"hide_menu","text":"<pre><code>hide_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def hide_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.show_menu","title":"show_menu","text":"<pre><code>show_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def show_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.invoke_key","title":"invoke_key","text":"<pre><code>invoke_key() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def invoke_key(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Assets","title":"Assets","text":"<p>               Bases: <code>ABC</code></p> <p>tauri::Assets</p> <p>This is an abstract class that you can subclass to implement a custom asset loader.</p> <p>See <code>tauri::Assets</code> rust docs for more details.</p> <p>Warning</p> <p>The implement has the same restrictions as App.run.</p> <p>Methods:</p> Name Description <code>get</code> <code>iter</code> <code>setup</code>"},{"location":"reference/py/pytauri/#pytauri.Assets.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key: _AssetKey) -&gt; Optional[bytes]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef get(self, key: _AssetKey, /) -&gt; Optional[bytes]: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Assets.iter","title":"iter  <code>abstractmethod</code>","text":"<pre><code>iter() -&gt; Iterator[tuple[str, bytes]]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef iter(self, /) -&gt; Iterator[tuple[str, bytes]]: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Assets.setup","title":"setup","text":"<pre><code>setup(_app: AppHandle) -&gt; object\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def setup(self, _app: AppHandle, /) -&gt; object:\n    return None\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Builder","title":"Builder","text":"<p>tauri::Builder</p> <p>use builder_factory to instantiate this class.</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>build</code> <p>tauri::Builder::build</p>"},{"location":"reference/py/pytauri/#pytauri.Builder.build","title":"build","text":"<pre><code>build(context: Context, **kwargs: Unpack[BuilderArgs]) -&gt; App\n</code></pre> <p>tauri::Builder::build</p> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>Context</code> <p>use context_factory to get it.</p> required <code>Unpack[BuilderArgs]</code> <p>see BuilderArgs for details.</p> <code>{}</code> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def build(self, context: \"Context\", **kwargs: Unpack[\"BuilderArgs\"]) -&gt; App:\n    \"\"\"[tauri::Builder::build](https://docs.rs/tauri/latest/tauri/struct.Builder.html#method.build)\n\n    Consume this builder and build an app with the given `BuilderArgs`.\n\n    Args:\n        context: use [context_factory][pytauri.context_factory] to get it.\n        **kwargs: see [BuilderArgs][pytauri.BuilderArgs] for details.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Builder.build(context)","title":"<code>context</code>","text":""},{"location":"reference/py/pytauri/#pytauri.Builder.build(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/py/pytauri/#pytauri.BuilderArgs","title":"BuilderArgs","text":"<p>               Bases: <code>TypedDict</code></p> <p>tauri::Builder</p> <p>Attributes:</p> Name Type Description <code>invoke_handler</code> <code>Required[Optional[_InvokeHandlerProto]]</code> <p>Use Commands to get it.</p> <code>setup</code> <code>Callable[[AppHandle], object]</code> <p>See rust <code>tauri::Builder::setup</code></p>"},{"location":"reference/py/pytauri/#pytauri.BuilderArgs.invoke_handler","title":"invoke_handler  <code>instance-attribute</code>","text":"<pre><code>invoke_handler: Required[Optional[_InvokeHandlerProto]]\n</code></pre> <p>Use Commands to get it.</p> <p>Warning</p> <p>The implement of <code>invoke_handler</code> must never raise an exception, otherwise it is considered logical undefined behavior. Additionally, <code>invoke_handler</code> must not block.</p> <p>Warning</p> <p>If you do not specify <code>invoke_handler</code>, <code>pytauri</code> will not register the <code>tauri-plugin-pytauri</code> plugin, which means you cannot use <code>pyInvoke</code> in the frontend to call <code>Commands</code> (you will receive an error like \"plugin pytauri not found\"). If this is indeed the behavior you expect, explicitly pass None.</p>"},{"location":"reference/py/pytauri/#pytauri.BuilderArgs.setup","title":"setup  <code>instance-attribute</code>","text":"<pre><code>setup: Callable[[AppHandle], object]\n</code></pre> <p>See rust <code>tauri::Builder::setup</code></p>"},{"location":"reference/py/pytauri/#pytauri.CloseRequestApi","title":"CloseRequestApi","text":"<p>tauri::CloseRequestApi</p> <p>Methods:</p> Name Description <code>prevent_close</code>"},{"location":"reference/py/pytauri/#pytauri.CloseRequestApi.prevent_close","title":"prevent_close","text":"<pre><code>prevent_close() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def prevent_close(self, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Context","title":"Context","text":"<p>tauri::Context</p> <p>Methods:</p> Name Description <code>set_assets</code> <p>Use custom assets instead of the assets bundled by Tauri.</p>"},{"location":"reference/py/pytauri/#pytauri.Context.set_assets","title":"set_assets","text":"<pre><code>set_assets(assets: Assets) -&gt; None\n</code></pre> <p>Use custom assets instead of the assets bundled by Tauri.</p> <p>To make this work:</p> <ul> <li>You need to enable the <code>tauri/custom-protocol</code> feature.<ul> <li>Or build using <code>tauri build</code>.</li> </ul> </li> <li>Set <code>frontendDist</code> in <code>tauri.conf.json</code> to an empty directory (do not set it to a URL).<ul> <li> <p>Or generate <code>Context</code> via:</p> <pre><code>use tauri::{generate_context, test::noop_assets};\n\nlet context = generate_context!(assets=noop_assets());\n</code></pre> <p>then we will use this method to set the assets.</p> <p>see: https://github.com/tauri-apps/tauri/pull/9141</p> </li> </ul> </li> </ul> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_assets(self, assets: \"Assets\", /) -&gt; None:\n    \"\"\"Use custom assets instead of the assets bundled by Tauri.\n\n    To make this work:\n\n    - You need to enable the `tauri/custom-protocol` feature.\n        - Or build using `tauri build`.\n    - Set `frontendDist` in `tauri.conf.json` to an empty directory (do not set it to a URL).\n        - Or generate `Context` via:\n\n            ```rust\n            use tauri::{generate_context, test::noop_assets};\n\n            let context = generate_context!(assets=noop_assets());\n            ```\n\n            then we will use this method to set the assets.\n\n            see: &lt;https://github.com/tauri-apps/tauri/pull/9141&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.DragDropEvent","title":"DragDropEvent","text":"<p>tauri::DragDropEvent</p> <p>Classes:</p> Name Description <code>Enter</code> <p>tauri::DragDropEvent::Enter</p> <code>Over</code> <p>tauri::DragDropEvent::Over</p> <code>Drop</code> <p>tauri::DragDropEvent::Drop</p> <code>Leave</code> <p>tauri::DragDropEvent::Leave</p>"},{"location":"reference/py/pytauri/#pytauri.DragDropEvent.Enter","title":"Enter","text":"<p>tauri::DragDropEvent::Enter</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>_VecPathBuf</code> <code>position</code> <code>_PhysicalPositionF64</code>"},{"location":"reference/py/pytauri/#pytauri.DragDropEvent.Enter.paths","title":"paths  <code>instance-attribute</code>","text":"<pre><code>paths: _VecPathBuf\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.DragDropEvent.Enter.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.DragDropEvent.Over","title":"Over","text":"<p>tauri::DragDropEvent::Over</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>_PhysicalPositionF64</code>"},{"location":"reference/py/pytauri/#pytauri.DragDropEvent.Over.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.DragDropEvent.Drop","title":"Drop","text":"<p>tauri::DragDropEvent::Drop</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>_VecPathBuf</code> <code>position</code> <code>_PhysicalPositionF64</code>"},{"location":"reference/py/pytauri/#pytauri.DragDropEvent.Drop.paths","title":"paths  <code>instance-attribute</code>","text":"<pre><code>paths: _VecPathBuf\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.DragDropEvent.Drop.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.DragDropEvent.Leave","title":"Leave","text":"<p>tauri::DragDropEvent::Leave</p>"},{"location":"reference/py/pytauri/#pytauri.Event","title":"Event","text":"<p>tauri::Event</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>EventId</code> <p>The <code>EventId</code> of the handler that was triggered.</p> <code>payload</code> <code>str</code> <p>The event payload.</p>"},{"location":"reference/py/pytauri/#pytauri.Event.id","title":"id  <code>property</code>","text":"<pre><code>id: EventId\n</code></pre> <p>The <code>EventId</code> of the handler that was triggered.</p>"},{"location":"reference/py/pytauri/#pytauri.Event.payload","title":"payload  <code>property</code>","text":"<pre><code>payload: str\n</code></pre> <p>The event payload.</p>"},{"location":"reference/py/pytauri/#pytauri.EventTarget","title":"EventTarget","text":"<p>tauri::EventTarget</p> <p>Classes:</p> Name Description <code>Any</code> <p>Any and all event targets.</p> <code>AnyLabel</code> <p>Any <code>Window</code>, <code>Webview</code> or <code>WebviewWindow</code> that have this label.</p> <code>App</code> <p>App and AppHandle targets.</p> <code>Window</code> <p><code>Window</code> target.</p> <code>Webview</code> <p>Webview target.</p> <code>WebviewWindow</code> <p>WebviewWindow target.</p>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.Any","title":"Any","text":"<p>Any and all event targets.</p> <p>Methods:</p> Name Description <code>__new__</code>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.Any.__new__","title":"__new__","text":"<pre><code>__new__() -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.AnyLabel","title":"AnyLabel","text":"<p>Any <code>Window</code>, <code>Webview</code> or <code>WebviewWindow</code> that have this label.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Target label.</p>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.AnyLabel.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>Target label.</p>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.AnyLabel.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.App","title":"App","text":"<p>App and AppHandle targets.</p> <p>Methods:</p> Name Description <code>__new__</code>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.App.__new__","title":"__new__","text":"<pre><code>__new__() -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.Window","title":"Window","text":"<p><code>Window</code> target.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>window label.</p>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.Window.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>window label.</p>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.Window.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.Webview","title":"Webview","text":"<p>Webview target.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>webview label.</p>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.Webview.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>webview label.</p>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.Webview.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.WebviewWindow","title":"WebviewWindow","text":"<p>WebviewWindow target.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>webview window label.</p>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.WebviewWindow.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>webview window label.</p>"},{"location":"reference/py/pytauri/#pytauri.EventTarget.WebviewWindow.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.ExitRequestApi","title":"ExitRequestApi","text":"<p>tauri::ExitRequestApi</p> <p>Methods:</p> Name Description <code>prevent_exit</code>"},{"location":"reference/py/pytauri/#pytauri.ExitRequestApi.prevent_exit","title":"prevent_exit","text":"<pre><code>prevent_exit() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def prevent_exit(self, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Listener","title":"Listener","text":"<p>tauri::Listener</p> <p>See also: https://tauri.app/develop/calling-rust/#event-system</p>"},{"location":"reference/py/pytauri/#pytauri.Listener--examples","title":"Examples","text":"<pre><code>from pydantic import BaseModel\nfrom pytauri import AppHandle, Event, Listener\n\n\nclass Payload(BaseModel):  # or `RootModel`\n    url: str\n    num: int\n\n\ndef listen(app_handle: AppHandle) -&gt; None:\n    def handler(event: Event):\n        assert event.id == event_id\n\n        serialized_event = Payload.model_validate_json(event.payload)\n        print(serialized_event.url, serialized_event.num)\n\n    event_id = Listener.listen(app_handle, \"event_name\", handler)\n</code></pre> <p>Methods:</p> Name Description <code>listen</code> <p>Listen to an emitted event on this manager.</p> <code>once</code> <p>Listen to an event on this manager only once.</p> <code>unlisten</code> <p>Remove an event listener.</p> <code>listen_any</code> <p>Listen to an emitted event to any target.</p> <code>once_any</code> <p>Listens once to an emitted event to any target .</p>"},{"location":"reference/py/pytauri/#pytauri.Listener.listen","title":"listen  <code>staticmethod</code>","text":"<pre><code>listen(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event on this manager.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event on this manager.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Listener.once","title":"once  <code>staticmethod</code>","text":"<pre><code>once(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an event on this manager only once.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an event on this manager only once.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Listener.unlisten","title":"unlisten  <code>staticmethod</code>","text":"<pre><code>unlisten(slf: ImplListener, id: EventId) -&gt; None\n</code></pre> <p>Remove an event listener.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef unlisten(\n    slf: \"ImplListener\",\n    id: \"EventId\",  # noqa: A002\n    /,\n) -&gt; None:\n    \"\"\"Remove an event listener.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Listener.listen_any","title":"listen_any  <code>staticmethod</code>","text":"<pre><code>listen_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event to any target.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event to any target.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Listener.once_any","title":"once_any  <code>staticmethod</code>","text":"<pre><code>once_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listens once to an emitted event to any target .</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listens once to an emitted event to any target .\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Manager","title":"Manager","text":"<p>tauri::Manager</p> <p>Methods:</p> Name Description <code>app_handle</code> <p>The application handle associated with this manager.</p> <code>get_webview_window</code> <p>Fetch a single webview window from the manager.</p> <code>webview_windows</code> <p>Fetch all managed webview windows.</p> <code>path</code> <p>The path resolver is a helper class for general and application-specific path APIs.</p>"},{"location":"reference/py/pytauri/#pytauri.Manager.app_handle","title":"app_handle  <code>staticmethod</code>","text":"<pre><code>app_handle(slf: ImplManager) -&gt; AppHandle\n</code></pre> <p>The application handle associated with this manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef app_handle(slf: \"ImplManager\", /) -&gt; AppHandle:\n    \"\"\"The application handle associated with this manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Manager.get_webview_window","title":"get_webview_window  <code>staticmethod</code>","text":"<pre><code>get_webview_window(slf: ImplManager, label: str) -&gt; Optional[WebviewWindow]\n</code></pre> <p>Fetch a single webview window from the manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef get_webview_window(\n    slf: \"ImplManager\", label: str, /\n) -&gt; Optional[WebviewWindow]:\n    \"\"\"Fetch a single webview window from the manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Manager.webview_windows","title":"webview_windows  <code>staticmethod</code>","text":"<pre><code>webview_windows(slf: ImplManager) -&gt; dict[str, WebviewWindow]\n</code></pre> <p>Fetch all managed webview windows.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef webview_windows(slf: \"ImplManager\", /) -&gt; dict[str, WebviewWindow]:\n    \"\"\"Fetch all managed webview windows.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Manager.path","title":"path  <code>staticmethod</code>","text":"<pre><code>path(slf: ImplManager) -&gt; PathResolver\n</code></pre> <p>The path resolver is a helper class for general and application-specific path APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef path(slf: \"ImplManager\", /) -&gt; PathResolver:\n    \"\"\"The path resolver is a helper class for general and application-specific path APIs.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Position","title":"Position","text":"<p>tauri::Position</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Position::Physical</p> <code>Logical</code> <p>tauri::Position::Logical</p>"},{"location":"reference/py/pytauri/#pytauri.Position.Physical","title":"Physical","text":"<p>               Bases: <code>tuple[_PhysicalPositionI32]</code></p> <p>tauri::Position::Physical</p> <p>Warning</p> <p>This is actually a <code>Class</code> disguised as an <code>NamedTuple</code>. See also: https://pyo3.rs/v0.23.4/class.html#pyclass-enums.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.Position.Physical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Position.Physical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalPositionI32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalPositionI32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Position.Logical","title":"Logical","text":"<p>               Bases: <code>tuple[_LogicalPositionF64]</code></p> <p>tauri::Position::Logical</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.Position.Logical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Position.Logical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _LogicalPositionF64) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _LogicalPositionF64, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Rect","title":"Rect","text":"<p>tauri::Rect</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>position</code> <code>PositionType</code> <code>size</code> <code>SizeType</code>"},{"location":"reference/py/pytauri/#pytauri.Rect.position","title":"position  <code>property</code>","text":"<pre><code>position: PositionType\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Rect.size","title":"size  <code>property</code>","text":"<pre><code>size: SizeType\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Rect.__new__","title":"__new__","text":"<pre><code>__new__(*, position: PositionType, size: SizeType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    position: \"PositionType\",\n    size: \"SizeType\",\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent","title":"RunEvent","text":"<p>tauri::RunEvent</p> <p>Classes:</p> Name Description <code>Exit</code> <p>tauri::RunEvent::Exit</p> <code>ExitRequested</code> <p>tauri::RunEvent::ExitRequested</p> <code>WindowEvent</code> <p>tauri::RunEvent::WindowEvent</p> <code>WebviewEvent</code> <p>tauri::RunEvent::WebviewEvent</p> <code>Ready</code> <p>tauri::RunEvent::Ready</p> <code>Resumed</code> <p>tauri::RunEvent::Resumed</p> <code>MainEventsCleared</code> <p>tauri::RunEvent::MainEventsCleared</p> <code>MenuEvent</code> <p>tauri::RunEvent::MenuEvent</p> <code>TrayIconEvent</code> <p>tauri::RunEvent::TrayIconEvent</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.Exit","title":"Exit","text":"<p>tauri::RunEvent::Exit</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.ExitRequested","title":"ExitRequested","text":"<p>tauri::RunEvent::ExitRequested</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>Optional[int]</code> <code>api</code> <code>ExitRequestApi</code>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.ExitRequested.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Optional[int]\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.ExitRequested.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api: ExitRequestApi\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.WindowEvent","title":"WindowEvent","text":"<p>tauri::RunEvent::WindowEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <code>event</code> <code>WindowEventType</code>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.WindowEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.WindowEvent.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: WindowEventType\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::RunEvent::WebviewEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <code>event</code> <code>WebviewEventType</code>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.WebviewEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.WebviewEvent.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: WebviewEventType\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.Ready","title":"Ready","text":"<p>tauri::RunEvent::Ready</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.Resumed","title":"Resumed","text":"<p>tauri::RunEvent::Resumed</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.MainEventsCleared","title":"MainEventsCleared","text":"<p>tauri::RunEvent::MainEventsCleared</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.MenuEvent","title":"MenuEvent","text":"<p>               Bases: <code>tuple[MenuEvent]</code></p> <p>tauri::RunEvent::MenuEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.MenuEvent.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.MenuEvent.__new__","title":"__new__","text":"<pre><code>__new__(_0: MenuEvent) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: MenuEvent, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.TrayIconEvent","title":"TrayIconEvent","text":"<p>               Bases: <code>tuple[TrayIconEventType]</code></p> <p>tauri::RunEvent::TrayIconEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.TrayIconEvent.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.TrayIconEvent.__new__","title":"__new__","text":"<pre><code>__new__(_0: TrayIconEventType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: TrayIconEventType, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Size","title":"Size","text":"<p>tauri::Size</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Size::Physical</p> <code>Logical</code> <p>tauri::Size::Logical</p>"},{"location":"reference/py/pytauri/#pytauri.Size.Physical","title":"Physical","text":"<p>               Bases: <code>tuple[_PhysicalSizeU32]</code></p> <p>tauri::Size::Physical</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.Size.Physical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Size.Physical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalSizeU32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalSizeU32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Size.Logical","title":"Logical","text":"<p>               Bases: <code>tuple[_LogicalSizeF64]</code></p> <p>tauri::Size::Logical</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.Size.Logical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Size.Logical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _LogicalSizeF64) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _LogicalSizeF64, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Theme","title":"Theme","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::Theme</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Light</code> <code>Dark</code>"},{"location":"reference/py/pytauri/#pytauri.Theme.Light","title":"Light  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Light = auto()\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Theme.Dark","title":"Dark  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Dark = auto()\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::WebviewEvent</p> <p>Classes:</p> Name Description <code>DragDrop</code> <p>tauri::WebviewEvent::DragDrop</p>"},{"location":"reference/py/pytauri/#pytauri.WebviewEvent.DragDrop","title":"DragDrop","text":"<p>               Bases: <code>tuple['DragDropEventType']</code></p> <p>tauri::WebviewEvent::DragDrop</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.WebviewEvent.DragDrop.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WebviewEvent.DragDrop.__new__","title":"__new__","text":"<pre><code>__new__(_0: DragDropEventType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: \"DragDropEventType\", /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent","title":"WindowEvent","text":"<p>tauri::WindowEvent</p> <p>Classes:</p> Name Description <code>Resized</code> <p>tauri::WindowEvent::Resized</p> <code>Moved</code> <p>tauri::WindowEvent::Moved</p> <code>CloseRequested</code> <p>tauri::WindowEvent::CloseRequested</p> <code>Destroyed</code> <p>tauri::WindowEvent::Destroyed</p> <code>Focused</code> <p>tauri::WindowEvent::Focused</p> <code>ScaleFactorChanged</code> <p>tauri::WindowEvent::ScaleFactorChanged</p> <code>DragDrop</code> <p>tauri::WindowEvent::DragDrop</p> <code>ThemeChanged</code> <p>tauri::WindowEvent::ThemeChanged</p>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.Resized","title":"Resized","text":"<p>               Bases: <code>tuple[_PhysicalSizeU32]</code></p> <p>tauri::WindowEvent::Resized</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.Resized.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.Resized.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalSizeU32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalSizeU32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.Moved","title":"Moved","text":"<p>               Bases: <code>tuple[_PhysicalPositionI32]</code></p> <p>tauri::WindowEvent::Moved</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.Moved.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.Moved.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalPositionI32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalPositionI32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.CloseRequested","title":"CloseRequested","text":"<p>tauri::WindowEvent::CloseRequested</p> <p>Attributes:</p> Name Type Description <code>api</code> <code>CloseRequestApi</code>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.CloseRequested.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api: CloseRequestApi\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.Destroyed","title":"Destroyed","text":"<p>tauri::WindowEvent::Destroyed</p>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.Focused","title":"Focused","text":"<p>               Bases: <code>tuple[bool]</code></p> <p>tauri::WindowEvent::Focused</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.Focused.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.Focused.__new__","title":"__new__","text":"<pre><code>__new__(_0: bool) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: bool, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.ScaleFactorChanged","title":"ScaleFactorChanged","text":"<p>tauri::WindowEvent::ScaleFactorChanged</p> <p>Attributes:</p> Name Type Description <code>scale_factor</code> <code>float</code> <code>new_inner_size</code> <code>_PhysicalSizeU32</code>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.ScaleFactorChanged.scale_factor","title":"scale_factor  <code>instance-attribute</code>","text":"<pre><code>scale_factor: float\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.ScaleFactorChanged.new_inner_size","title":"new_inner_size  <code>instance-attribute</code>","text":"<pre><code>new_inner_size: _PhysicalSizeU32\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.DragDrop","title":"DragDrop","text":"<p>               Bases: <code>tuple['DragDropEventType']</code></p> <p>tauri::WindowEvent::DragDrop</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.DragDrop.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.DragDrop.__new__","title":"__new__","text":"<pre><code>__new__(_0: DragDropEventType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: \"DragDropEventType\", /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.ThemeChanged","title":"ThemeChanged","text":"<p>               Bases: <code>tuple['Theme']</code></p> <p>tauri::WindowEvent::ThemeChanged</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.ThemeChanged.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.WindowEvent.ThemeChanged.__new__","title":"__new__","text":"<pre><code>__new__(_0: Theme) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: \"Theme\", /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands","title":"Commands","text":"<pre><code>Commands(*, experimental_gen_ts: bool = False)\n</code></pre> <p>               Bases: <code>UserDict[str, _PyInvokHandleData]</code></p> <p>This class provides features similar to tauri::generate_handler.</p> <p>Typically, you would use Commands.command to register a command handler function. Then, use Commands.generate_handler to get an <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Methods:</p> Name Description <code>generate_handler</code> <p>This method is similar to tauri::generate_handler.</p> <code>wrap_pyfunc</code> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <code>parse_parameters</code> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <code>set_command</code> <p>Set a command handler.</p> <code>command</code> <p>A decorator to register a command handler.</p> <code>experimental_gen_ts</code> <p>Generate TypeScript types and API client from the registered commands.</p> <code>experimental_gen_ts_background</code> <p>Generate TypeScript types and API client from the registered commands in the background.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self, *, experimental_gen_ts: bool = False) -&gt; None:  # noqa: D107\n    super().__init__()\n\n    self._experimental_gen_ts = {} if experimental_gen_ts else None\n\n    data = self.data\n\n    async def _async_invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - the implementer of this function must not raise exceptions\n        # - and must ensure to fulfill `invoke/resolver`\n        resolver = None\n        try:\n            command = invoke.command\n            handler_data = data.get(command)\n            if handler_data is None:\n                invoke.reject(f\"no python handler `{command}` found\")\n                return\n\n            parameters = handler_data.parameters\n            handler = handler_data.handler\n\n            resolver = invoke.bind_to(parameters)\n            if resolver is None:\n                # `invoke` has already been rejected\n                return\n\n            try:\n                resp = await handler(**resolver.arguments)\n                # TODO, PERF: idk if this will block?\n            except InvokeException as e:\n                resolver.reject(e.value)\n            except Exception as e:\n                # # TODO: Should we return the traceback to the frontend?\n                # # It might leak information.\n                # from traceback import format_exc\n                # resolver.reject(format_exc())\n                _logger.exception(\n                    f\"invoke_handler {handler}: `{handler.__name__}` raised an exception\",\n                    exc_info=e,\n                )\n                resolver.reject(repr(e))\n            else:\n                resolver.resolve(resp)\n\n        except Exception as e:\n            msg = f\"{_async_invoke_handler} implementation raised an exception, please report this as a pytauri bug\"\n\n            _logger.critical(msg, exc_info=e)\n            if resolver is not None:\n                resolver.reject(msg)\n            else:\n                invoke.reject(msg)\n            raise\n\n    self._async_invoke_handler = _async_invoke_handler\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.generate_handler","title":"generate_handler","text":"<pre><code>generate_handler(portal: BlockingPortal) -&gt; _InvokeHandlerProto\n</code></pre> <p>This method is similar to tauri::generate_handler.</p> <p>You can use this method to get <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Examples:</p> <pre><code>from anyio.from_thread import start_blocking_portal\n\ncommands = Commands()\n\nwith start_blocking_portal(backend) as portal:\n    invoke_handler = commands.generate_handler(portal)\n    ...\n</code></pre> <p>Warning</p> <p>The <code>portal</code> must remain valid while the returned <code>invoke_handler</code> is being used.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def generate_handler(self, portal: BlockingPortal, /) -&gt; _InvokeHandlerProto:\n    \"\"\"This method is similar to [tauri::generate_handler](https://docs.rs/tauri/latest/tauri/macro.generate_handler.html).\n\n    You can use this method to get `invoke_handler` for use with [BuilderArgs][pytauri.BuilderArgs].\n\n    Examples:\n        ```py\n        from anyio.from_thread import start_blocking_portal\n\n        commands = Commands()\n\n        with start_blocking_portal(backend) as portal:\n            invoke_handler = commands.generate_handler(portal)\n            ...\n        ```\n\n    !!! warning\n        The `portal` must remain valid while the returned `invoke_handler` is being used.\n    \"\"\"\n    async_invoke_handler = self._async_invoke_handler\n\n    def invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - `invoke_handler` must not raise exception\n        # - must not block\n\n        # this func will be call in extern thread, so it's ok to use `start_task_soon`\n        portal.start_task_soon(async_invoke_handler, invoke)\n\n    return invoke_handler\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.wrap_pyfunc","title":"wrap_pyfunc","text":"<pre><code>wrap_pyfunc(pyfunc: _WrappablePyHandlerType, *, _gen_ts_cmd: Optional[str] = None) -&gt; _PyHandlerType\n</code></pre> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <p>Specifically:</p> <ul> <li>If <code>pyfunc</code> has a <code>KEYWORD_ONLY</code> parameter named <code>body</code>:<ul> <li>If <code>body</code> is <code>bytes</code>:     do nothing.</li> <li>If <code>issubclass(body, BaseModel)</code>:     wrap this callable as a new function with a <code>body: bytes</code> parameter.</li> <li>Otherwise:     try to convert it to a <code>BaseModel</code>/<code>TypeAdapter</code>, and proceed as in the <code>BaseModel</code> branch.</li> </ul> </li> <li>Handle the return type:<ul> <li>If the return type is <code>bytes</code>:     do nothing.</li> <li>If <code>issubclass(return_type, BaseModel)</code>:     wrap this callable as a new function with <code>return: str</code> value.</li> <li>Otherwise:     try to convert it to a <code>BaseModel</code>/<code>TypeAdapter</code>, and proceed as in the <code>BaseModel</code> branch.</li> </ul> </li> <li>If no wrapping is needed, the original <code>pyfunc</code> will be returned.</li> </ul> <p>The <code>pyfunc</code> will be decorated using functools.wraps, and its <code>__signature__</code> will also be updated.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def wrap_pyfunc(  # noqa: C901, PLR0912, PLR0915  # TODO: simplify this method\n    self, pyfunc: _WrappablePyHandlerType, *, _gen_ts_cmd: Optional[str] = None\n) -&gt; _PyHandlerType:\n    \"\"\"Wrap a `Callable` to conform to the definition of PyHandlerType.\n\n    Specifically:\n\n    - If `pyfunc` has a `KEYWORD_ONLY` parameter named `body`:\n        - If `body` is `bytes`:\n            do nothing.\n        - If `issubclass(body, BaseModel)`:\n            wrap this callable as a new function with a `body: bytes` parameter.\n        - Otherwise:\n            try to convert it to a `BaseModel`/`TypeAdapter`, and proceed as in the `BaseModel` branch.\n    - Handle the return type:\n        - If the return type is `bytes`:\n            do nothing.\n        - If `issubclass(return_type, BaseModel)`:\n            wrap this callable as a new function with `return: str` value.\n        - Otherwise:\n            try to convert it to a `BaseModel`/`TypeAdapter`, and proceed as in the `BaseModel` branch.\n    - If no wrapping is needed, the original `pyfunc` will be returned.\n\n    The `pyfunc` will be decorated using [functools.wraps][], and its `__signature__` will also be updated.\n    \"\"\"\n    serializer: Optional[_Serializer[Union[BaseModel, Any]]] = None\n    deserializer: Optional[_Deserializer[Union[BaseModel, Any]]] = None\n    input_type = NoneType\n    output_type = NoneType\n\n    body_key = \"body\"\n\n    sig = signature(pyfunc)\n    parameters = sig.parameters\n    return_annotation = sig.return_annotation\n\n    body_param = parameters.get(body_key)\n    if body_param is not None:\n        if body_param.kind not in {\n            Parameter.KEYWORD_ONLY,\n            Parameter.POSITIONAL_OR_KEYWORD,\n        }:\n            raise ValueError(\n                f\"Expected `{body_key}` to be KEYWORD parameter, but got `{body_param.kind}` parameter\"\n            )\n\n        body_type = body_param.annotation\n        if body_type is Parameter.empty:\n            raise ValueError(\n                f\"Expected `{body_key}` to have type annotation, but got empty\"\n            )\n        elif body_type is bytes:\n            serializer = None\n            input_type = bytes\n        # `Annotated`, `Union`, `None`, etc are not `type`\n        elif isinstance(body_type, type) and issubclass(body_type, BaseModel):\n            serializer = body_type.model_validate_json\n            input_type = body_type\n        else:\n            # PERF, FIXME: `cast` make pyright happy, it mistakenly thinks this is `Any | type[Unknown]`\n            body_type = cast(Any, body_type)\n            try:\n                model_serde = _type_to_model(body_type)\n            except Exception as e:\n                raise ValueError(\n                    f\"Failed to convert `{body_type}` type to pydantic Model, \"\n                    f\"please explicitly use {BaseModel} or {bytes} as `{body_key}` type annotation instead.\"\n                ) from e\n            serializer = model_serde.serializer\n            input_type = model_serde.model\n\n    if return_annotation is Signature.empty:\n        raise ValueError(\n            \"Expected the return value to have type annotation, but got empty. \"\n            \"Please explicitly use `def foo() -&gt; None:` instead.\"\n        )\n    elif return_annotation is bytes:\n        deserializer = None\n        output_type = bytes\n    # `Annotated`, `Union`, `None`, etc are not `type`\n    elif isinstance(return_annotation, type) and issubclass(\n        return_annotation, BaseModel\n    ):\n        # PERF: maybe we should cache this closure?\n        def _deserializer(data: BaseModel) -&gt; str:\n            return data.model_dump_json()\n\n        deserializer = _deserializer\n        output_type = return_annotation\n    else:\n        # PERF, FIXME: `cast` make pyright happy, it mistakenly thinks this is `Any | type[Unknown]`\n        return_annotation = cast(Any, return_annotation)\n        try:\n            model_serde = _type_to_model(return_annotation)\n        except Exception as e:\n            raise ValueError(\n                f\"Failed to convert `{return_annotation}` type to pydantic Model, \"\n                f\"please explicitly use {BaseModel} or {bytes} as return type annotation instead.\"\n            ) from e\n        deserializer = model_serde.deserializer\n        output_type = model_serde.model\n\n    if not serializer and not deserializer:\n        if _gen_ts_cmd is not None:\n            assert self._experimental_gen_ts is not None\n            self._experimental_gen_ts[_gen_ts_cmd] = InputOutput(\n                cmd_handler=pyfunc, input_type=input_type, output_type=output_type\n            )\n        return cast(_PyHandlerType, pyfunc)  # `cast` make typing happy\n\n    # NOTE: Use `wraps` to ensure the docstring is preserved correctly\n    @wraps(pyfunc)\n    async def wrapper(*args: Any, **kwargs: Any) -&gt; _InvokeResponseBody:\n        nonlocal serializer, deserializer\n\n        if serializer is not None:\n            body_bytes = kwargs[body_key]\n            assert isinstance(body_bytes, bytes)  # PERF\n            try:\n                body_arg = serializer(body_bytes)\n            except ValidationError as e:\n                raise InvokeException(repr(e)) from e\n            kwargs[body_key] = body_arg\n\n        resp = await pyfunc(*args, **kwargs)\n\n        if deserializer is not None:\n            # - subclass of `BaseModel`\n            # - other types that are not `bytes`\n            assert not isinstance(resp, bytes)  # PERF\n            return deserializer(resp)\n        else:\n            assert isinstance(resp, bytes)  # PERF\n            return resp\n\n    new_parameters = parameters.copy()\n    new_return_annotation = return_annotation\n    if serializer is not None:\n        new_parameters[body_key] = parameters[body_key].replace(annotation=bytes)\n    if deserializer is not None:\n        new_return_annotation = str\n\n    # see: &lt;https://docs.python.org/3.13/library/inspect.html#inspect.signature&gt;\n    wrapper.__signature__ = sig.replace(  # pyright: ignore[reportAttributeAccessIssue]\n        parameters=tuple(new_parameters.values()),\n        return_annotation=new_return_annotation,\n    )\n\n    if _gen_ts_cmd is not None:\n        assert self._experimental_gen_ts is not None\n        self._experimental_gen_ts[_gen_ts_cmd] = InputOutput(\n            cmd_handler=wrapper, input_type=input_type, output_type=output_type\n        )\n    return wrapper\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.parse_parameters","title":"parse_parameters  <code>staticmethod</code>","text":"<pre><code>parse_parameters(pyfunc: _PyHandlerType, /, check_signature: bool = True) -&gt; ParametersType\n</code></pre> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <p>Check if the Signature of <code>pyfunc</code> conforms to ArgumentsType, and if the return value is bytes or str.</p> <p>Parameters:</p> Name Type Description Default <code>_PyHandlerType</code> <p>The <code>Callable</code> to check.</p> required <code>bool</code> <p>Whether to check the signature of <code>pyfunc</code>. Set it to <code>False</code> only if you are sure that the signature conforms to the expected pattern.</p> <code>True</code> <p>Returns:</p> Type Description <code>ParametersType</code> <p>The parameters of the <code>pyfunc</code>. You can use it with Invoke.bind_to.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature does not conform to the expected pattern.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@staticmethod\ndef parse_parameters(\n    pyfunc: _PyHandlerType, /, check_signature: bool = True\n) -&gt; ParametersType:\n    \"\"\"Check the signature of a `Callable` and return the parameters.\n\n    Check if the [Signature][inspect.Signature] of `pyfunc` conforms to [ArgumentsType][pytauri.ipc.ArgumentsType],\n    and if the return value is [bytes][] or [str][].\n\n    Args:\n        pyfunc: The `Callable` to check.\n        check_signature: Whether to check the signature of `pyfunc`.\n            Set it to `False` only if you are sure that the signature conforms to the expected pattern.\n\n    Returns:\n        The parameters of the `pyfunc`. You can use it with [Invoke.bind_to][pytauri.ipc.Invoke.bind_to].\n\n    Raises:\n        ValueError: If the signature does not conform to the expected pattern.\n    \"\"\"\n    sig = signature(pyfunc)\n    parameters = sig.parameters\n    if not check_signature:\n        # `cast` make typing happy\n        return cast(ParametersType, parameters)\n\n    return_annotation = sig.return_annotation\n\n    arguments_type = {\n        \"body\": bytes,\n        \"app_handle\": AppHandle,\n        \"webview_window\": WebviewWindow,\n        \"headers\": Headers,\n    }\n\n    for name, param in parameters.items():\n        # check if the `parameters` type hint conforms to [pytauri.ipc.ArgumentsType][]\n\n        correct_anna = arguments_type.get(name)\n        if correct_anna is None:\n            raise ValueError(\n                f\"Unexpected parameter `{name}`, expected one of {list(arguments_type.keys())}\"\n            )\n        if param.annotation is not correct_anna:\n            raise ValueError(\n                f\"Expected `{name}` to be `{correct_anna}`, but got `{param.annotation}`\"\n            )\n        if param.kind not in {\n            Parameter.KEYWORD_ONLY,\n            Parameter.POSITIONAL_OR_KEYWORD,\n        }:\n            raise ValueError(\n                f\"Expected `{name}` to be KEYWORD parameter, but got `{param.kind}` parameter\"\n            )\n    else:\n        # after checking, we are sure that the `parameters` are valid\n        parameters = cast(ParametersType, parameters)\n\n    if return_annotation not in {bytes, str}:\n        raise ValueError(\n            f\"Expected `return_annotation` to be {bytes} or {str}, got `{return_annotation}`\"\n        )\n\n    return parameters\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.parse_parameters(pyfunc)","title":"<code>pyfunc</code>","text":""},{"location":"reference/py/pytauri/#pytauri.Commands.parse_parameters(check_signature)","title":"<code>check_signature</code>","text":""},{"location":"reference/py/pytauri/#pytauri.Commands.set_command","title":"set_command","text":"<pre><code>set_command(command: str, handler: _WrappablePyHandlerType, /, check_signature: bool = True) -&gt; None\n</code></pre> <p>Set a command handler.</p> <p>This method internally calls parse_parameters and wrap_pyfunc, <code>parse_parameters(wrap_pyfunc(handler))</code>.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def set_command(\n    self,\n    command: str,\n    handler: _WrappablePyHandlerType,\n    /,\n    check_signature: bool = True,\n) -&gt; None:\n    \"\"\"Set a command handler.\n\n    This method internally calls [parse_parameters][pytauri.Commands.parse_parameters]\n    and [wrap_pyfunc][pytauri.Commands.wrap_pyfunc], `parse_parameters(wrap_pyfunc(handler))`.\n    \"\"\"\n    new_handler = self.wrap_pyfunc(\n        handler,\n        _gen_ts_cmd=command if self._experimental_gen_ts is not None else None,\n    )\n    parameters = self.parse_parameters(new_handler, check_signature=check_signature)\n    self.data[command] = _PyInvokHandleData(parameters, new_handler)\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.command","title":"command","text":"<pre><code>command(command: Optional[str] = None) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]\n</code></pre> <p>A decorator to register a command handler.</p> <p>Examples:</p> <pre><code>commands = Commands()\n\n\n@commands.command()\nasync def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n@commands.command(\"foo_command\")\nasync def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n</code></pre> <p>This method internally calls set_command, which means the function signature must conform to ArgumentsType.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[str]</code> <p>The name of the command. If not provided, the <code>__name__</code> of <code>callable</code> will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a command with the same name already exists. If it's expected, use set_command instead.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def command(\n    self, command: Optional[str] = None, /\n) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]:\n    \"\"\"A [decorator](https://docs.python.org/3/glossary.html#term-decorator) to register a command handler.\n\n    Examples:\n        ```py\n        commands = Commands()\n\n\n        @commands.command()\n        async def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n        @commands.command(\"foo_command\")\n        async def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n        ```\n\n    This method internally calls [set_command][pytauri.Commands.set_command],\n    which means the function signature must conform to [ArgumentsType][pytauri.ipc.ArgumentsType].\n\n    Args:\n        command: The name of the command. If not provided, the `__name__` of `callable` will be used.\n\n    Raises:\n        ValueError: If a command with the same name already exists.\n            If it's expected, use [set_command][pytauri.Commands.set_command] instead.\n    \"\"\"\n    if command is None:\n        return self._register\n    else:\n        return partial(self._register, command=command)\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.command(command)","title":"<code>command</code>","text":""},{"location":"reference/py/pytauri/#pytauri.Commands.experimental_gen_ts","title":"experimental_gen_ts  <code>async</code>","text":"<pre><code>experimental_gen_ts(output_dir: Union[str, PathLike[str]], json2ts_cmd: str, *, cmd_alias: Optional[Callable[[str], str]] = to_camel) -&gt; None\n</code></pre> <p>Generate TypeScript types and API client from the registered commands.</p> <p>This method is only available if <code>experimental_gen_ts</code> is set to <code>True</code> when creating the <code>Commands</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>Union[str, PathLike[str]]</code> <p>The directory to output the generated TypeScript files.</p> required <code>str</code> <p>The command to run json-schema-to-typescript to generate TypeScript types.</p> required <code>Optional[Callable[[str], str]]</code> <p>An optional function to convert command names to TypeScript style. By default, it uses to_camel.</p> <code>to_camel</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>experimental_gen_ts</code> is not enabled when creating the <code>Commands</code> instance.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>async def experimental_gen_ts(\n    self,\n    output_dir: Union[str, PathLike[str]],\n    json2ts_cmd: str,\n    *,\n    cmd_alias: Optional[Callable[[str], str]] = to_camel,\n) -&gt; None:\n    \"\"\"Generate TypeScript types and API client from the registered commands.\n\n    This method is only available if `experimental_gen_ts` is set to `True`\n    when creating the `Commands` instance.\n\n    Args:\n        output_dir: The directory to output the generated TypeScript files.\n        json2ts_cmd: The command to run [json-schema-to-typescript] to generate TypeScript types.\n            [json-schema-to-typescript]: https://github.com/bcherny/json-schema-to-typescript/\n        cmd_alias: An optional function to convert command names to TypeScript style.\n            By default, it uses [to_camel][pydantic.alias_generators.to_camel].\n\n    Raises:\n        RuntimeError: If `experimental_gen_ts` is not enabled when creating the `Commands`\n            instance.\n    \"\"\"\n    if self._experimental_gen_ts is None:\n        raise RuntimeError(\n            \"Experimental TypeScript generation is not enabled. \"\n            \"Please set `experimental_gen_ts=True` when creating `Commands`.\"\n        )\n    cmd_in_out = self._experimental_gen_ts\n    del self._experimental_gen_ts  # release memory\n\n    await gen_ts(cmd_in_out, output_dir, json2ts_cmd, cmd_alias=cmd_alias)\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.experimental_gen_ts(output_dir)","title":"<code>output_dir</code>","text":""},{"location":"reference/py/pytauri/#pytauri.Commands.experimental_gen_ts(json2ts_cmd)","title":"<code>json2ts_cmd</code>","text":""},{"location":"reference/py/pytauri/#pytauri.Commands.experimental_gen_ts(cmd_alias)","title":"<code>cmd_alias</code>","text":""},{"location":"reference/py/pytauri/#pytauri.Commands.experimental_gen_ts_background","title":"experimental_gen_ts_background  <code>async</code>","text":"<pre><code>experimental_gen_ts_background(output_dir: Union[str, PathLike[str]], json2ts_cmd: str, *, cmd_alias: Optional[Callable[[str], str]] = to_camel) -&gt; None\n</code></pre> <p>Generate TypeScript types and API client from the registered commands in the background.</p> <p>See experimental_gen_ts for more details. This method is equivalent to:</p> <pre><code>try:\n    await self.experimental_gen_ts(\n        output_dir,\n        json2ts_cmd,\n        cmd_alias=cmd_alias,\n    )\nexcept Exception:\n    logging.exception(...)\n    return None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>async def experimental_gen_ts_background(\n    self,\n    output_dir: Union[str, PathLike[str]],\n    json2ts_cmd: str,\n    *,\n    cmd_alias: Optional[Callable[[str], str]] = to_camel,\n) -&gt; None:\n    \"\"\"Generate TypeScript types and API client from the registered commands in the background.\n\n    See [experimental_gen_ts][pytauri.ipc.Commands.experimental_gen_ts] for more details.\n    This method is equivalent to:\n\n    ```python\n    try:\n        await self.experimental_gen_ts(\n            output_dir,\n            json2ts_cmd,\n            cmd_alias=cmd_alias,\n        )\n    except Exception:\n        logging.exception(...)\n        return None\n    ```\n    \"\"\"\n    start_time = current_time()\n    _logger.info(\"Generating TypeScript types and API client in the background.\")\n    try:\n        await self.experimental_gen_ts(\n            output_dir,\n            json2ts_cmd,\n            cmd_alias=cmd_alias,\n        )\n    except Exception:\n        _logger.exception(\"Failed to generate TypeScript types and API client.\")\n        return None\n\n    elapsed = current_time() - start_time\n    _logger.info(\n        f\"Finished generating TypeScript types and API client in {elapsed:.2f} seconds.\"\n    )\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Emitter","title":"Emitter","text":"<p>               Bases: <code>Emitter</code></p> <p>tauri::Emitter</p> <p>See also: https://tauri.app/develop/calling-frontend/#event-system</p>"},{"location":"reference/py/pytauri/#pytauri.Emitter--examples","title":"Examples","text":"<pre><code>from pydantic import BaseModel\nfrom pytauri import AppHandle, Emitter\n\n\nclass Payload(BaseModel):  # or `RootModel`\n    url: str\n    num: int\n\n\ndef emit(app_handle: AppHandle) -&gt; None:\n    Emitter.emit(\n        app_handle, \"event_name\", Payload(url=\"https://example.com\", num=42)\n    )\n</code></pre> <p>Methods:</p> Name Description <code>emit_str</code> <p>Similar to [<code>Emitter::emit</code>] but the payload is json serialized.</p> <code>emit_str_to</code> <p>Similar to [<code>Emitter::emit_to</code>] but the payload is json serialized.</p> <code>emit_str_filter</code> <p>Similar to [<code>Emitter::emit_filter</code>] but the payload is json serialized.</p> <code>emit</code> <p>Emits an event to all <code>targets</code>.</p> <code>emit_to</code> <p>Emits an event to all <code>targets</code> matching the given target.</p> <code>emit_filter</code> <p>Emits an event to all <code>targets</code> based on the given filter.</p>"},{"location":"reference/py/pytauri/#pytauri.Emitter.emit_str","title":"emit_str  <code>staticmethod</code>","text":"<pre><code>emit_str(slf: ImplEmitter, event: str, payload: str) -&gt; None\n</code></pre> <p>Similar to [<code>Emitter::emit</code>] but the payload is json serialized.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef emit_str(\n    slf: \"ImplEmitter\",\n    event: str,\n    payload: str,\n    /,\n) -&gt; None:\n    \"\"\"Similar to [`Emitter::emit`] but the payload is json serialized.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Emitter.emit_str_to","title":"emit_str_to  <code>staticmethod</code>","text":"<pre><code>emit_str_to(slf: ImplEmitter, target: EventTargetType, event: str, payload: str) -&gt; None\n</code></pre> <p>Similar to [<code>Emitter::emit_to</code>] but the payload is json serialized.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef emit_str_to(\n    slf: \"ImplEmitter\",\n    target: \"EventTargetType\",\n    event: str,\n    payload: str,\n    /,\n) -&gt; None:\n    \"\"\"Similar to [`Emitter::emit_to`] but the payload is json serialized.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Emitter.emit_str_filter","title":"emit_str_filter  <code>staticmethod</code>","text":"<pre><code>emit_str_filter(slf: ImplEmitter, event: str, payload: str, filter: Callable[[EventTargetType], bool]) -&gt; None\n</code></pre> <p>Similar to [<code>Emitter::emit_filter</code>] but the payload is json serialized.</p> <p>Warning</p> <p><code>filter</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef emit_str_filter(\n    slf: \"ImplEmitter\",\n    event: str,\n    payload: str,\n    filter: Callable[[\"EventTargetType\"], bool],  # noqa: A002\n    /,\n) -&gt; None:\n    \"\"\"Similar to [`Emitter::emit_filter`] but the payload is json serialized.\n\n    !!! warning\n        `filter` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Emitter.emit","title":"emit  <code>classmethod</code>","text":"<pre><code>emit(slf: ImplEmitter, event: str, payload: BaseModel) -&gt; None\n</code></pre> <p>Emits an event to all <code>targets</code>.</p> Source code in <code>python/pytauri/src/pytauri/__init__.py</code> <pre><code>@classmethod\ndef emit(cls, slf: ImplEmitter, event: str, payload: BaseModel, /) -&gt; None:\n    \"\"\"Emits an event to all `targets`.\"\"\"\n    super().emit_str(slf, event, payload.model_dump_json())\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Emitter.emit_to","title":"emit_to  <code>classmethod</code>","text":"<pre><code>emit_to(slf: ImplEmitter, target: EventTargetType, event: str, payload: BaseModel) -&gt; None\n</code></pre> <p>Emits an event to all <code>targets</code> matching the given target.</p> Source code in <code>python/pytauri/src/pytauri/__init__.py</code> <pre><code>@classmethod\ndef emit_to(\n    cls,\n    slf: ImplEmitter,\n    target: EventTargetType,\n    event: str,\n    payload: BaseModel,\n    /,\n) -&gt; None:\n    \"\"\"Emits an event to all `targets` matching the given target.\"\"\"\n    super().emit_str_to(slf, target, event, payload.model_dump_json())\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Emitter.emit_filter","title":"emit_filter  <code>classmethod</code>","text":"<pre><code>emit_filter(slf: ImplEmitter, event: str, payload: BaseModel, filter: Callable[[EventTargetType], bool]) -&gt; None\n</code></pre> <p>Emits an event to all <code>targets</code> based on the given filter.</p> <p>Warning</p> <p><code>filter</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/__init__.py</code> <pre><code>@classmethod\ndef emit_filter(\n    cls,\n    slf: ImplEmitter,\n    event: str,\n    payload: BaseModel,\n    filter: Callable[[\"EventTargetType\"], bool],  # noqa: A002\n    /,\n) -&gt; None:\n    \"\"\"Emits an event to all `targets` based on the given filter.\n\n    !!! warning\n        `filter` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    super().emit_str_filter(slf, event, payload.model_dump_json(), filter)\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.builder_factory","title":"builder_factory","text":"<pre><code>builder_factory(*args: Any, **kwargs: Any) -&gt; Builder\n</code></pre> <p>A factory function for creating a <code>Builder</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def builder_factory(*args: Any, **kwargs: Any) -&gt; Builder:\n    \"\"\"A factory function for creating a `Builder` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.context_factory","title":"context_factory","text":"<pre><code>context_factory(*args: Any, **kwargs: Any) -&gt; Context\n</code></pre> <p>A factory function for creating a <code>Context</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def context_factory(*args: Any, **kwargs: Any) -&gt; Context:\n    \"\"\"A factory function for creating a `Context` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/image/","title":"image","text":""},{"location":"reference/py/pytauri/image/#pytauri.image","title":"pytauri.image","text":"<p>tauri::image</p> <p>Classes:</p> Name Description <code>Image</code> <p>tauri::image::Image</p>"},{"location":"reference/py/pytauri/image/#pytauri.image.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Image']\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image","title":"Image","text":"<p>               Bases: <code>Image</code></p> <p>tauri::image::Image</p> <p>Methods:</p> Name Description <code>__new__</code> <code>from_pil</code> <p>Creates a new image using the provided <code>PIL</code> image.</p> <code>from_bytes</code> <p>Create an image from bytes.</p> <code>from_path</code> <p>Create an image from a file path.</p> <p>Attributes:</p> Name Type Description <code>rgba</code> <code>bytes</code> <code>width</code> <code>int</code> <code>height</code> <code>int</code>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.rgba","title":"rgba  <code>property</code>","text":"<pre><code>rgba: bytes\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.__new__","title":"__new__","text":"<pre><code>__new__(rgba: bytes, width: int, height: int) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/image.py</code> <pre><code>def __new__(cls, rgba: bytes, width: int, height: int, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.from_pil","title":"from_pil  <code>classmethod</code>","text":"<pre><code>from_pil(image: Image) -&gt; Self\n</code></pre> <p>Creates a new image using the provided <code>PIL</code> image.</p> <p>The original <code>tauri::image::Image::from_bytes</code> only supports <code>.ico</code> and <code>.png</code> formats. But this method supports all formats supported by <code>PIL</code>.</p> <p>Note</p> <p><code>Tauri</code> requires images to be in <code>RGBA</code> mode. If the provided image is not in <code>RGBA</code> mode, it will be converted to <code>RGBA</code> mode as a copy.</p> Source code in <code>python/pytauri/src/pytauri/image.py</code> <pre><code>@classmethod\ndef from_pil(cls, image: PILImage.Image) -&gt; Self:\n    \"\"\"Creates a new image using the provided `PIL` image.\n\n    The original `tauri::image::Image::from_bytes` only supports `.ico` and `.png` formats.\n    But this method supports **all formats supported by `PIL`**.\n\n    !!! note\n        `Tauri` requires images to be in `RGBA` mode.\n        If the provided image is not in `RGBA` mode, it will be converted to `RGBA` mode as a copy.\n    \"\"\"\n    if image.mode != cls._MODE:\n        image = image.convert(cls._MODE)\n    return cls(image.tobytes(), *image.size)\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(bytes_: Union[bytes, bytearray, memoryview]) -&gt; Self\n</code></pre> <p>Create an image from bytes.</p> <p>This method calls pytauri.image.Image.from_pil internally.</p> Source code in <code>python/pytauri/src/pytauri/image.py</code> <pre><code>@classmethod\ndef from_bytes(cls, bytes_: Union[bytes, bytearray, memoryview], /) -&gt; Self:\n    \"\"\"Create an image from bytes.\n\n    This method calls [pytauri.image.Image.from_pil][] internally.\n    \"\"\"\n    return cls.from_pil(PILImage.open(BytesIO(bytes_)))\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.from_path","title":"from_path  <code>classmethod</code>","text":"<pre><code>from_path(path: Union[str, bytes, PathLike[str], PathLike[bytes]]) -&gt; Self\n</code></pre> <p>Create an image from a file path.</p> <p>This method calls pytauri.image.Image.from_pil internally.</p> Source code in <code>python/pytauri/src/pytauri/image.py</code> <pre><code>@classmethod\ndef from_path(\n    cls, path: Union[str, bytes, PathLike[str], PathLike[bytes]], /\n) -&gt; Self:\n    \"\"\"Create an image from a file path.\n\n    This method calls [pytauri.image.Image.from_pil][] internally.\n    \"\"\"\n    return cls.from_pil(PILImage.open(path))\n</code></pre>"},{"location":"reference/py/pytauri/ipc/","title":"ipc","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc","title":"pytauri.ipc","text":"<p>tauri::ipc</p> <p>Classes:</p> Name Description <code>ArgumentsType</code> <p>The bound arguments of a command.</p> <code>Invoke</code> <p>tauri::ipc::Invoke</p> <code>InvokeResolver</code> <p>tauri::ipc::InvokeResolver</p> <code>ParametersType</code> <p>The parameters of a command.</p> <code>InvokeException</code> <p>Indicates that an exception occurred in a <code>command</code>. Similar to Rust's <code>Result::Err</code>.</p> <code>Commands</code> <p>This class provides features similar to tauri::generate_handler.</p> <code>JavaScriptChannelId</code> <p>This class is a wrapper around pytauri.ffi.ipc.JavaScriptChannelId.</p> <code>Channel</code> <p>This class is a wrapper around pytauri.ffi.ipc.Channel.</p> <p>Attributes:</p> Name Type Description <code>Headers</code> <p>http::header::HeaderMap::iter</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Headers","title":"Headers  <code>module-attribute</code>","text":"<pre><code>Headers = TypeAliasType('Headers', list[tuple[bytes, bytes]])\n</code></pre> <p>http::header::HeaderMap::iter</p> <p><code>(key, value)</code> pairs of headers.</p> <p>Each key will be yielded once per associated value. So, if a key has 3 associated values, it will be yielded 3 times.</p> <pre><code>[(b\"key0\", b\"value00\"), (b\"key0\", b\"value01\"), (b\"key1\", b\"value1\")]\n</code></pre> <p>Tip</p> <p>You can use libraries like multidict or httpx.Headers to convert it into dict for more efficient retrieval of a specific header.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ArgumentsType', 'Channel', 'Commands', 'Headers', 'Invoke', 'InvokeException', 'InvokeResolver', 'JavaScriptChannelId', 'ParametersType']\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ArgumentsType","title":"ArgumentsType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The bound arguments of a command.</p> <p>Each key is optional, depending on the keys of the bound ParametersType.</p> <p>You can use it like <code>**kwargs</code>, for example <code>command(**arguments)</code>.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>bytes</code> <p>The body of this ipc message.</p> <code>app_handle</code> <code>AppHandle</code> <p>The handle of the app.</p> <code>webview_window</code> <code>WebviewWindow</code> <p>The <code>WebviewWindow</code> of this <code>Invoke</code>.</p> <code>headers</code> <code>Headers</code> <p>The headers of this ipc message.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ArgumentsType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: bytes\n</code></pre> <p>The body of this ipc message.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ArgumentsType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: AppHandle\n</code></pre> <p>The handle of the app.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ArgumentsType.webview_window","title":"webview_window  <code>instance-attribute</code>","text":"<pre><code>webview_window: WebviewWindow\n</code></pre> <p>The <code>WebviewWindow</code> of this <code>Invoke</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ArgumentsType.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers: Headers\n</code></pre> <p>The headers of this ipc message.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke","title":"Invoke","text":"<p>tauri::ipc::Invoke</p> <p>Methods:</p> Name Description <code>bind_to</code> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <code>resolve</code> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>The name of the current command.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke.command","title":"command  <code>property</code>","text":"<pre><code>command: str\n</code></pre> <p>The name of the current command.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke.bind_to","title":"bind_to","text":"<pre><code>bind_to(parameters: ParametersType) -&gt; Optional[InvokeResolver[_ArgumentsTypeVar]]\n</code></pre> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <p>If the frontend illegally calls the IPC, this method will automatically reject this <code>Invoke</code> and return <code>None</code>.</p> <p>The return value InvokeResolver.arguments is not the same object as the input <code>parameters</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def bind_to(\n    self, parameters: ParametersType\n) -&gt; Optional[\"InvokeResolver[_ArgumentsTypeVar]\"]:\n    \"\"\"Consumes this `Invoke` and binds parameters.\n\n    If the frontend illegally calls the IPC,\n    this method will automatically reject this `Invoke` and return `None`.\n\n    The return value [InvokeResolver.arguments][pytauri.ffi.ipc.InvokeResolver.arguments]\n    is not the same object as the input `parameters`.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke.resolve","title":"resolve","text":"<pre><code>resolve(value: _InvokeResponseBody) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> <p>Parameters:</p> Name Type Description Default <code>_InvokeResponseBody</code> <p>The value to resolve the command with.</p> <ul> <li>If <code>str</code>, it will be serialized as JSON on the frontend.</li> <li>If <code>bytes</code>, it will be sent as <code>ArrayBuffer</code> to the frontend.</li> </ul> required Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: _InvokeResponseBody) -&gt; None:\n    \"\"\"Consumes this `Invoke` and resolves the command with the given value.\n\n    Args:\n        value: The value to resolve the command with.\n\n            - If `str`, it will be serialized as JSON on the frontend.\n            - If `bytes`, it will be sent as `ArrayBuffer` to the frontend.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke.resolve(value)","title":"<code>value</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `Invoke` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeResolver","title":"InvokeResolver","text":"<p>               Bases: <code>Generic[_ArgumentsTypeVar]</code></p> <p>tauri::ipc::InvokeResolver</p> <p>Methods:</p> Name Description <code>resolve</code> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>arguments</code> <code>_ArgumentsTypeVar</code> <p>The bound arguments of the current command.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeResolver.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: _ArgumentsTypeVar\n</code></pre> <p>The bound arguments of the current command.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeResolver.resolve","title":"resolve","text":"<pre><code>resolve(value: _InvokeResponseBody) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> <p>Parameters:</p> Name Type Description Default <code>_InvokeResponseBody</code> <p>The value to resolve the command with.</p> <ul> <li>If <code>str</code>, it will be serialized as JSON on the frontend.</li> <li>If <code>bytes</code>, it will be sent as <code>ArrayBuffer</code> to the frontend.</li> </ul> required Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: _InvokeResponseBody) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and resolves the command with the given value.\n\n    Args:\n        value: The value to resolve the command with.\n\n            - If `str`, it will be serialized as JSON on the frontend.\n            - If `bytes`, it will be sent as `ArrayBuffer` to the frontend.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeResolver.resolve(value)","title":"<code>value</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeResolver.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ParametersType","title":"ParametersType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The parameters of a command.</p> <p>All keys are optional, and values can be of any type. If a key exists, it will be assigned a value corresponding to ArgumentsType.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p> <code>app_handle</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p> <code>webview_window</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p> <code>headers</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ParametersType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ParametersType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ParametersType.webview_window","title":"webview_window  <code>instance-attribute</code>","text":"<pre><code>webview_window: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ParametersType.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeException","title":"InvokeException","text":"<pre><code>InvokeException(value: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Indicates that an exception occurred in a <code>command</code>. Similar to Rust's <code>Result::Err</code>.</p> <p>When this exception is raised in a <code>command</code>, pytauri will return it to the frontend through <code>Invoke.reject(value)</code> and will not log the exception on the python side.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>The error message that will be returned to the frontend.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self, value: str) -&gt; None:  # noqa: D107\n    self.value = value\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeException.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: str = value\n</code></pre> <p>The error message that will be returned to the frontend.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands","title":"Commands","text":"<pre><code>Commands(*, experimental_gen_ts: bool = False)\n</code></pre> <p>               Bases: <code>UserDict[str, _PyInvokHandleData]</code></p> <p>This class provides features similar to tauri::generate_handler.</p> <p>Typically, you would use Commands.command to register a command handler function. Then, use Commands.generate_handler to get an <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Methods:</p> Name Description <code>generate_handler</code> <p>This method is similar to tauri::generate_handler.</p> <code>wrap_pyfunc</code> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <code>parse_parameters</code> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <code>set_command</code> <p>Set a command handler.</p> <code>command</code> <p>A decorator to register a command handler.</p> <code>experimental_gen_ts</code> <p>Generate TypeScript types and API client from the registered commands.</p> <code>experimental_gen_ts_background</code> <p>Generate TypeScript types and API client from the registered commands in the background.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self, *, experimental_gen_ts: bool = False) -&gt; None:  # noqa: D107\n    super().__init__()\n\n    self._experimental_gen_ts = {} if experimental_gen_ts else None\n\n    data = self.data\n\n    async def _async_invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - the implementer of this function must not raise exceptions\n        # - and must ensure to fulfill `invoke/resolver`\n        resolver = None\n        try:\n            command = invoke.command\n            handler_data = data.get(command)\n            if handler_data is None:\n                invoke.reject(f\"no python handler `{command}` found\")\n                return\n\n            parameters = handler_data.parameters\n            handler = handler_data.handler\n\n            resolver = invoke.bind_to(parameters)\n            if resolver is None:\n                # `invoke` has already been rejected\n                return\n\n            try:\n                resp = await handler(**resolver.arguments)\n                # TODO, PERF: idk if this will block?\n            except InvokeException as e:\n                resolver.reject(e.value)\n            except Exception as e:\n                # # TODO: Should we return the traceback to the frontend?\n                # # It might leak information.\n                # from traceback import format_exc\n                # resolver.reject(format_exc())\n                _logger.exception(\n                    f\"invoke_handler {handler}: `{handler.__name__}` raised an exception\",\n                    exc_info=e,\n                )\n                resolver.reject(repr(e))\n            else:\n                resolver.resolve(resp)\n\n        except Exception as e:\n            msg = f\"{_async_invoke_handler} implementation raised an exception, please report this as a pytauri bug\"\n\n            _logger.critical(msg, exc_info=e)\n            if resolver is not None:\n                resolver.reject(msg)\n            else:\n                invoke.reject(msg)\n            raise\n\n    self._async_invoke_handler = _async_invoke_handler\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.generate_handler","title":"generate_handler","text":"<pre><code>generate_handler(portal: BlockingPortal) -&gt; _InvokeHandlerProto\n</code></pre> <p>This method is similar to tauri::generate_handler.</p> <p>You can use this method to get <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Examples:</p> <pre><code>from anyio.from_thread import start_blocking_portal\n\ncommands = Commands()\n\nwith start_blocking_portal(backend) as portal:\n    invoke_handler = commands.generate_handler(portal)\n    ...\n</code></pre> <p>Warning</p> <p>The <code>portal</code> must remain valid while the returned <code>invoke_handler</code> is being used.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def generate_handler(self, portal: BlockingPortal, /) -&gt; _InvokeHandlerProto:\n    \"\"\"This method is similar to [tauri::generate_handler](https://docs.rs/tauri/latest/tauri/macro.generate_handler.html).\n\n    You can use this method to get `invoke_handler` for use with [BuilderArgs][pytauri.BuilderArgs].\n\n    Examples:\n        ```py\n        from anyio.from_thread import start_blocking_portal\n\n        commands = Commands()\n\n        with start_blocking_portal(backend) as portal:\n            invoke_handler = commands.generate_handler(portal)\n            ...\n        ```\n\n    !!! warning\n        The `portal` must remain valid while the returned `invoke_handler` is being used.\n    \"\"\"\n    async_invoke_handler = self._async_invoke_handler\n\n    def invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - `invoke_handler` must not raise exception\n        # - must not block\n\n        # this func will be call in extern thread, so it's ok to use `start_task_soon`\n        portal.start_task_soon(async_invoke_handler, invoke)\n\n    return invoke_handler\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.wrap_pyfunc","title":"wrap_pyfunc","text":"<pre><code>wrap_pyfunc(pyfunc: _WrappablePyHandlerType, *, _gen_ts_cmd: Optional[str] = None) -&gt; _PyHandlerType\n</code></pre> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <p>Specifically:</p> <ul> <li>If <code>pyfunc</code> has a <code>KEYWORD_ONLY</code> parameter named <code>body</code>:<ul> <li>If <code>body</code> is <code>bytes</code>:     do nothing.</li> <li>If <code>issubclass(body, BaseModel)</code>:     wrap this callable as a new function with a <code>body: bytes</code> parameter.</li> <li>Otherwise:     try to convert it to a <code>BaseModel</code>/<code>TypeAdapter</code>, and proceed as in the <code>BaseModel</code> branch.</li> </ul> </li> <li>Handle the return type:<ul> <li>If the return type is <code>bytes</code>:     do nothing.</li> <li>If <code>issubclass(return_type, BaseModel)</code>:     wrap this callable as a new function with <code>return: str</code> value.</li> <li>Otherwise:     try to convert it to a <code>BaseModel</code>/<code>TypeAdapter</code>, and proceed as in the <code>BaseModel</code> branch.</li> </ul> </li> <li>If no wrapping is needed, the original <code>pyfunc</code> will be returned.</li> </ul> <p>The <code>pyfunc</code> will be decorated using functools.wraps, and its <code>__signature__</code> will also be updated.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def wrap_pyfunc(  # noqa: C901, PLR0912, PLR0915  # TODO: simplify this method\n    self, pyfunc: _WrappablePyHandlerType, *, _gen_ts_cmd: Optional[str] = None\n) -&gt; _PyHandlerType:\n    \"\"\"Wrap a `Callable` to conform to the definition of PyHandlerType.\n\n    Specifically:\n\n    - If `pyfunc` has a `KEYWORD_ONLY` parameter named `body`:\n        - If `body` is `bytes`:\n            do nothing.\n        - If `issubclass(body, BaseModel)`:\n            wrap this callable as a new function with a `body: bytes` parameter.\n        - Otherwise:\n            try to convert it to a `BaseModel`/`TypeAdapter`, and proceed as in the `BaseModel` branch.\n    - Handle the return type:\n        - If the return type is `bytes`:\n            do nothing.\n        - If `issubclass(return_type, BaseModel)`:\n            wrap this callable as a new function with `return: str` value.\n        - Otherwise:\n            try to convert it to a `BaseModel`/`TypeAdapter`, and proceed as in the `BaseModel` branch.\n    - If no wrapping is needed, the original `pyfunc` will be returned.\n\n    The `pyfunc` will be decorated using [functools.wraps][], and its `__signature__` will also be updated.\n    \"\"\"\n    serializer: Optional[_Serializer[Union[BaseModel, Any]]] = None\n    deserializer: Optional[_Deserializer[Union[BaseModel, Any]]] = None\n    input_type = NoneType\n    output_type = NoneType\n\n    body_key = \"body\"\n\n    sig = signature(pyfunc)\n    parameters = sig.parameters\n    return_annotation = sig.return_annotation\n\n    body_param = parameters.get(body_key)\n    if body_param is not None:\n        if body_param.kind not in {\n            Parameter.KEYWORD_ONLY,\n            Parameter.POSITIONAL_OR_KEYWORD,\n        }:\n            raise ValueError(\n                f\"Expected `{body_key}` to be KEYWORD parameter, but got `{body_param.kind}` parameter\"\n            )\n\n        body_type = body_param.annotation\n        if body_type is Parameter.empty:\n            raise ValueError(\n                f\"Expected `{body_key}` to have type annotation, but got empty\"\n            )\n        elif body_type is bytes:\n            serializer = None\n            input_type = bytes\n        # `Annotated`, `Union`, `None`, etc are not `type`\n        elif isinstance(body_type, type) and issubclass(body_type, BaseModel):\n            serializer = body_type.model_validate_json\n            input_type = body_type\n        else:\n            # PERF, FIXME: `cast` make pyright happy, it mistakenly thinks this is `Any | type[Unknown]`\n            body_type = cast(Any, body_type)\n            try:\n                model_serde = _type_to_model(body_type)\n            except Exception as e:\n                raise ValueError(\n                    f\"Failed to convert `{body_type}` type to pydantic Model, \"\n                    f\"please explicitly use {BaseModel} or {bytes} as `{body_key}` type annotation instead.\"\n                ) from e\n            serializer = model_serde.serializer\n            input_type = model_serde.model\n\n    if return_annotation is Signature.empty:\n        raise ValueError(\n            \"Expected the return value to have type annotation, but got empty. \"\n            \"Please explicitly use `def foo() -&gt; None:` instead.\"\n        )\n    elif return_annotation is bytes:\n        deserializer = None\n        output_type = bytes\n    # `Annotated`, `Union`, `None`, etc are not `type`\n    elif isinstance(return_annotation, type) and issubclass(\n        return_annotation, BaseModel\n    ):\n        # PERF: maybe we should cache this closure?\n        def _deserializer(data: BaseModel) -&gt; str:\n            return data.model_dump_json()\n\n        deserializer = _deserializer\n        output_type = return_annotation\n    else:\n        # PERF, FIXME: `cast` make pyright happy, it mistakenly thinks this is `Any | type[Unknown]`\n        return_annotation = cast(Any, return_annotation)\n        try:\n            model_serde = _type_to_model(return_annotation)\n        except Exception as e:\n            raise ValueError(\n                f\"Failed to convert `{return_annotation}` type to pydantic Model, \"\n                f\"please explicitly use {BaseModel} or {bytes} as return type annotation instead.\"\n            ) from e\n        deserializer = model_serde.deserializer\n        output_type = model_serde.model\n\n    if not serializer and not deserializer:\n        if _gen_ts_cmd is not None:\n            assert self._experimental_gen_ts is not None\n            self._experimental_gen_ts[_gen_ts_cmd] = InputOutput(\n                cmd_handler=pyfunc, input_type=input_type, output_type=output_type\n            )\n        return cast(_PyHandlerType, pyfunc)  # `cast` make typing happy\n\n    # NOTE: Use `wraps` to ensure the docstring is preserved correctly\n    @wraps(pyfunc)\n    async def wrapper(*args: Any, **kwargs: Any) -&gt; _InvokeResponseBody:\n        nonlocal serializer, deserializer\n\n        if serializer is not None:\n            body_bytes = kwargs[body_key]\n            assert isinstance(body_bytes, bytes)  # PERF\n            try:\n                body_arg = serializer(body_bytes)\n            except ValidationError as e:\n                raise InvokeException(repr(e)) from e\n            kwargs[body_key] = body_arg\n\n        resp = await pyfunc(*args, **kwargs)\n\n        if deserializer is not None:\n            # - subclass of `BaseModel`\n            # - other types that are not `bytes`\n            assert not isinstance(resp, bytes)  # PERF\n            return deserializer(resp)\n        else:\n            assert isinstance(resp, bytes)  # PERF\n            return resp\n\n    new_parameters = parameters.copy()\n    new_return_annotation = return_annotation\n    if serializer is not None:\n        new_parameters[body_key] = parameters[body_key].replace(annotation=bytes)\n    if deserializer is not None:\n        new_return_annotation = str\n\n    # see: &lt;https://docs.python.org/3.13/library/inspect.html#inspect.signature&gt;\n    wrapper.__signature__ = sig.replace(  # pyright: ignore[reportAttributeAccessIssue]\n        parameters=tuple(new_parameters.values()),\n        return_annotation=new_return_annotation,\n    )\n\n    if _gen_ts_cmd is not None:\n        assert self._experimental_gen_ts is not None\n        self._experimental_gen_ts[_gen_ts_cmd] = InputOutput(\n            cmd_handler=wrapper, input_type=input_type, output_type=output_type\n        )\n    return wrapper\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.parse_parameters","title":"parse_parameters  <code>staticmethod</code>","text":"<pre><code>parse_parameters(pyfunc: _PyHandlerType, /, check_signature: bool = True) -&gt; ParametersType\n</code></pre> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <p>Check if the Signature of <code>pyfunc</code> conforms to ArgumentsType, and if the return value is bytes or str.</p> <p>Parameters:</p> Name Type Description Default <code>_PyHandlerType</code> <p>The <code>Callable</code> to check.</p> required <code>bool</code> <p>Whether to check the signature of <code>pyfunc</code>. Set it to <code>False</code> only if you are sure that the signature conforms to the expected pattern.</p> <code>True</code> <p>Returns:</p> Type Description <code>ParametersType</code> <p>The parameters of the <code>pyfunc</code>. You can use it with Invoke.bind_to.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature does not conform to the expected pattern.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@staticmethod\ndef parse_parameters(\n    pyfunc: _PyHandlerType, /, check_signature: bool = True\n) -&gt; ParametersType:\n    \"\"\"Check the signature of a `Callable` and return the parameters.\n\n    Check if the [Signature][inspect.Signature] of `pyfunc` conforms to [ArgumentsType][pytauri.ipc.ArgumentsType],\n    and if the return value is [bytes][] or [str][].\n\n    Args:\n        pyfunc: The `Callable` to check.\n        check_signature: Whether to check the signature of `pyfunc`.\n            Set it to `False` only if you are sure that the signature conforms to the expected pattern.\n\n    Returns:\n        The parameters of the `pyfunc`. You can use it with [Invoke.bind_to][pytauri.ipc.Invoke.bind_to].\n\n    Raises:\n        ValueError: If the signature does not conform to the expected pattern.\n    \"\"\"\n    sig = signature(pyfunc)\n    parameters = sig.parameters\n    if not check_signature:\n        # `cast` make typing happy\n        return cast(ParametersType, parameters)\n\n    return_annotation = sig.return_annotation\n\n    arguments_type = {\n        \"body\": bytes,\n        \"app_handle\": AppHandle,\n        \"webview_window\": WebviewWindow,\n        \"headers\": Headers,\n    }\n\n    for name, param in parameters.items():\n        # check if the `parameters` type hint conforms to [pytauri.ipc.ArgumentsType][]\n\n        correct_anna = arguments_type.get(name)\n        if correct_anna is None:\n            raise ValueError(\n                f\"Unexpected parameter `{name}`, expected one of {list(arguments_type.keys())}\"\n            )\n        if param.annotation is not correct_anna:\n            raise ValueError(\n                f\"Expected `{name}` to be `{correct_anna}`, but got `{param.annotation}`\"\n            )\n        if param.kind not in {\n            Parameter.KEYWORD_ONLY,\n            Parameter.POSITIONAL_OR_KEYWORD,\n        }:\n            raise ValueError(\n                f\"Expected `{name}` to be KEYWORD parameter, but got `{param.kind}` parameter\"\n            )\n    else:\n        # after checking, we are sure that the `parameters` are valid\n        parameters = cast(ParametersType, parameters)\n\n    if return_annotation not in {bytes, str}:\n        raise ValueError(\n            f\"Expected `return_annotation` to be {bytes} or {str}, got `{return_annotation}`\"\n        )\n\n    return parameters\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.parse_parameters(pyfunc)","title":"<code>pyfunc</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.parse_parameters(check_signature)","title":"<code>check_signature</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.set_command","title":"set_command","text":"<pre><code>set_command(command: str, handler: _WrappablePyHandlerType, /, check_signature: bool = True) -&gt; None\n</code></pre> <p>Set a command handler.</p> <p>This method internally calls parse_parameters and wrap_pyfunc, <code>parse_parameters(wrap_pyfunc(handler))</code>.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def set_command(\n    self,\n    command: str,\n    handler: _WrappablePyHandlerType,\n    /,\n    check_signature: bool = True,\n) -&gt; None:\n    \"\"\"Set a command handler.\n\n    This method internally calls [parse_parameters][pytauri.Commands.parse_parameters]\n    and [wrap_pyfunc][pytauri.Commands.wrap_pyfunc], `parse_parameters(wrap_pyfunc(handler))`.\n    \"\"\"\n    new_handler = self.wrap_pyfunc(\n        handler,\n        _gen_ts_cmd=command if self._experimental_gen_ts is not None else None,\n    )\n    parameters = self.parse_parameters(new_handler, check_signature=check_signature)\n    self.data[command] = _PyInvokHandleData(parameters, new_handler)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.command","title":"command","text":"<pre><code>command(command: Optional[str] = None) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]\n</code></pre> <p>A decorator to register a command handler.</p> <p>Examples:</p> <pre><code>commands = Commands()\n\n\n@commands.command()\nasync def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n@commands.command(\"foo_command\")\nasync def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n</code></pre> <p>This method internally calls set_command, which means the function signature must conform to ArgumentsType.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[str]</code> <p>The name of the command. If not provided, the <code>__name__</code> of <code>callable</code> will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a command with the same name already exists. If it's expected, use set_command instead.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def command(\n    self, command: Optional[str] = None, /\n) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]:\n    \"\"\"A [decorator](https://docs.python.org/3/glossary.html#term-decorator) to register a command handler.\n\n    Examples:\n        ```py\n        commands = Commands()\n\n\n        @commands.command()\n        async def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n        @commands.command(\"foo_command\")\n        async def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n        ```\n\n    This method internally calls [set_command][pytauri.Commands.set_command],\n    which means the function signature must conform to [ArgumentsType][pytauri.ipc.ArgumentsType].\n\n    Args:\n        command: The name of the command. If not provided, the `__name__` of `callable` will be used.\n\n    Raises:\n        ValueError: If a command with the same name already exists.\n            If it's expected, use [set_command][pytauri.Commands.set_command] instead.\n    \"\"\"\n    if command is None:\n        return self._register\n    else:\n        return partial(self._register, command=command)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.command(command)","title":"<code>command</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.experimental_gen_ts","title":"experimental_gen_ts  <code>async</code>","text":"<pre><code>experimental_gen_ts(output_dir: Union[str, PathLike[str]], json2ts_cmd: str, *, cmd_alias: Optional[Callable[[str], str]] = to_camel) -&gt; None\n</code></pre> <p>Generate TypeScript types and API client from the registered commands.</p> <p>This method is only available if <code>experimental_gen_ts</code> is set to <code>True</code> when creating the <code>Commands</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>Union[str, PathLike[str]]</code> <p>The directory to output the generated TypeScript files.</p> required <code>str</code> <p>The command to run json-schema-to-typescript to generate TypeScript types.</p> required <code>Optional[Callable[[str], str]]</code> <p>An optional function to convert command names to TypeScript style. By default, it uses to_camel.</p> <code>to_camel</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>experimental_gen_ts</code> is not enabled when creating the <code>Commands</code> instance.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>async def experimental_gen_ts(\n    self,\n    output_dir: Union[str, PathLike[str]],\n    json2ts_cmd: str,\n    *,\n    cmd_alias: Optional[Callable[[str], str]] = to_camel,\n) -&gt; None:\n    \"\"\"Generate TypeScript types and API client from the registered commands.\n\n    This method is only available if `experimental_gen_ts` is set to `True`\n    when creating the `Commands` instance.\n\n    Args:\n        output_dir: The directory to output the generated TypeScript files.\n        json2ts_cmd: The command to run [json-schema-to-typescript] to generate TypeScript types.\n            [json-schema-to-typescript]: https://github.com/bcherny/json-schema-to-typescript/\n        cmd_alias: An optional function to convert command names to TypeScript style.\n            By default, it uses [to_camel][pydantic.alias_generators.to_camel].\n\n    Raises:\n        RuntimeError: If `experimental_gen_ts` is not enabled when creating the `Commands`\n            instance.\n    \"\"\"\n    if self._experimental_gen_ts is None:\n        raise RuntimeError(\n            \"Experimental TypeScript generation is not enabled. \"\n            \"Please set `experimental_gen_ts=True` when creating `Commands`.\"\n        )\n    cmd_in_out = self._experimental_gen_ts\n    del self._experimental_gen_ts  # release memory\n\n    await gen_ts(cmd_in_out, output_dir, json2ts_cmd, cmd_alias=cmd_alias)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.experimental_gen_ts(output_dir)","title":"<code>output_dir</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.experimental_gen_ts(json2ts_cmd)","title":"<code>json2ts_cmd</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.experimental_gen_ts(cmd_alias)","title":"<code>cmd_alias</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.experimental_gen_ts_background","title":"experimental_gen_ts_background  <code>async</code>","text":"<pre><code>experimental_gen_ts_background(output_dir: Union[str, PathLike[str]], json2ts_cmd: str, *, cmd_alias: Optional[Callable[[str], str]] = to_camel) -&gt; None\n</code></pre> <p>Generate TypeScript types and API client from the registered commands in the background.</p> <p>See experimental_gen_ts for more details. This method is equivalent to:</p> <pre><code>try:\n    await self.experimental_gen_ts(\n        output_dir,\n        json2ts_cmd,\n        cmd_alias=cmd_alias,\n    )\nexcept Exception:\n    logging.exception(...)\n    return None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>async def experimental_gen_ts_background(\n    self,\n    output_dir: Union[str, PathLike[str]],\n    json2ts_cmd: str,\n    *,\n    cmd_alias: Optional[Callable[[str], str]] = to_camel,\n) -&gt; None:\n    \"\"\"Generate TypeScript types and API client from the registered commands in the background.\n\n    See [experimental_gen_ts][pytauri.ipc.Commands.experimental_gen_ts] for more details.\n    This method is equivalent to:\n\n    ```python\n    try:\n        await self.experimental_gen_ts(\n            output_dir,\n            json2ts_cmd,\n            cmd_alias=cmd_alias,\n        )\n    except Exception:\n        logging.exception(...)\n        return None\n    ```\n    \"\"\"\n    start_time = current_time()\n    _logger.info(\"Generating TypeScript types and API client in the background.\")\n    try:\n        await self.experimental_gen_ts(\n            output_dir,\n            json2ts_cmd,\n            cmd_alias=cmd_alias,\n        )\n    except Exception:\n        _logger.exception(\"Failed to generate TypeScript types and API client.\")\n        return None\n\n    elapsed = current_time() - start_time\n    _logger.info(\n        f\"Finished generating TypeScript types and API client in {elapsed:.2f} seconds.\"\n    )\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.JavaScriptChannelId","title":"JavaScriptChannelId","text":"<p>               Bases: <code>RootModel[_FFIJavaScriptChannelIdAnno]</code>, <code>Generic[_ModelTypeVar]</code></p> <p>This class is a wrapper around pytauri.ffi.ipc.JavaScriptChannelId.</p> <p>You can use this class as model field in pydantic model directly, or use it as model directly.</p> <p>pytauri.ffi.ipc.JavaScriptChannelId can't be used directly in pydantic model.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.JavaScriptChannelId--examples","title":"Examples","text":"<pre><code>from asyncio import Task, create_task, sleep\nfrom typing import Any\n\nfrom pydantic import BaseModel, RootModel\nfrom pydantic.networks import HttpUrl\nfrom pytauri import Commands\nfrom pytauri.ipc import JavaScriptChannelId, WebviewWindow\n\ncommands = Commands()\n\nProgress = RootModel[int]\n\n\nclass Download(BaseModel):\n    url: HttpUrl\n    channel: JavaScriptChannelId[Progress]\n\n\nbackground_tasks: set[Task[Any]] = set()\n\n\n@commands.command()\nasync def download(body: Download, webview_window: WebviewWindow) -&gt; None:\n    channel = body.channel.channel_on(webview_window.as_ref_webview())\n\n    async def task():\n        progress = Progress(0)\n        while progress.root &lt;= 100:\n            channel.send_model(progress)\n            await sleep(0.1)\n            progress.root += 1\n\n    t = create_task(task())\n    background_tasks.add(t)\n    t.add_done_callback(background_tasks.discard)\n\n\n# Or you can use it as `body` model directly\n@commands.command()\nasync def my_command(body: JavaScriptChannelId) -&gt; bytes: ...\n</code></pre> <p>Methods:</p> Name Description <code>from_str</code> <p>See pytauri.ffi.ipc.JavaScriptChannelId.from_str.</p> <code>channel_on</code> <p>See pytauri.ffi.ipc.JavaScriptChannelId.channel_on.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.JavaScriptChannelId.from_str","title":"from_str  <code>classmethod</code>","text":"<pre><code>from_str(value: str) -&gt; Self\n</code></pre> <p>See pytauri.ffi.ipc.JavaScriptChannelId.from_str.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@classmethod\ndef from_str(cls, value: str, /) -&gt; Self:\n    \"\"\"See [pytauri.ffi.ipc.JavaScriptChannelId.from_str][].\"\"\"\n    ffi_js_channel_id = _FFIJavaScriptChannelId.from_str(value)\n    return cls(ffi_js_channel_id)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.JavaScriptChannelId.channel_on","title":"channel_on","text":"<pre><code>channel_on(webview: Webview) -&gt; Channel[_ModelTypeVar]\n</code></pre> <p>See pytauri.ffi.ipc.JavaScriptChannelId.channel_on.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def channel_on(self, webview: Webview, /) -&gt; \"Channel[_ModelTypeVar]\":\n    \"\"\"See [pytauri.ffi.ipc.JavaScriptChannelId.channel_on][].\"\"\"\n    ffi_channel = self.root.channel_on(webview)\n    return Channel(ffi_channel)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Channel","title":"Channel","text":"<pre><code>Channel(ffi_channel: Channel)\n</code></pre> <p>               Bases: <code>Generic[_ModelTypeVar]</code></p> <p>This class is a wrapper around pytauri.ffi.ipc.Channel.</p> <p>It adds the following methods:</p> <ul> <li>send_model</li> </ul>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Channel--examples","title":"Examples","text":"<p>See JavaScriptChannelId</p> <p>Methods:</p> Name Description <code>id</code> <p>See pytauri.ffi.ipc.Channel.id.</p> <code>send</code> <p>See pytauri.ffi.ipc.Channel.send.</p> <code>send_model</code> <p>Equivalent to <code>self.send(model.model_dump_json())</code>.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self, ffi_channel: _FFIChannel, /):  # noqa: D107\n    self._ffi_channel = ffi_channel\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Channel.id","title":"id","text":"<pre><code>id() -&gt; int\n</code></pre> <p>See pytauri.ffi.ipc.Channel.id.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def id(self, /) -&gt; int:\n    \"\"\"See [pytauri.ffi.ipc.Channel.id][].\"\"\"\n    return self._ffi_channel.id()\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Channel.send","title":"send","text":"<pre><code>send(data: _InvokeResponseBody) -&gt; None\n</code></pre> <p>See pytauri.ffi.ipc.Channel.send.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def send(self, data: _InvokeResponseBody, /) -&gt; None:\n    \"\"\"See [pytauri.ffi.ipc.Channel.send][].\"\"\"\n    self._ffi_channel.send(data)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Channel.send_model","title":"send_model","text":"<pre><code>send_model(model: _ModelTypeVar) -&gt; None\n</code></pre> <p>Equivalent to <code>self.send(model.model_dump_json())</code>.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def send_model(self, model: _ModelTypeVar, /) -&gt; None:\n    \"\"\"Equivalent to `self.send(model.model_dump_json())`.\"\"\"\n    self.send(model.model_dump_json())\n</code></pre>"},{"location":"reference/py/pytauri/menu/","title":"menu","text":""},{"location":"reference/py/pytauri/menu/#pytauri.menu","title":"pytauri.menu","text":"<p>tauri::menu</p> <p>Classes:</p> Name Description <code>AboutMetadata</code> <p>tauri::menu::AboutMetadata</p> <code>CheckMenuItem</code> <p>tauri::menu::CheckMenuItem</p> <code>ContextMenu</code> <p>tauri::menu::ContextMenu</p> <code>IconMenuItem</code> <p>tauri::menu::IconMenuItem</p> <code>Menu</code> <p>tauri::menu::Menu</p> <code>MenuItem</code> <p>tauri::menu::MenuItem</p> <code>NativeIcon</code> <p>tauri::menu::NativeIcon</p> <code>PredefinedMenuItem</code> <p>tauri::menu::PredefinedMenuItem</p> <code>Submenu</code> <p>tauri::menu::Submenu</p> <p>Attributes:</p> Name Type Description <code>HELP_SUBMENU_ID</code> <code>LiteralString</code> <p>tauri::menu::HELP_SUBMENU_ID</p> <code>WINDOW_SUBMENU_ID</code> <code>LiteralString</code> <p>tauri::menu::WINDOW_SUBMENU_ID</p> <code>ImplContextMenu</code> <code>MenuEvent</code> <p>tauri::menu::MenuEvent</p> <code>MenuID</code> <p>tauri::menu::MenuID</p> <code>MenuItemKind</code> <p>tauri::menu::MenuItemKind</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.HELP_SUBMENU_ID","title":"HELP_SUBMENU_ID  <code>module-attribute</code>","text":"<pre><code>HELP_SUBMENU_ID: LiteralString\n</code></pre> <p>tauri::menu::HELP_SUBMENU_ID</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.WINDOW_SUBMENU_ID","title":"WINDOW_SUBMENU_ID  <code>module-attribute</code>","text":"<pre><code>WINDOW_SUBMENU_ID: LiteralString\n</code></pre> <p>tauri::menu::WINDOW_SUBMENU_ID</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.ImplContextMenu","title":"ImplContextMenu  <code>module-attribute</code>","text":"<pre><code>ImplContextMenu = TypeAliasType('ImplContextMenu', Union[Menu, Submenu])\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuEvent","title":"MenuEvent  <code>module-attribute</code>","text":"<pre><code>MenuEvent = TypeAliasType('MenuEvent', MenuID)\n</code></pre> <p>tauri::menu::MenuEvent</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuID","title":"MenuID  <code>module-attribute</code>","text":"<pre><code>MenuID = TypeAliasType('MenuID', str)\n</code></pre> <p>tauri::menu::MenuID</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItemKind","title":"MenuItemKind  <code>module-attribute</code>","text":"<pre><code>MenuItemKind = TypeAliasType('MenuItemKind', Union[MenuItem, Submenu, PredefinedMenuItem, CheckMenuItem, IconMenuItem])\n</code></pre> <p>tauri::menu::MenuItemKind</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['HELP_SUBMENU_ID', 'WINDOW_SUBMENU_ID', 'AboutMetadata', 'CheckMenuItem', 'ContextMenu', 'IconMenuItem', 'ImplContextMenu', 'Menu', 'MenuEvent', 'MenuID', 'MenuItem', 'MenuItemKind', 'NativeIcon', 'PredefinedMenuItem', 'Submenu']\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.AboutMetadata","title":"AboutMetadata","text":"<p>tauri::menu::AboutMetadata</p> <p>Methods:</p> Name Description <code>__new__</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.AboutMetadata.__new__","title":"__new__","text":"<pre><code>__new__(*, name: Optional[str] = None, version: Optional[str] = None, short_version: Optional[str] = None, authors: Optional[Sequence[str]] = None, comments: Optional[str] = None, copyright: Optional[str] = None, license: Optional[str] = None, website: Optional[str] = None, website_label: Optional[str] = None, credits: Optional[str] = None, icon: Optional[Image] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    name: Optional[str] = None,\n    version: Optional[str] = None,\n    short_version: Optional[str] = None,\n    authors: Optional[Sequence[str]] = None,\n    comments: Optional[str] = None,\n    copyright: Optional[str] = None,  # noqa: A002\n    license: Optional[str] = None,  # noqa: A002\n    website: Optional[str] = None,\n    website_label: Optional[str] = None,\n    credits: Optional[str] = None,  # noqa: A002\n    icon: Optional[\"Image\"] = None,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem","title":"CheckMenuItem","text":"<p>tauri::menu::CheckMenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code> <code>is_checked</code> <code>set_checked</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, checked: bool, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    checked: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, checked: bool, accelerator: Optional[str] = None) -&gt; CheckMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    checked: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"CheckMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.is_checked","title":"is_checked","text":"<pre><code>is_checked() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_checked(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.set_checked","title":"set_checked","text":"<pre><code>set_checked(checked: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_checked(self, checked: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.ContextMenu","title":"ContextMenu","text":"<p>tauri::menu::ContextMenu</p> <p>Methods:</p> Name Description <code>popup</code> <code>popup_at</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.ContextMenu.popup","title":"popup  <code>staticmethod</code>","text":"<pre><code>popup(slf: ImplContextMenu, window: Window) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef popup(slf: \"ImplContextMenu\", window: Window, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.ContextMenu.popup_at","title":"popup_at  <code>staticmethod</code>","text":"<pre><code>popup_at(slf: ImplContextMenu, window: Window, position: PositionType) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef popup_at(\n    slf: \"ImplContextMenu\", window: Window, position: PositionType, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem","title":"IconMenuItem","text":"<p>tauri::menu::IconMenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_native_icon</code> <code>with_id_and_native_icon</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code> <code>set_icon</code> <code>set_native_icon</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, icon: Optional[Image] = None, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    icon: Optional[\"Image\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, icon: Optional[Image] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    icon: Optional[\"Image\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.with_native_icon","title":"with_native_icon  <code>staticmethod</code>","text":"<pre><code>with_native_icon(manager: ImplManager, text: str, enabled: bool, native_icon: Optional[NativeIcon] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_native_icon(\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    native_icon: Optional[\"NativeIcon\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.with_id_and_native_icon","title":"with_id_and_native_icon  <code>staticmethod</code>","text":"<pre><code>with_id_and_native_icon(manager: ImplManager, id: MenuID, text: str, enabled: bool, native_icon: Optional[NativeIcon] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_native_icon(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    native_icon: Optional[\"NativeIcon\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Optional[Image]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_icon(self, icon: Optional[\"Image\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.set_native_icon","title":"set_native_icon","text":"<pre><code>set_native_icon(native_icon: Optional[NativeIcon]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_native_icon(self, native_icon: Optional[\"NativeIcon\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu","title":"Menu","text":"<p>tauri::menu::Menu</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_items</code> <code>with_id_and_items</code> <code>default</code> <code>app_handle</code> <code>id</code> <code>append</code> <code>append_items</code> <code>prepend</code> <code>prepend_items</code> <code>insert</code> <code>insert_items</code> <code>remove</code> <code>remove_at</code> <code>get</code> <code>items</code> <code>set_as_app_menu</code> <code>set_as_window_menu</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(cls, manager: ImplManager, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(manager: ImplManager, id: MenuID, /) -&gt; \"Menu\": ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.with_items","title":"with_items  <code>staticmethod</code>","text":"<pre><code>with_items(manager: ImplManager, items: Sequence[MenuItemKind]) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_items(\n    manager: ImplManager, items: Sequence[\"MenuItemKind\"], /\n) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.with_id_and_items","title":"with_id_and_items  <code>staticmethod</code>","text":"<pre><code>with_id_and_items(manager: ImplManager, id: MenuID, items: Sequence[MenuItemKind]) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_items(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.default","title":"default  <code>staticmethod</code>","text":"<pre><code>default(app_handle: AppHandle) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef default(app_handle: AppHandle, /) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.append","title":"append","text":"<pre><code>append(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.append_items","title":"append_items","text":"<pre><code>append_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.prepend","title":"prepend","text":"<pre><code>prepend(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.prepend_items","title":"prepend_items","text":"<pre><code>prepend_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.insert","title":"insert","text":"<pre><code>insert(item: MenuItemKind, position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert(self, item: \"MenuItemKind\", position: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.insert_items","title":"insert_items","text":"<pre><code>insert_items(items: Sequence[MenuItemKind], position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert_items(\n    self, items: Sequence[\"MenuItemKind\"], position: int, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.remove","title":"remove","text":"<pre><code>remove(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.remove_at","title":"remove_at","text":"<pre><code>remove_at(position: int) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove_at(self, position: int, /) -&gt; Optional[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.get","title":"get","text":"<pre><code>get(id: MenuID) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def get(self, id: MenuID, /) -&gt; Optional[\"MenuItemKind\"]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.items","title":"items","text":"<pre><code>items() -&gt; list[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def items(self, /) -&gt; list[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.set_as_app_menu","title":"set_as_app_menu","text":"<pre><code>set_as_app_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_as_app_menu(self, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.set_as_window_menu","title":"set_as_window_menu","text":"<pre><code>set_as_window_menu(window: Window) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_as_window_menu(self, window: Window, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem","title":"MenuItem","text":"<p>tauri::menu::MenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, accelerator: Optional[str] = None) -&gt; MenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"MenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon","title":"NativeIcon","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::menu::NativeIcon</p> <p>Warning</p> <p>This is actually a <code>Class</code> disguised as an <code>Enum</code>. The order of fields is not guaranteed. See also: https://pyo3.rs/v0.23.4/class.html#pyclass-enums.</p> <p>Attributes:</p> Name Type Description <code>Add</code> <code>Advanced</code> <code>Bluetooth</code> <code>Bookmarks</code> <code>Caution</code> <code>ColorPanel</code> <code>ColumnView</code> <code>Computer</code> <code>EnterFullScreen</code> <code>Everyone</code> <code>ExitFullScreen</code> <code>FlowView</code> <code>Folder</code> <code>FolderBurnable</code> <code>FolderSmart</code> <code>FollowLinkFreestanding</code> <code>FontPanel</code> <code>GoLeft</code> <code>GoRight</code> <code>Home</code> <code>IChatTheater</code> <code>IconView</code> <code>Info</code> <code>InvalidDataFreestanding</code> <code>LeftFacingTriangle</code> <code>ListView</code> <code>LockLocked</code> <code>LockUnlocked</code> <code>MenuMixedState</code> <code>MenuOnState</code> <code>MobileMe</code> <code>MultipleDocuments</code> <code>Network</code> <code>Path</code> <code>PreferencesGeneral</code> <code>QuickLook</code> <code>RefreshFreestanding</code> <code>Refresh</code> <code>Remove</code> <code>RevealFreestanding</code> <code>RightFacingTriangle</code> <code>Share</code> <code>Slideshow</code> <code>SmartBadge</code> <code>StatusAvailable</code> <code>StatusNone</code> <code>StatusPartiallyAvailable</code> <code>StatusUnavailable</code> <code>StopProgressFreestanding</code> <code>StopProgress</code> <code>TrashEmpty</code> <code>TrashFull</code> <code>User</code> <code>UserAccounts</code> <code>UserGroup</code> <code>UserGuest</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Add","title":"Add  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Add = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Advanced","title":"Advanced  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Advanced = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Bluetooth","title":"Bluetooth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Bluetooth = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Bookmarks","title":"Bookmarks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Bookmarks = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Caution","title":"Caution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Caution = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.ColorPanel","title":"ColorPanel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ColorPanel = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.ColumnView","title":"ColumnView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ColumnView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Computer","title":"Computer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Computer = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.EnterFullScreen","title":"EnterFullScreen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EnterFullScreen = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Everyone","title":"Everyone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Everyone = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.ExitFullScreen","title":"ExitFullScreen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ExitFullScreen = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.FlowView","title":"FlowView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FlowView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Folder","title":"Folder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Folder = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.FolderBurnable","title":"FolderBurnable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FolderBurnable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.FolderSmart","title":"FolderSmart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FolderSmart = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.FollowLinkFreestanding","title":"FollowLinkFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FollowLinkFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.FontPanel","title":"FontPanel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FontPanel = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.GoLeft","title":"GoLeft  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GoLeft = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.GoRight","title":"GoRight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GoRight = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Home","title":"Home  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Home = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.IChatTheater","title":"IChatTheater  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IChatTheater = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.IconView","title":"IconView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IconView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Info","title":"Info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Info = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.InvalidDataFreestanding","title":"InvalidDataFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>InvalidDataFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.LeftFacingTriangle","title":"LeftFacingTriangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LeftFacingTriangle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.ListView","title":"ListView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ListView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.LockLocked","title":"LockLocked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LockLocked = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.LockUnlocked","title":"LockUnlocked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LockUnlocked = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.MenuMixedState","title":"MenuMixedState  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MenuMixedState = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.MenuOnState","title":"MenuOnState  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MenuOnState = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.MobileMe","title":"MobileMe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MobileMe = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.MultipleDocuments","title":"MultipleDocuments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MultipleDocuments = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Network","title":"Network  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Network = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Path","title":"Path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Path = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.PreferencesGeneral","title":"PreferencesGeneral  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PreferencesGeneral = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.QuickLook","title":"QuickLook  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QuickLook = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.RefreshFreestanding","title":"RefreshFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RefreshFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Refresh","title":"Refresh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Refresh = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Remove","title":"Remove  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Remove = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.RevealFreestanding","title":"RevealFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RevealFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.RightFacingTriangle","title":"RightFacingTriangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RightFacingTriangle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Share","title":"Share  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Share = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Slideshow","title":"Slideshow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Slideshow = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.SmartBadge","title":"SmartBadge  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SmartBadge = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StatusAvailable","title":"StatusAvailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusAvailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StatusNone","title":"StatusNone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusNone = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StatusPartiallyAvailable","title":"StatusPartiallyAvailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusPartiallyAvailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StatusUnavailable","title":"StatusUnavailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusUnavailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StopProgressFreestanding","title":"StopProgressFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StopProgressFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StopProgress","title":"StopProgress  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StopProgress = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.TrashEmpty","title":"TrashEmpty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TrashEmpty = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.TrashFull","title":"TrashFull  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TrashFull = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.User","title":"User  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>User = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.UserAccounts","title":"UserAccounts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserAccounts = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.UserGroup","title":"UserGroup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserGroup = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.UserGuest","title":"UserGuest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserGuest = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem","title":"PredefinedMenuItem","text":"<p>tauri::menu::PredefinedMenuItem</p> <p>Methods:</p> Name Description <code>separator</code> <code>copy</code> <code>cut</code> <code>paste</code> <code>select_all</code> <code>undo</code> <code>redo</code> <code>minimize</code> <code>maximize</code> <code>fullscreen</code> <code>hide</code> <code>hide_others</code> <code>show_all</code> <code>close_window</code> <code>quit</code> <code>about</code> <code>services</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.separator","title":"separator  <code>staticmethod</code>","text":"<pre><code>separator(manager: ImplManager) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef separator(manager: ImplManager, /) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.copy","title":"copy  <code>staticmethod</code>","text":"<pre><code>copy(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef copy(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.cut","title":"cut  <code>staticmethod</code>","text":"<pre><code>cut(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef cut(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.paste","title":"paste  <code>staticmethod</code>","text":"<pre><code>paste(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef paste(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.select_all","title":"select_all  <code>staticmethod</code>","text":"<pre><code>select_all(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef select_all(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.undo","title":"undo  <code>staticmethod</code>","text":"<pre><code>undo(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef undo(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.redo","title":"redo  <code>staticmethod</code>","text":"<pre><code>redo(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef redo(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.minimize","title":"minimize  <code>staticmethod</code>","text":"<pre><code>minimize(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef minimize(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.maximize","title":"maximize  <code>staticmethod</code>","text":"<pre><code>maximize(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef maximize(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.fullscreen","title":"fullscreen  <code>staticmethod</code>","text":"<pre><code>fullscreen(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef fullscreen(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.hide","title":"hide  <code>staticmethod</code>","text":"<pre><code>hide(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef hide(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.hide_others","title":"hide_others  <code>staticmethod</code>","text":"<pre><code>hide_others(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef hide_others(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.show_all","title":"show_all  <code>staticmethod</code>","text":"<pre><code>show_all(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef show_all(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.close_window","title":"close_window  <code>staticmethod</code>","text":"<pre><code>close_window(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef close_window(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.quit","title":"quit  <code>staticmethod</code>","text":"<pre><code>quit(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef quit(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.about","title":"about  <code>staticmethod</code>","text":"<pre><code>about(manager: ImplManager, text: Optional[str] = None, metadata: Optional[AboutMetadata] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef about(\n    manager: ImplManager,\n    text: Optional[str] = None,\n    metadata: Optional[\"AboutMetadata\"] = None,\n    /,\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.services","title":"services  <code>staticmethod</code>","text":"<pre><code>services(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef services(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu","title":"Submenu","text":"<p>tauri::menu::Submenu</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_items</code> <code>with_id_and_items</code> <code>app_handle</code> <code>id</code> <code>append</code> <code>append_items</code> <code>prepend</code> <code>prepend_items</code> <code>insert</code> <code>insert_items</code> <code>remove</code> <code>remove_at</code> <code>get</code> <code>items</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(cls, manager: ImplManager, text: str, enabled: bool, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.with_items","title":"with_items  <code>staticmethod</code>","text":"<pre><code>with_items(manager: ImplManager, text: str, enabled: bool, items: Sequence[MenuItemKind]) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_items(\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.with_id_and_items","title":"with_id_and_items  <code>staticmethod</code>","text":"<pre><code>with_id_and_items(manager: ImplManager, id: MenuID, text: str, enabled: bool, items: Sequence[MenuItemKind]) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_items(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.append","title":"append","text":"<pre><code>append(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.append_items","title":"append_items","text":"<pre><code>append_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.prepend","title":"prepend","text":"<pre><code>prepend(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.prepend_items","title":"prepend_items","text":"<pre><code>prepend_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.insert","title":"insert","text":"<pre><code>insert(item: MenuItemKind, position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert(self, item: \"MenuItemKind\", position: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.insert_items","title":"insert_items","text":"<pre><code>insert_items(items: Sequence[MenuItemKind], position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert_items(\n    self, items: Sequence[\"MenuItemKind\"], position: int, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.remove","title":"remove","text":"<pre><code>remove(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.remove_at","title":"remove_at","text":"<pre><code>remove_at(position: int) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove_at(self, position: int, /) -&gt; Optional[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.get","title":"get","text":"<pre><code>get(id: MenuID) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def get(self, id: MenuID, /) -&gt; Optional[\"MenuItemKind\"]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.items","title":"items","text":"<pre><code>items() -&gt; list[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def items(self, /) -&gt; list[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/","title":"path","text":""},{"location":"reference/py/pytauri/path/#pytauri.path","title":"pytauri.path","text":"<p>tauri::path</p> <p>Classes:</p> Name Description <code>PathResolver</code> <p>tauri::path::PathResolver</p>"},{"location":"reference/py/pytauri/path/#pytauri.path.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['PathResolver']\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver","title":"PathResolver","text":"<p>tauri::path::PathResolver</p>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver--examples","title":"Examples","text":"<pre><code>from pathlib import Path\nfrom typing import Union\n\nfrom pytauri import App, AppHandle, Manager\nfrom pytauri.path import PathResolver\nfrom pytauri.webview import WebviewWindow\n\n\ndef get_resource_dir(manager: Union[App, AppHandle, WebviewWindow]) -&gt; Path:\n    path_resolver: PathResolver = Manager.path(manager)\n    return path_resolver.resource_dir()\n</code></pre> <p>Methods:</p> Name Description <code>audio_dir</code> <code>cache_dir</code> <code>config_dir</code> <code>data_dir</code> <code>local_data_dir</code> <code>desktop_dir</code> <code>document_dir</code> <code>download_dir</code> <code>executable_dir</code> <code>font_dir</code> <code>home_dir</code> <code>picture_dir</code> <code>public_dir</code> <code>runtime_dir</code> <code>template_dir</code> <code>video_dir</code> <code>resource_dir</code> <code>app_config_dir</code> <code>app_data_dir</code> <code>app_local_data_dir</code> <code>app_cache_dir</code> <code>app_log_dir</code> <code>temp_dir</code>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.audio_dir","title":"audio_dir","text":"<pre><code>audio_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def audio_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.cache_dir","title":"cache_dir","text":"<pre><code>cache_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def cache_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.config_dir","title":"config_dir","text":"<pre><code>config_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def config_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.data_dir","title":"data_dir","text":"<pre><code>data_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def data_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.local_data_dir","title":"local_data_dir","text":"<pre><code>local_data_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def local_data_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.desktop_dir","title":"desktop_dir","text":"<pre><code>desktop_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def desktop_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.document_dir","title":"document_dir","text":"<pre><code>document_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def document_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.download_dir","title":"download_dir","text":"<pre><code>download_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def download_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.executable_dir","title":"executable_dir","text":"<pre><code>executable_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def executable_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.font_dir","title":"font_dir","text":"<pre><code>font_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def font_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.home_dir","title":"home_dir","text":"<pre><code>home_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def home_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.picture_dir","title":"picture_dir","text":"<pre><code>picture_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def picture_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.public_dir","title":"public_dir","text":"<pre><code>public_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def public_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.runtime_dir","title":"runtime_dir","text":"<pre><code>runtime_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def runtime_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.template_dir","title":"template_dir","text":"<pre><code>template_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def template_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.video_dir","title":"video_dir","text":"<pre><code>video_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def video_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.resource_dir","title":"resource_dir","text":"<pre><code>resource_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def resource_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.app_config_dir","title":"app_config_dir","text":"<pre><code>app_config_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def app_config_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.app_data_dir","title":"app_data_dir","text":"<pre><code>app_data_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def app_data_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.app_local_data_dir","title":"app_local_data_dir","text":"<pre><code>app_local_data_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def app_local_data_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.app_cache_dir","title":"app_cache_dir","text":"<pre><code>app_cache_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def app_cache_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.app_log_dir","title":"app_log_dir","text":"<pre><code>app_log_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def app_log_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/path/#pytauri.path.PathResolver.temp_dir","title":"temp_dir","text":"<pre><code>temp_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def temp_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/","title":"tray","text":""},{"location":"reference/py/pytauri/tray/#pytauri.tray","title":"pytauri.tray","text":"<p>tauri::tray</p> <p>Classes:</p> Name Description <code>MouseButton</code> <p>tauri::tray::MouseButton</p> <code>MouseButtonState</code> <p>tauri::tray::MouseButtonState</p> <code>TrayIcon</code> <p>tauri::tray::TrayIcon</p> <code>TrayIconEvent</code> <p>tauri::tray::TrayIconEvent</p> <p>Attributes:</p> Name Type Description <code>TrayIconEventType</code> <p>See TrayIconEvent for details.</p> <code>TrayIconId</code> <p>tauri::tray::TrayIconId</p>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEventType","title":"TrayIconEventType  <code>module-attribute</code>","text":"<pre><code>TrayIconEventType = TypeAliasType('TrayIconEventType', Union[Click, DoubleClick, Enter, Move, Leave, _NonExhaustive])\n</code></pre> <p>See TrayIconEvent for details.</p>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconId","title":"TrayIconId  <code>module-attribute</code>","text":"<pre><code>TrayIconId = TypeAliasType('TrayIconId', str)\n</code></pre> <p>tauri::tray::TrayIconId</p>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['MouseButton', 'MouseButtonState', 'TrayIcon', 'TrayIconEvent', 'TrayIconEventType', 'TrayIconId']\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButton","title":"MouseButton","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::tray::MouseButton</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Left</code> <code>Right</code> <code>Middle</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButton.Left","title":"Left  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Left = auto()\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButton.Right","title":"Right  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Right = auto()\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButton.Middle","title":"Middle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Middle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButtonState","title":"MouseButtonState","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::tray::MouseButtonState</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Up</code> <code>Down</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButtonState.Up","title":"Up  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Up = auto()\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButtonState.Down","title":"Down  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Down = auto()\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon","title":"TrayIcon","text":"<p>tauri::tray::TrayIcon</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>on_menu_event</code> <p>This is an alias for pytauri.ffi.AppHandle.on_menu_event.</p> <code>on_tray_icon_event</code> <p>Set a handler for this tray icon events.</p> <code>id</code> <code>set_icon</code> <code>set_menu</code> <code>set_tooltip</code> <code>set_title</code> <code>set_visible</code> <code>set_temp_dir_path</code> <code>set_icon_as_template</code> <code>set_show_menu_on_left_click</code> <code>rect</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def __new__(cls, manager: ImplManager, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: TrayIconId) -&gt; TrayIcon\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>@staticmethod\ndef with_id(manager: ImplManager, id: TrayIconId, /) -&gt; \"TrayIcon\": ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[AppHandle, MenuEvent], None]) -&gt; None\n</code></pre> <p>This is an alias for pytauri.ffi.AppHandle.on_menu_event.</p> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[AppHandle, MenuEvent], None], /\n) -&gt; None:\n    \"\"\"This is an alias for [pytauri.ffi.AppHandle.on_menu_event][].\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.on_tray_icon_event","title":"on_tray_icon_event","text":"<pre><code>on_tray_icon_event(handler: Callable[[Self, TrayIconEventType], None]) -&gt; None\n</code></pre> <p>Set a handler for this tray icon events.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def on_tray_icon_event(\n    self, handler: Callable[[Self, \"TrayIconEventType\"], None], /\n) -&gt; None:\n    \"\"\"Set a handler for this tray icon events.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.id","title":"id","text":"<pre><code>id() -&gt; TrayIconId\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def id(self, /) -&gt; TrayIconId: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Optional[Image]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_icon(self, icon: Optional[Image], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Optional[ImplContextMenu]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_menu(self, menu: Optional[ImplContextMenu], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_tooltip","title":"set_tooltip","text":"<pre><code>set_tooltip(tooltip: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_tooltip(self, tooltip: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_title","title":"set_title","text":"<pre><code>set_title(title: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_title(self, title: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_visible","title":"set_visible","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_visible(self, visible: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_temp_dir_path","title":"set_temp_dir_path","text":"<pre><code>set_temp_dir_path(path: Optional[Pyo3Path]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_temp_dir_path(self, path: Optional[Pyo3Path], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_icon_as_template","title":"set_icon_as_template","text":"<pre><code>set_icon_as_template(is_template: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_icon_as_template(self, is_template: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_show_menu_on_left_click","title":"set_show_menu_on_left_click","text":"<pre><code>set_show_menu_on_left_click(enable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_show_menu_on_left_click(self, enable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.rect","title":"rect","text":"<pre><code>rect() -&gt; Optional[Rect]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def rect(self, /) -&gt; Optional[Rect]: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent","title":"TrayIconEvent","text":"<p>tauri::tray::TrayIconEvent</p> <p>Classes:</p> Name Description <code>Click</code> <p>tauri::tray::TrayIconEvent::Click</p> <code>DoubleClick</code> <p>tauri::tray::TrayIconEvent::DoubleClick</p> <code>Enter</code> <p>tauri::tray::TrayIconEvent::Enter</p> <code>Move</code> <p>tauri::tray::TrayIconEvent::Move</p> <code>Leave</code> <p>tauri::tray::TrayIconEvent::Leave</p>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click","title":"Click","text":"<p>tauri::tray::TrayIconEvent::Click</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PhysicalPositionF64</code> <code>rect</code> <code>Rect</code> <code>button</code> <code>MouseButton</code> <code>button_state</code> <code>MouseButtonState</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click.position","title":"position  <code>property</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click.button","title":"button  <code>property</code>","text":"<pre><code>button: MouseButton\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click.button_state","title":"button_state  <code>property</code>","text":"<pre><code>button_state: MouseButtonState\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.DoubleClick","title":"DoubleClick","text":"<p>tauri::tray::TrayIconEvent::DoubleClick</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PhysicalPositionF64</code> <code>rect</code> <code>Rect</code> <code>button</code> <code>MouseButton</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.DoubleClick.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.DoubleClick.position","title":"position  <code>property</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.DoubleClick.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.DoubleClick.button","title":"button  <code>property</code>","text":"<pre><code>button: MouseButton\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Enter","title":"Enter","text":"<p>tauri::tray::TrayIconEvent::Enter</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Enter.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Enter.position","title":"position  <code>property</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Enter.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Move","title":"Move","text":"<p>tauri::tray::TrayIconEvent::Move</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Move.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Move.position","title":"position  <code>property</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Move.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Leave","title":"Leave","text":"<p>tauri::tray::TrayIconEvent::Leave</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Leave.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Leave.position","title":"position  <code>property</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Leave.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/webview/","title":"webview","text":""},{"location":"reference/py/pytauri/webview/#pytauri.webview","title":"pytauri.webview","text":"<p>tauri::webview</p> <p>Classes:</p> Name Description <code>Webview</code> <p>tauri::webview::Webview</p> <code>WebviewWindow</code> <p>tauri::webview::WebviewWindow</p>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Webview', 'WebviewWindow']\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.Webview","title":"Webview","text":"<p>tauri::webview::Webview</p> <p>Methods:</p> Name Description <code>window</code>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.Webview.window","title":"window","text":"<pre><code>window() -&gt; Window\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def window(self) -&gt; \"Window\": ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow","title":"WebviewWindow","text":"<p>tauri::webview::WebviewWindow</p> <p>Methods:</p> Name Description <code>run_on_main_thread</code> <p>Runs the given closure on the main thread.</p> <code>label</code> <code>on_window_event</code> <p>Registers a window event listener.</p> <code>on_menu_event</code> <p>Registers a global menu event listener.</p> <code>menu</code> <code>set_menu</code> <code>remove_menu</code> <code>hide_menu</code> <code>show_menu</code> <code>is_menu_visible</code> <code>popup_menu</code> <code>popup_menu_at</code> <code>is_fullscreen</code> <code>is_minimized</code> <code>is_maximized</code> <code>is_focused</code> <code>is_decorated</code> <code>is_resizable</code> <code>is_enabled</code> <code>is_maximizable</code> <code>is_minimizable</code> <code>is_closable</code> <code>is_visible</code> <code>title</code> <code>theme</code> <code>center</code> <code>set_resizable</code> <code>set_enabled</code> <code>set_maximizable</code> <code>set_minimizable</code> <code>set_closable</code> <code>set_title</code> <code>maximize</code> <code>unmaximize</code> <code>minimize</code> <code>unminimize</code> <code>show</code> <code>hide</code> <code>close</code> <code>destroy</code> <code>set_decorations</code> <code>set_shadow</code> <code>set_always_on_bottom</code> <code>set_always_on_top</code> <code>set_visible_on_all_workspaces</code> <code>set_content_protected</code> <code>set_fullscreen</code> <code>set_focus</code> <code>set_icon</code> <code>set_skip_taskbar</code> <code>set_cursor_grab</code> <code>set_cursor_visible</code> <code>set_ignore_cursor_events</code> <code>start_dragging</code> <code>set_badge_count</code> <code>set_theme</code> <code>print</code> <code>url</code> <code>navigate</code> <code>eval</code> <code>set_zoom</code> <code>clear_all_browsing_data</code> <code>as_ref_webview</code> <code>on_webview_event</code> <p>Registers a window event listener.</p>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.run_on_main_thread","title":"run_on_main_thread","text":"<pre><code>run_on_main_thread(handler: Callable[[], object]) -&gt; None\n</code></pre> <p>Runs the given closure on the main thread.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def run_on_main_thread(self, handler: Callable[[], object], /) -&gt; None:\n    \"\"\"Runs the given closure on the main thread.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.label","title":"label","text":"<pre><code>label() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def label(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.on_window_event","title":"on_window_event","text":"<pre><code>on_window_event(handler: Callable[[WindowEventType], None]) -&gt; None\n</code></pre> <p>Registers a window event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def on_window_event(\n    self, handler: Callable[[WindowEventType], None], /\n) -&gt; None:\n    \"\"\"Registers a window event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[Self, MenuEvent], None]) -&gt; None\n</code></pre> <p>Registers a global menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[\"Self\", \"MenuEvent\"], None], /\n) -&gt; None:\n    \"\"\"Registers a global menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.menu","title":"menu","text":"<pre><code>menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Menu) -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_menu(self, menu: Menu, /) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.remove_menu","title":"remove_menu","text":"<pre><code>remove_menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def remove_menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.hide_menu","title":"hide_menu","text":"<pre><code>hide_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def hide_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.show_menu","title":"show_menu","text":"<pre><code>show_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def show_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_menu_visible","title":"is_menu_visible","text":"<pre><code>is_menu_visible() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_menu_visible(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.popup_menu","title":"popup_menu","text":"<pre><code>popup_menu(menu: ImplContextMenu) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def popup_menu(self, menu: ImplContextMenu, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.popup_menu_at","title":"popup_menu_at","text":"<pre><code>popup_menu_at(menu: ImplContextMenu, position: PositionType) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def popup_menu_at(\n    self, menu: ImplContextMenu, position: PositionType, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_fullscreen","title":"is_fullscreen","text":"<pre><code>is_fullscreen() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_fullscreen(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_minimized","title":"is_minimized","text":"<pre><code>is_minimized() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_minimized(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_maximized","title":"is_maximized","text":"<pre><code>is_maximized() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_maximized(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_focused","title":"is_focused","text":"<pre><code>is_focused() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_focused(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_decorated","title":"is_decorated","text":"<pre><code>is_decorated() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_decorated(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_resizable","title":"is_resizable","text":"<pre><code>is_resizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_resizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_enabled(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_maximizable","title":"is_maximizable","text":"<pre><code>is_maximizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_maximizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_minimizable","title":"is_minimizable","text":"<pre><code>is_minimizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_minimizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_closable","title":"is_closable","text":"<pre><code>is_closable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_closable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_visible","title":"is_visible","text":"<pre><code>is_visible() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_visible(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.title","title":"title","text":"<pre><code>title() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def title(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.theme","title":"theme","text":"<pre><code>theme() -&gt; Theme\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def theme(self) -&gt; Theme: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.center","title":"center","text":"<pre><code>center() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def center(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_resizable","title":"set_resizable","text":"<pre><code>set_resizable(resizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_resizable(self, resizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_maximizable","title":"set_maximizable","text":"<pre><code>set_maximizable(maximizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_maximizable(self, maximizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_minimizable","title":"set_minimizable","text":"<pre><code>set_minimizable(minimizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_minimizable(self, minimizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_closable","title":"set_closable","text":"<pre><code>set_closable(closable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_closable(self, closable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_title","title":"set_title","text":"<pre><code>set_title(title: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_title(self, title: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.maximize","title":"maximize","text":"<pre><code>maximize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def maximize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.unmaximize","title":"unmaximize","text":"<pre><code>unmaximize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def unmaximize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.minimize","title":"minimize","text":"<pre><code>minimize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def minimize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.unminimize","title":"unminimize","text":"<pre><code>unminimize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def unminimize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def show(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def hide(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def close(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.destroy","title":"destroy","text":"<pre><code>destroy() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def destroy(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_decorations","title":"set_decorations","text":"<pre><code>set_decorations(decorations: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_decorations(self, decorations: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_shadow","title":"set_shadow","text":"<pre><code>set_shadow(shadow: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_shadow(self, shadow: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_always_on_bottom","title":"set_always_on_bottom","text":"<pre><code>set_always_on_bottom(always_on_bottom: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_always_on_bottom(self, always_on_bottom: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_always_on_top","title":"set_always_on_top","text":"<pre><code>set_always_on_top(always_on_top: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_always_on_top(self, always_on_top: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_visible_on_all_workspaces","title":"set_visible_on_all_workspaces","text":"<pre><code>set_visible_on_all_workspaces(visible_on_all_workspaces: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_visible_on_all_workspaces(\n    self, visible_on_all_workspaces: bool, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_content_protected","title":"set_content_protected","text":"<pre><code>set_content_protected(protected: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_content_protected(self, protected: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_fullscreen","title":"set_fullscreen","text":"<pre><code>set_fullscreen(fullscreen: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_fullscreen(self, fullscreen: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_focus","title":"set_focus","text":"<pre><code>set_focus() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_focus(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Image) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_icon(self, icon: Image, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_skip_taskbar","title":"set_skip_taskbar","text":"<pre><code>set_skip_taskbar(skip: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_skip_taskbar(self, skip: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_cursor_grab","title":"set_cursor_grab","text":"<pre><code>set_cursor_grab(grab: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_cursor_grab(self, grab: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_cursor_visible","title":"set_cursor_visible","text":"<pre><code>set_cursor_visible(visible: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_cursor_visible(self, visible: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_ignore_cursor_events","title":"set_ignore_cursor_events","text":"<pre><code>set_ignore_cursor_events(ignore: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_ignore_cursor_events(self, ignore: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.start_dragging","title":"start_dragging","text":"<pre><code>start_dragging() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def start_dragging(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_badge_count","title":"set_badge_count","text":"<pre><code>set_badge_count(count: Optional[int]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_badge_count(self, count: Optional[int], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_theme","title":"set_theme","text":"<pre><code>set_theme(theme: Optional[Theme]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_theme(self, theme: Optional[Theme], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.print","title":"print","text":"<pre><code>print() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def print(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.url","title":"url","text":"<pre><code>url() -&gt; Url\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def url(self) -&gt; Url: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.navigate","title":"navigate","text":"<pre><code>navigate(url: Url) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def navigate(self, url: Url, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.eval","title":"eval","text":"<pre><code>eval(js: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def eval(self, js: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_zoom","title":"set_zoom","text":"<pre><code>set_zoom(scale_factor: float) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_zoom(self, scale_factor: float, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.clear_all_browsing_data","title":"clear_all_browsing_data","text":"<pre><code>clear_all_browsing_data() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def clear_all_browsing_data(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.as_ref_webview","title":"as_ref_webview","text":"<pre><code>as_ref_webview() -&gt; Webview\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def as_ref_webview(self) -&gt; \"Webview\": ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.on_webview_event","title":"on_webview_event","text":"<pre><code>on_webview_event(handler: Callable[[WebviewEventType], None]) -&gt; None\n</code></pre> <p>Registers a window event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def on_webview_event(\n    self, handler: Callable[[WebviewEventType], None], /\n) -&gt; None:\n    \"\"\"Registers a window event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/window/","title":"window","text":""},{"location":"reference/py/pytauri/window/#pytauri.window","title":"pytauri.window","text":"<p>tauri::window</p> <p>Classes:</p> Name Description <code>Window</code> <p>tauri::Window</p>"},{"location":"reference/py/pytauri/window/#pytauri.window.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Window']\n</code></pre>"},{"location":"reference/py/pytauri/window/#pytauri.window.Window","title":"Window","text":"<p>tauri::Window</p>"},{"location":"reference/py/pytauri/ffi/","title":"ffi","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi","title":"pytauri.ffi","text":"<p>Original FFI interface module.</p> <p>Warning</p> <p>All APIs under this module should not be considered stable. You should use the re-exported APIs under the top-level module.</p> <p>Modules:</p> Name Description <code>image</code> <p>tauri::image</p> <code>ipc</code> <p>tauri::ipc</p> <code>lib</code> <p>tauri::self</p> <code>menu</code> <p>tauri::menu</p> <code>path</code> <p>tauri::path</p> <code>tray</code> <p>tauri::tray</p> <code>webview</code> <p>tauri::webview</p> <code>window</code> <p>tauri::window</p> <p>Classes:</p> Name Description <code>App</code> <p>Tauri::app</p> <code>AppHandle</code> <p>tauri::AppHandle</p> <code>Assets</code> <p>tauri::Assets</p> <code>Builder</code> <p>tauri::Builder</p> <code>BuilderArgs</code> <p>tauri::Builder</p> <code>CloseRequestApi</code> <p>tauri::CloseRequestApi</p> <code>Context</code> <p>tauri::Context</p> <code>DragDropEvent</code> <p>tauri::DragDropEvent</p> <code>Emitter</code> <p>tauri::Emitter</p> <code>Event</code> <p>tauri::Event</p> <code>EventTarget</code> <p>tauri::EventTarget</p> <code>ExitRequestApi</code> <p>tauri::ExitRequestApi</p> <code>Listener</code> <p>tauri::Listener</p> <code>Manager</code> <p>tauri::Manager</p> <code>Position</code> <p>tauri::Position</p> <code>Rect</code> <p>tauri::Rect</p> <code>RunEvent</code> <p>tauri::RunEvent</p> <code>Size</code> <p>tauri::Size</p> <code>Theme</code> <p>tauri::Theme</p> <code>WebviewEvent</code> <p>tauri::WebviewEvent</p> <code>WindowEvent</code> <p>tauri::WindowEvent</p> <p>Functions:</p> Name Description <code>builder_factory</code> <p>A factory function for creating a <code>Builder</code> instance.</p> <code>context_factory</code> <p>A factory function for creating a <code>Context</code> instance.</p> <p>Attributes:</p> Name Type Description <code>EXT_MOD</code> <code>ModuleType</code> <p>The extension module of <code>pytauri</code> app.</p> <code>DragDropEventType</code> <p>See DragDropEvent for details.</p> <code>EventId</code> <p>tauri::EventId</p> <code>EventTargetType</code> <p>See EventTarget for details.</p> <code>ImplEmitter</code> <code>ImplListener</code> <code>ImplManager</code> <code>PositionType</code> <p>See Position for details.</p> <code>RunEventType</code> <p>See RunEvent for details.</p> <code>SizeType</code> <p>See Size for details.</p> <code>Url</code> <p>tauri::Url</p> <code>WebviewEventType</code> <p>See WebviewEvent for details.</p> <code>WindowEventType</code> <p>See WindowEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EXT_MOD","title":"EXT_MOD  <code>module-attribute</code>","text":"<pre><code>EXT_MOD: ModuleType\n</code></pre> <p>The extension module of <code>pytauri</code> app.</p> <p>It will be loaded from <code>entry_points(group=\"pytauri\", name=\"ext_mod\")</code>.</p> <p>Usually you don't need to use it, unless you want to write plugins for <code>pytauri</code>.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEventType","title":"DragDropEventType  <code>module-attribute</code>","text":"<pre><code>DragDropEventType = TypeAliasType('DragDropEventType', Union[Enter, Over, Drop, Leave, _NonExhaustive])\n</code></pre> <p>See DragDropEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventId","title":"EventId  <code>module-attribute</code>","text":"<pre><code>EventId = NewType('EventId', int)\n</code></pre> <p>tauri::EventId</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTargetType","title":"EventTargetType  <code>module-attribute</code>","text":"<pre><code>EventTargetType = TypeAliasType('EventTargetType', Union[Any, AnyLabel, App, Window, Webview, WebviewWindow, _NonExhaustive])\n</code></pre> <p>See EventTarget for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.ImplEmitter","title":"ImplEmitter  <code>module-attribute</code>","text":"<pre><code>ImplEmitter = ImplManager\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.ImplListener","title":"ImplListener  <code>module-attribute</code>","text":"<pre><code>ImplListener = ImplManager\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.ImplManager","title":"ImplManager  <code>module-attribute</code>","text":"<pre><code>ImplManager = TypeAliasType('ImplManager', Union[App, AppHandle, 'WebviewWindow'])\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.PositionType","title":"PositionType  <code>module-attribute</code>","text":"<pre><code>PositionType = TypeAliasType('PositionType', Union[Physical, Logical])\n</code></pre> <p>See Position for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEventType","title":"RunEventType  <code>module-attribute</code>","text":"<pre><code>RunEventType = TypeAliasType('RunEventType', Union[Exit, ExitRequested, WindowEvent, WebviewEvent, Ready, Resumed, MainEventsCleared, MenuEvent, TrayIconEvent, _NonExhaustive])\n</code></pre> <p>See RunEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.SizeType","title":"SizeType  <code>module-attribute</code>","text":"<pre><code>SizeType = TypeAliasType('SizeType', Union[Physical, Logical])\n</code></pre> <p>See Size for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Url","title":"Url  <code>module-attribute</code>","text":"<pre><code>Url = TypeAliasType('Url', str)\n</code></pre> <p>tauri::Url</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WebviewEventType","title":"WebviewEventType  <code>module-attribute</code>","text":"<pre><code>WebviewEventType = TypeAliasType('WebviewEventType', Union[DragDrop, _NonExhaustive])\n</code></pre> <p>See WebviewEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEventType","title":"WindowEventType  <code>module-attribute</code>","text":"<pre><code>WindowEventType = TypeAliasType('WindowEventType', Union[Resized, Moved, CloseRequested, Destroyed, Focused, ScaleFactorChanged, DragDrop, ThemeChanged, _NonExhaustive])\n</code></pre> <p>See WindowEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ('EXT_MOD', 'App', 'AppHandle', 'Assets', 'Builder', 'BuilderArgs', 'CloseRequestApi', 'Context', 'DragDropEvent', 'DragDropEventType', 'Emitter', 'Event', 'EventId', 'EventTarget', 'EventTargetType', 'ExitRequestApi', 'ImplEmitter', 'ImplListener', 'ImplManager', 'Listener', 'Manager', 'Position', 'PositionType', 'Rect', 'RunEvent', 'RunEventType', 'Size', 'SizeType', 'Theme', 'Url', 'WebviewEvent', 'WebviewEventType', 'WindowEvent', 'WindowEventType', 'builder_factory', 'context_factory')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App","title":"App","text":"<p>Tauri::app</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>run</code> <p>Consume and run this app, will block until the app is exited.</p> <code>run_return</code> <p>Consume and run this application, returning its intended exit code.</p> <code>run_iteration</code> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <code>cleanup_before_exit</code> <p>Runs necessary cleanup tasks before exiting the process.</p> <code>handle</code> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.run","title":"run","text":"<pre><code>run(callback: Optional[_AppRunCallbackType] = None) -&gt; NoReturn\n</code></pre> <p>Consume and run this app, will block until the app is exited.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each event. It will be called on the same thread that the app was created on, so you should not block in this function.</p> <code>None</code> <p>Note</p> <p>This function will call <code>std::process::exit</code> at the end to terminate the entire process, which means the Python interpreter cannot be properly finalized. If this is a problem for you, please use pytauri.App.run_return.</p> <p>Warning</p> <p>If <code>callback</code> is specified, it must not raise an exception, otherwise it is logical undefined behavior, and in most cases, the program will panic.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; NoReturn:\n    \"\"\"Consume and run this app, will block until the app is exited.\n\n    Args:\n        callback: a callback function that will be called on each event.\n            It will be called on the same thread that the app was created on,\n            so you should not block in this function.\n\n    !!! note\n        This function will call `std::process::exit` at the end to terminate the entire process,\n        which means the Python interpreter cannot be properly finalized.\n        If this is a problem for you, please use [pytauri.App.run_return][].\n\n    !!! warning\n        If `callback` is specified, it must not raise an exception,\n        otherwise it is logical undefined behavior, and in most cases, the program will panic.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.run(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.run_return","title":"run_return","text":"<pre><code>run_return(callback: Optional[_AppRunCallbackType] = None) -&gt; int\n</code></pre> <p>Consume and run this application, returning its intended exit code.</p> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_return(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; int:\n    \"\"\"Consume and run this application, returning its intended exit code.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.run_iteration","title":"run_iteration  <code>deprecated</code>","text":"<pre><code>run_iteration(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> Deprecated <p>When called in a loop (as suggested by the name), this function will busy-loop.             To re-gain control of control flow after the app has exited, use <code>App::run_return</code> instead.             See https://docs.rs/tauri/latest/tauri/struct.App.html#method.run_iteration for more details.</p> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each iteration.</p> <code>None</code> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> <p>Tip</p> <p>Approximately 2ms per calling in debug mode.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@deprecated(\n    \"\"\"When called in a loop (as suggested by the name), this function will busy-loop.\n    To re-gain control of control flow after the app has exited, use `App::run_return` instead.\n    See &lt;https://docs.rs/tauri/latest/tauri/struct.App.html#method.run_iteration&gt; for more details.\"\"\",\n    category=None,\n)\ndef run_iteration(\n    self, callback: Optional[_AppRunCallbackType] = None, /\n) -&gt; None:\n    \"\"\"Run this app iteratively without consuming it, calling `callback` on each iteration.\n\n    Args:\n        callback: a callback function that will be called on each iteration.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n\n    !!! tip\n        Approximately 2ms per calling in debug mode.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.run_iteration(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.cleanup_before_exit","title":"cleanup_before_exit","text":"<pre><code>cleanup_before_exit() -&gt; None\n</code></pre> <p>Runs necessary cleanup tasks before exiting the process.</p> <p>You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def cleanup_before_exit(self, /) -&gt; None:\n    \"\"\"Runs necessary cleanup tasks before exiting the process.\n\n    **You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.**\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.handle","title":"handle","text":"<pre><code>handle() -&gt; AppHandle\n</code></pre> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def handle(self, /) -&gt; \"AppHandle\":\n    \"\"\"Get a handle to this app, which can be used to interact with the app from another thread.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle","title":"AppHandle","text":"<p>tauri::AppHandle</p> <p>Methods:</p> Name Description <code>run_on_main_thread</code> <p>Runs the given closure on the main thread.</p> <code>exit</code> <code>restart</code> <code>on_menu_event</code> <p>Registers a global menu event listener.</p> <code>on_tray_icon_event</code> <p>Registers a global tray icon menu event listener.</p> <code>tray_by_id</code> <code>remove_tray_by_id</code> <code>set_theme</code> <code>default_window_icon</code> <p>Returns the default window icon.</p> <code>menu</code> <code>set_menu</code> <code>remove_menu</code> <code>hide_menu</code> <code>show_menu</code> <code>invoke_key</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.run_on_main_thread","title":"run_on_main_thread","text":"<pre><code>run_on_main_thread(handler: Callable[[], object]) -&gt; None\n</code></pre> <p>Runs the given closure on the main thread.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_on_main_thread(self, handler: Callable[[], object], /) -&gt; None:\n    \"\"\"Runs the given closure on the main thread.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.exit","title":"exit","text":"<pre><code>exit(exit_code: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def exit(self, exit_code: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.restart","title":"restart","text":"<pre><code>restart() -&gt; Never\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def restart(self, /) -&gt; Never: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[Self, MenuEvent], None]) -&gt; None\n</code></pre> <p>Registers a global menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[\"Self\", \"MenuEvent\"], None], /\n) -&gt; None:\n    \"\"\"Registers a global menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.on_tray_icon_event","title":"on_tray_icon_event","text":"<pre><code>on_tray_icon_event(handler: Callable[[Self, TrayIconEventType], None]) -&gt; None\n</code></pre> <p>Registers a global tray icon menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_tray_icon_event(\n    self, handler: Callable[[Self, TrayIconEventType], None], /\n) -&gt; None:\n    \"\"\"Registers a global tray icon menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.tray_by_id","title":"tray_by_id","text":"<pre><code>tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.remove_tray_by_id","title":"remove_tray_by_id","text":"<pre><code>remove_tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.set_theme","title":"set_theme","text":"<pre><code>set_theme(theme: Optional[Theme]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_theme(self, theme: Optional[\"Theme\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.default_window_icon","title":"default_window_icon","text":"<pre><code>default_window_icon() -&gt; Optional[Image]\n</code></pre> <p>Returns the default window icon.</p> <p>Warning</p> <p>Each time you call this function, a new image instance will be created. So you should cache the result if you need to use it multiple times.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def default_window_icon(self, /) -&gt; Optional[Image]:\n    \"\"\"Returns the default window icon.\n\n    !!! warning\n        Each time you call this function, a new image instance will be created.\n        So you should cache the result if you need to use it multiple times.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.menu","title":"menu","text":"<pre><code>menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Menu) -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_menu(self, menu: Menu, /) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.remove_menu","title":"remove_menu","text":"<pre><code>remove_menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.hide_menu","title":"hide_menu","text":"<pre><code>hide_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def hide_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.show_menu","title":"show_menu","text":"<pre><code>show_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def show_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.invoke_key","title":"invoke_key","text":"<pre><code>invoke_key() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def invoke_key(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Assets","title":"Assets","text":"<p>               Bases: <code>ABC</code></p> <p>tauri::Assets</p> <p>This is an abstract class that you can subclass to implement a custom asset loader.</p> <p>See <code>tauri::Assets</code> rust docs for more details.</p> <p>Warning</p> <p>The implement has the same restrictions as App.run.</p> <p>Methods:</p> Name Description <code>get</code> <code>iter</code> <code>setup</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Assets.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key: _AssetKey) -&gt; Optional[bytes]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef get(self, key: _AssetKey, /) -&gt; Optional[bytes]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Assets.iter","title":"iter  <code>abstractmethod</code>","text":"<pre><code>iter() -&gt; Iterator[tuple[str, bytes]]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef iter(self, /) -&gt; Iterator[tuple[str, bytes]]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Assets.setup","title":"setup","text":"<pre><code>setup(_app: AppHandle) -&gt; object\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def setup(self, _app: AppHandle, /) -&gt; object:\n    return None\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Builder","title":"Builder","text":"<p>tauri::Builder</p> <p>use builder_factory to instantiate this class.</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>build</code> <p>tauri::Builder::build</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Builder.build","title":"build","text":"<pre><code>build(context: Context, **kwargs: Unpack[BuilderArgs]) -&gt; App\n</code></pre> <p>tauri::Builder::build</p> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>Context</code> <p>use context_factory to get it.</p> required <code>Unpack[BuilderArgs]</code> <p>see BuilderArgs for details.</p> <code>{}</code> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def build(self, context: \"Context\", **kwargs: Unpack[\"BuilderArgs\"]) -&gt; App:\n    \"\"\"[tauri::Builder::build](https://docs.rs/tauri/latest/tauri/struct.Builder.html#method.build)\n\n    Consume this builder and build an app with the given `BuilderArgs`.\n\n    Args:\n        context: use [context_factory][pytauri.context_factory] to get it.\n        **kwargs: see [BuilderArgs][pytauri.BuilderArgs] for details.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Builder.build(context)","title":"<code>context</code>","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Builder.build(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.BuilderArgs","title":"BuilderArgs","text":"<p>               Bases: <code>TypedDict</code></p> <p>tauri::Builder</p> <p>Attributes:</p> Name Type Description <code>invoke_handler</code> <code>Required[Optional[_InvokeHandlerProto]]</code> <p>Use Commands to get it.</p> <code>setup</code> <code>Callable[[AppHandle], object]</code> <p>See rust <code>tauri::Builder::setup</code></p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.BuilderArgs.invoke_handler","title":"invoke_handler  <code>instance-attribute</code>","text":"<pre><code>invoke_handler: Required[Optional[_InvokeHandlerProto]]\n</code></pre> <p>Use Commands to get it.</p> <p>Warning</p> <p>The implement of <code>invoke_handler</code> must never raise an exception, otherwise it is considered logical undefined behavior. Additionally, <code>invoke_handler</code> must not block.</p> <p>Warning</p> <p>If you do not specify <code>invoke_handler</code>, <code>pytauri</code> will not register the <code>tauri-plugin-pytauri</code> plugin, which means you cannot use <code>pyInvoke</code> in the frontend to call <code>Commands</code> (you will receive an error like \"plugin pytauri not found\"). If this is indeed the behavior you expect, explicitly pass None.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.BuilderArgs.setup","title":"setup  <code>instance-attribute</code>","text":"<pre><code>setup: Callable[[AppHandle], object]\n</code></pre> <p>See rust <code>tauri::Builder::setup</code></p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.CloseRequestApi","title":"CloseRequestApi","text":"<p>tauri::CloseRequestApi</p> <p>Methods:</p> Name Description <code>prevent_close</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.CloseRequestApi.prevent_close","title":"prevent_close","text":"<pre><code>prevent_close() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def prevent_close(self, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Context","title":"Context","text":"<p>tauri::Context</p> <p>Methods:</p> Name Description <code>set_assets</code> <p>Use custom assets instead of the assets bundled by Tauri.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Context.set_assets","title":"set_assets","text":"<pre><code>set_assets(assets: Assets) -&gt; None\n</code></pre> <p>Use custom assets instead of the assets bundled by Tauri.</p> <p>To make this work:</p> <ul> <li>You need to enable the <code>tauri/custom-protocol</code> feature.<ul> <li>Or build using <code>tauri build</code>.</li> </ul> </li> <li>Set <code>frontendDist</code> in <code>tauri.conf.json</code> to an empty directory (do not set it to a URL).<ul> <li> <p>Or generate <code>Context</code> via:</p> <pre><code>use tauri::{generate_context, test::noop_assets};\n\nlet context = generate_context!(assets=noop_assets());\n</code></pre> <p>then we will use this method to set the assets.</p> <p>see: https://github.com/tauri-apps/tauri/pull/9141</p> </li> </ul> </li> </ul> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_assets(self, assets: \"Assets\", /) -&gt; None:\n    \"\"\"Use custom assets instead of the assets bundled by Tauri.\n\n    To make this work:\n\n    - You need to enable the `tauri/custom-protocol` feature.\n        - Or build using `tauri build`.\n    - Set `frontendDist` in `tauri.conf.json` to an empty directory (do not set it to a URL).\n        - Or generate `Context` via:\n\n            ```rust\n            use tauri::{generate_context, test::noop_assets};\n\n            let context = generate_context!(assets=noop_assets());\n            ```\n\n            then we will use this method to set the assets.\n\n            see: &lt;https://github.com/tauri-apps/tauri/pull/9141&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEvent","title":"DragDropEvent","text":"<p>tauri::DragDropEvent</p> <p>Classes:</p> Name Description <code>Enter</code> <p>tauri::DragDropEvent::Enter</p> <code>Over</code> <p>tauri::DragDropEvent::Over</p> <code>Drop</code> <p>tauri::DragDropEvent::Drop</p> <code>Leave</code> <p>tauri::DragDropEvent::Leave</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEvent.Enter","title":"Enter","text":"<p>tauri::DragDropEvent::Enter</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>_VecPathBuf</code> <code>position</code> <code>_PhysicalPositionF64</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEvent.Enter.paths","title":"paths  <code>instance-attribute</code>","text":"<pre><code>paths: _VecPathBuf\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEvent.Enter.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEvent.Over","title":"Over","text":"<p>tauri::DragDropEvent::Over</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>_PhysicalPositionF64</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEvent.Over.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEvent.Drop","title":"Drop","text":"<p>tauri::DragDropEvent::Drop</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>_VecPathBuf</code> <code>position</code> <code>_PhysicalPositionF64</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEvent.Drop.paths","title":"paths  <code>instance-attribute</code>","text":"<pre><code>paths: _VecPathBuf\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEvent.Drop.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.DragDropEvent.Leave","title":"Leave","text":"<p>tauri::DragDropEvent::Leave</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Emitter","title":"Emitter","text":"<p>tauri::Emitter</p> <p>Methods:</p> Name Description <code>emit_str</code> <p>Similar to [<code>Emitter::emit</code>] but the payload is json serialized.</p> <code>emit_str_to</code> <p>Similar to [<code>Emitter::emit_to</code>] but the payload is json serialized.</p> <code>emit_str_filter</code> <p>Similar to [<code>Emitter::emit_filter</code>] but the payload is json serialized.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Emitter.emit_str","title":"emit_str  <code>staticmethod</code>","text":"<pre><code>emit_str(slf: ImplEmitter, event: str, payload: str) -&gt; None\n</code></pre> <p>Similar to [<code>Emitter::emit</code>] but the payload is json serialized.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef emit_str(\n    slf: \"ImplEmitter\",\n    event: str,\n    payload: str,\n    /,\n) -&gt; None:\n    \"\"\"Similar to [`Emitter::emit`] but the payload is json serialized.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Emitter.emit_str_to","title":"emit_str_to  <code>staticmethod</code>","text":"<pre><code>emit_str_to(slf: ImplEmitter, target: EventTargetType, event: str, payload: str) -&gt; None\n</code></pre> <p>Similar to [<code>Emitter::emit_to</code>] but the payload is json serialized.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef emit_str_to(\n    slf: \"ImplEmitter\",\n    target: \"EventTargetType\",\n    event: str,\n    payload: str,\n    /,\n) -&gt; None:\n    \"\"\"Similar to [`Emitter::emit_to`] but the payload is json serialized.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Emitter.emit_str_filter","title":"emit_str_filter  <code>staticmethod</code>","text":"<pre><code>emit_str_filter(slf: ImplEmitter, event: str, payload: str, filter: Callable[[EventTargetType], bool]) -&gt; None\n</code></pre> <p>Similar to [<code>Emitter::emit_filter</code>] but the payload is json serialized.</p> <p>Warning</p> <p><code>filter</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef emit_str_filter(\n    slf: \"ImplEmitter\",\n    event: str,\n    payload: str,\n    filter: Callable[[\"EventTargetType\"], bool],  # noqa: A002\n    /,\n) -&gt; None:\n    \"\"\"Similar to [`Emitter::emit_filter`] but the payload is json serialized.\n\n    !!! warning\n        `filter` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Event","title":"Event","text":"<p>tauri::Event</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>EventId</code> <p>The <code>EventId</code> of the handler that was triggered.</p> <code>payload</code> <code>str</code> <p>The event payload.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Event.id","title":"id  <code>property</code>","text":"<pre><code>id: EventId\n</code></pre> <p>The <code>EventId</code> of the handler that was triggered.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Event.payload","title":"payload  <code>property</code>","text":"<pre><code>payload: str\n</code></pre> <p>The event payload.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget","title":"EventTarget","text":"<p>tauri::EventTarget</p> <p>Classes:</p> Name Description <code>Any</code> <p>Any and all event targets.</p> <code>AnyLabel</code> <p>Any <code>Window</code>, <code>Webview</code> or <code>WebviewWindow</code> that have this label.</p> <code>App</code> <p>App and AppHandle targets.</p> <code>Window</code> <p><code>Window</code> target.</p> <code>Webview</code> <p>Webview target.</p> <code>WebviewWindow</code> <p>WebviewWindow target.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.Any","title":"Any","text":"<p>Any and all event targets.</p> <p>Methods:</p> Name Description <code>__new__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.Any.__new__","title":"__new__","text":"<pre><code>__new__() -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.AnyLabel","title":"AnyLabel","text":"<p>Any <code>Window</code>, <code>Webview</code> or <code>WebviewWindow</code> that have this label.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Target label.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.AnyLabel.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>Target label.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.AnyLabel.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.App","title":"App","text":"<p>App and AppHandle targets.</p> <p>Methods:</p> Name Description <code>__new__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.App.__new__","title":"__new__","text":"<pre><code>__new__() -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.Window","title":"Window","text":"<p><code>Window</code> target.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>window label.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.Window.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>window label.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.Window.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.Webview","title":"Webview","text":"<p>Webview target.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>webview label.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.Webview.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>webview label.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.Webview.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.WebviewWindow","title":"WebviewWindow","text":"<p>WebviewWindow target.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>webview window label.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.WebviewWindow.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>webview window label.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventTarget.WebviewWindow.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.ExitRequestApi","title":"ExitRequestApi","text":"<p>tauri::ExitRequestApi</p> <p>Methods:</p> Name Description <code>prevent_exit</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.ExitRequestApi.prevent_exit","title":"prevent_exit","text":"<pre><code>prevent_exit() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def prevent_exit(self, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener","title":"Listener","text":"<p>tauri::Listener</p> <p>See also: https://tauri.app/develop/calling-rust/#event-system</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener--examples","title":"Examples","text":"<pre><code>from pydantic import BaseModel\nfrom pytauri import AppHandle, Event, Listener\n\n\nclass Payload(BaseModel):  # or `RootModel`\n    url: str\n    num: int\n\n\ndef listen(app_handle: AppHandle) -&gt; None:\n    def handler(event: Event):\n        assert event.id == event_id\n\n        serialized_event = Payload.model_validate_json(event.payload)\n        print(serialized_event.url, serialized_event.num)\n\n    event_id = Listener.listen(app_handle, \"event_name\", handler)\n</code></pre> <p>Methods:</p> Name Description <code>listen</code> <p>Listen to an emitted event on this manager.</p> <code>once</code> <p>Listen to an event on this manager only once.</p> <code>unlisten</code> <p>Remove an event listener.</p> <code>listen_any</code> <p>Listen to an emitted event to any target.</p> <code>once_any</code> <p>Listens once to an emitted event to any target .</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener.listen","title":"listen  <code>staticmethod</code>","text":"<pre><code>listen(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event on this manager.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event on this manager.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener.once","title":"once  <code>staticmethod</code>","text":"<pre><code>once(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an event on this manager only once.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an event on this manager only once.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener.unlisten","title":"unlisten  <code>staticmethod</code>","text":"<pre><code>unlisten(slf: ImplListener, id: EventId) -&gt; None\n</code></pre> <p>Remove an event listener.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef unlisten(\n    slf: \"ImplListener\",\n    id: \"EventId\",  # noqa: A002\n    /,\n) -&gt; None:\n    \"\"\"Remove an event listener.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener.listen_any","title":"listen_any  <code>staticmethod</code>","text":"<pre><code>listen_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event to any target.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event to any target.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener.once_any","title":"once_any  <code>staticmethod</code>","text":"<pre><code>once_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listens once to an emitted event to any target .</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listens once to an emitted event to any target .\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Manager","title":"Manager","text":"<p>tauri::Manager</p> <p>Methods:</p> Name Description <code>app_handle</code> <p>The application handle associated with this manager.</p> <code>get_webview_window</code> <p>Fetch a single webview window from the manager.</p> <code>webview_windows</code> <p>Fetch all managed webview windows.</p> <code>path</code> <p>The path resolver is a helper class for general and application-specific path APIs.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Manager.app_handle","title":"app_handle  <code>staticmethod</code>","text":"<pre><code>app_handle(slf: ImplManager) -&gt; AppHandle\n</code></pre> <p>The application handle associated with this manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef app_handle(slf: \"ImplManager\", /) -&gt; AppHandle:\n    \"\"\"The application handle associated with this manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Manager.get_webview_window","title":"get_webview_window  <code>staticmethod</code>","text":"<pre><code>get_webview_window(slf: ImplManager, label: str) -&gt; Optional[WebviewWindow]\n</code></pre> <p>Fetch a single webview window from the manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef get_webview_window(\n    slf: \"ImplManager\", label: str, /\n) -&gt; Optional[WebviewWindow]:\n    \"\"\"Fetch a single webview window from the manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Manager.webview_windows","title":"webview_windows  <code>staticmethod</code>","text":"<pre><code>webview_windows(slf: ImplManager) -&gt; dict[str, WebviewWindow]\n</code></pre> <p>Fetch all managed webview windows.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef webview_windows(slf: \"ImplManager\", /) -&gt; dict[str, WebviewWindow]:\n    \"\"\"Fetch all managed webview windows.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Manager.path","title":"path  <code>staticmethod</code>","text":"<pre><code>path(slf: ImplManager) -&gt; PathResolver\n</code></pre> <p>The path resolver is a helper class for general and application-specific path APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef path(slf: \"ImplManager\", /) -&gt; PathResolver:\n    \"\"\"The path resolver is a helper class for general and application-specific path APIs.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Position","title":"Position","text":"<p>tauri::Position</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Position::Physical</p> <code>Logical</code> <p>tauri::Position::Logical</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Position.Physical","title":"Physical","text":"<p>               Bases: <code>tuple[_PhysicalPositionI32]</code></p> <p>tauri::Position::Physical</p> <p>Warning</p> <p>This is actually a <code>Class</code> disguised as an <code>NamedTuple</code>. See also: https://pyo3.rs/v0.23.4/class.html#pyclass-enums.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Position.Physical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Position.Physical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalPositionI32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalPositionI32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Position.Logical","title":"Logical","text":"<p>               Bases: <code>tuple[_LogicalPositionF64]</code></p> <p>tauri::Position::Logical</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Position.Logical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Position.Logical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _LogicalPositionF64) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _LogicalPositionF64, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Rect","title":"Rect","text":"<p>tauri::Rect</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>position</code> <code>PositionType</code> <code>size</code> <code>SizeType</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Rect.position","title":"position  <code>property</code>","text":"<pre><code>position: PositionType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Rect.size","title":"size  <code>property</code>","text":"<pre><code>size: SizeType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Rect.__new__","title":"__new__","text":"<pre><code>__new__(*, position: PositionType, size: SizeType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    position: \"PositionType\",\n    size: \"SizeType\",\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent","title":"RunEvent","text":"<p>tauri::RunEvent</p> <p>Classes:</p> Name Description <code>Exit</code> <p>tauri::RunEvent::Exit</p> <code>ExitRequested</code> <p>tauri::RunEvent::ExitRequested</p> <code>WindowEvent</code> <p>tauri::RunEvent::WindowEvent</p> <code>WebviewEvent</code> <p>tauri::RunEvent::WebviewEvent</p> <code>Ready</code> <p>tauri::RunEvent::Ready</p> <code>Resumed</code> <p>tauri::RunEvent::Resumed</p> <code>MainEventsCleared</code> <p>tauri::RunEvent::MainEventsCleared</p> <code>MenuEvent</code> <p>tauri::RunEvent::MenuEvent</p> <code>TrayIconEvent</code> <p>tauri::RunEvent::TrayIconEvent</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.Exit","title":"Exit","text":"<p>tauri::RunEvent::Exit</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.ExitRequested","title":"ExitRequested","text":"<p>tauri::RunEvent::ExitRequested</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>Optional[int]</code> <code>api</code> <code>ExitRequestApi</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.ExitRequested.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Optional[int]\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.ExitRequested.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api: ExitRequestApi\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.WindowEvent","title":"WindowEvent","text":"<p>tauri::RunEvent::WindowEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <code>event</code> <code>WindowEventType</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.WindowEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.WindowEvent.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: WindowEventType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::RunEvent::WebviewEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <code>event</code> <code>WebviewEventType</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.WebviewEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.WebviewEvent.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: WebviewEventType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.Ready","title":"Ready","text":"<p>tauri::RunEvent::Ready</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.Resumed","title":"Resumed","text":"<p>tauri::RunEvent::Resumed</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.MainEventsCleared","title":"MainEventsCleared","text":"<p>tauri::RunEvent::MainEventsCleared</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.MenuEvent","title":"MenuEvent","text":"<p>               Bases: <code>tuple[MenuEvent]</code></p> <p>tauri::RunEvent::MenuEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.MenuEvent.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.MenuEvent.__new__","title":"__new__","text":"<pre><code>__new__(_0: MenuEvent) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: MenuEvent, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.TrayIconEvent","title":"TrayIconEvent","text":"<p>               Bases: <code>tuple[TrayIconEventType]</code></p> <p>tauri::RunEvent::TrayIconEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.TrayIconEvent.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.TrayIconEvent.__new__","title":"__new__","text":"<pre><code>__new__(_0: TrayIconEventType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: TrayIconEventType, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Size","title":"Size","text":"<p>tauri::Size</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Size::Physical</p> <code>Logical</code> <p>tauri::Size::Logical</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Size.Physical","title":"Physical","text":"<p>               Bases: <code>tuple[_PhysicalSizeU32]</code></p> <p>tauri::Size::Physical</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Size.Physical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Size.Physical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalSizeU32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalSizeU32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Size.Logical","title":"Logical","text":"<p>               Bases: <code>tuple[_LogicalSizeF64]</code></p> <p>tauri::Size::Logical</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Size.Logical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Size.Logical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _LogicalSizeF64) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _LogicalSizeF64, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Theme","title":"Theme","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::Theme</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Light</code> <code>Dark</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Theme.Light","title":"Light  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Light = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Theme.Dark","title":"Dark  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Dark = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::WebviewEvent</p> <p>Classes:</p> Name Description <code>DragDrop</code> <p>tauri::WebviewEvent::DragDrop</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WebviewEvent.DragDrop","title":"DragDrop","text":"<p>               Bases: <code>tuple['DragDropEventType']</code></p> <p>tauri::WebviewEvent::DragDrop</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WebviewEvent.DragDrop.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WebviewEvent.DragDrop.__new__","title":"__new__","text":"<pre><code>__new__(_0: DragDropEventType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: \"DragDropEventType\", /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent","title":"WindowEvent","text":"<p>tauri::WindowEvent</p> <p>Classes:</p> Name Description <code>Resized</code> <p>tauri::WindowEvent::Resized</p> <code>Moved</code> <p>tauri::WindowEvent::Moved</p> <code>CloseRequested</code> <p>tauri::WindowEvent::CloseRequested</p> <code>Destroyed</code> <p>tauri::WindowEvent::Destroyed</p> <code>Focused</code> <p>tauri::WindowEvent::Focused</p> <code>ScaleFactorChanged</code> <p>tauri::WindowEvent::ScaleFactorChanged</p> <code>DragDrop</code> <p>tauri::WindowEvent::DragDrop</p> <code>ThemeChanged</code> <p>tauri::WindowEvent::ThemeChanged</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.Resized","title":"Resized","text":"<p>               Bases: <code>tuple[_PhysicalSizeU32]</code></p> <p>tauri::WindowEvent::Resized</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.Resized.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.Resized.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalSizeU32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalSizeU32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.Moved","title":"Moved","text":"<p>               Bases: <code>tuple[_PhysicalPositionI32]</code></p> <p>tauri::WindowEvent::Moved</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.Moved.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.Moved.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalPositionI32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalPositionI32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.CloseRequested","title":"CloseRequested","text":"<p>tauri::WindowEvent::CloseRequested</p> <p>Attributes:</p> Name Type Description <code>api</code> <code>CloseRequestApi</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.CloseRequested.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api: CloseRequestApi\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.Destroyed","title":"Destroyed","text":"<p>tauri::WindowEvent::Destroyed</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.Focused","title":"Focused","text":"<p>               Bases: <code>tuple[bool]</code></p> <p>tauri::WindowEvent::Focused</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.Focused.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.Focused.__new__","title":"__new__","text":"<pre><code>__new__(_0: bool) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: bool, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.ScaleFactorChanged","title":"ScaleFactorChanged","text":"<p>tauri::WindowEvent::ScaleFactorChanged</p> <p>Attributes:</p> Name Type Description <code>scale_factor</code> <code>float</code> <code>new_inner_size</code> <code>_PhysicalSizeU32</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.ScaleFactorChanged.scale_factor","title":"scale_factor  <code>instance-attribute</code>","text":"<pre><code>scale_factor: float\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.ScaleFactorChanged.new_inner_size","title":"new_inner_size  <code>instance-attribute</code>","text":"<pre><code>new_inner_size: _PhysicalSizeU32\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.DragDrop","title":"DragDrop","text":"<p>               Bases: <code>tuple['DragDropEventType']</code></p> <p>tauri::WindowEvent::DragDrop</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.DragDrop.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.DragDrop.__new__","title":"__new__","text":"<pre><code>__new__(_0: DragDropEventType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: \"DragDropEventType\", /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.ThemeChanged","title":"ThemeChanged","text":"<p>               Bases: <code>tuple['Theme']</code></p> <p>tauri::WindowEvent::ThemeChanged</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.ThemeChanged.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.WindowEvent.ThemeChanged.__new__","title":"__new__","text":"<pre><code>__new__(_0: Theme) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: \"Theme\", /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.builder_factory","title":"builder_factory","text":"<pre><code>builder_factory(*args: Any, **kwargs: Any) -&gt; Builder\n</code></pre> <p>A factory function for creating a <code>Builder</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def builder_factory(*args: Any, **kwargs: Any) -&gt; Builder:\n    \"\"\"A factory function for creating a `Builder` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.context_factory","title":"context_factory","text":"<pre><code>context_factory(*args: Any, **kwargs: Any) -&gt; Context\n</code></pre> <p>A factory function for creating a <code>Context</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def context_factory(*args: Any, **kwargs: Any) -&gt; Context:\n    \"\"\"A factory function for creating a `Context` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/image/","title":"image","text":""},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image","title":"pytauri.ffi.image","text":"<p>tauri::image</p> <p>Classes:</p> Name Description <code>Image</code> <p>tauri::image::Image</p>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Image']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.Image","title":"Image","text":"<p>tauri::image::Image</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>rgba</code> <code>bytes</code> <code>width</code> <code>int</code> <code>height</code> <code>int</code>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.Image.rgba","title":"rgba  <code>property</code>","text":"<pre><code>rgba: bytes\n</code></pre>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.Image.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.Image.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.Image.__new__","title":"__new__","text":"<pre><code>__new__(rgba: bytes, width: int, height: int) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/image.py</code> <pre><code>def __new__(cls, rgba: bytes, width: int, height: int, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/","title":"ipc","text":""},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc","title":"pytauri.ffi.ipc","text":"<p>tauri::ipc</p> <p>Classes:</p> Name Description <code>ParametersType</code> <p>The parameters of a command.</p> <code>ArgumentsType</code> <p>The bound arguments of a command.</p> <code>Invoke</code> <p>tauri::ipc::Invoke</p> <code>InvokeResolver</code> <p>tauri::ipc::InvokeResolver</p> <code>JavaScriptChannelId</code> <p>tauri::ipc::JavaScriptChannelId</p> <code>Channel</code> <p>tauri::ipc::Channel</p> <p>Attributes:</p> Name Type Description <code>Headers</code> <p>http::header::HeaderMap::iter</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ArgumentsType', 'Channel', 'Headers', 'Invoke', 'InvokeResolver', 'JavaScriptChannelId', 'ParametersType']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Headers","title":"Headers  <code>module-attribute</code>","text":"<pre><code>Headers = TypeAliasType('Headers', list[tuple[bytes, bytes]])\n</code></pre> <p>http::header::HeaderMap::iter</p> <p><code>(key, value)</code> pairs of headers.</p> <p>Each key will be yielded once per associated value. So, if a key has 3 associated values, it will be yielded 3 times.</p> <pre><code>[(b\"key0\", b\"value00\"), (b\"key0\", b\"value01\"), (b\"key1\", b\"value1\")]\n</code></pre> <p>Tip</p> <p>You can use libraries like multidict or httpx.Headers to convert it into dict for more efficient retrieval of a specific header.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType","title":"ParametersType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The parameters of a command.</p> <p>All keys are optional, and values can be of any type. If a key exists, it will be assigned a value corresponding to ArgumentsType.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p> <code>app_handle</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p> <code>webview_window</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p> <code>headers</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType.webview_window","title":"webview_window  <code>instance-attribute</code>","text":"<pre><code>webview_window: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType","title":"ArgumentsType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The bound arguments of a command.</p> <p>Each key is optional, depending on the keys of the bound ParametersType.</p> <p>You can use it like <code>**kwargs</code>, for example <code>command(**arguments)</code>.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>bytes</code> <p>The body of this ipc message.</p> <code>app_handle</code> <code>AppHandle</code> <p>The handle of the app.</p> <code>webview_window</code> <code>WebviewWindow</code> <p>The <code>WebviewWindow</code> of this <code>Invoke</code>.</p> <code>headers</code> <code>Headers</code> <p>The headers of this ipc message.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: bytes\n</code></pre> <p>The body of this ipc message.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: AppHandle\n</code></pre> <p>The handle of the app.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType.webview_window","title":"webview_window  <code>instance-attribute</code>","text":"<pre><code>webview_window: WebviewWindow\n</code></pre> <p>The <code>WebviewWindow</code> of this <code>Invoke</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers: Headers\n</code></pre> <p>The headers of this ipc message.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke","title":"Invoke","text":"<p>tauri::ipc::Invoke</p> <p>Methods:</p> Name Description <code>bind_to</code> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <code>resolve</code> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>The name of the current command.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.command","title":"command  <code>property</code>","text":"<pre><code>command: str\n</code></pre> <p>The name of the current command.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.bind_to","title":"bind_to","text":"<pre><code>bind_to(parameters: ParametersType) -&gt; Optional[InvokeResolver[_ArgumentsTypeVar]]\n</code></pre> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <p>If the frontend illegally calls the IPC, this method will automatically reject this <code>Invoke</code> and return <code>None</code>.</p> <p>The return value InvokeResolver.arguments is not the same object as the input <code>parameters</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def bind_to(\n    self, parameters: ParametersType\n) -&gt; Optional[\"InvokeResolver[_ArgumentsTypeVar]\"]:\n    \"\"\"Consumes this `Invoke` and binds parameters.\n\n    If the frontend illegally calls the IPC,\n    this method will automatically reject this `Invoke` and return `None`.\n\n    The return value [InvokeResolver.arguments][pytauri.ffi.ipc.InvokeResolver.arguments]\n    is not the same object as the input `parameters`.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.resolve","title":"resolve","text":"<pre><code>resolve(value: _InvokeResponseBody) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> <p>Parameters:</p> Name Type Description Default <code>_InvokeResponseBody</code> <p>The value to resolve the command with.</p> <ul> <li>If <code>str</code>, it will be serialized as JSON on the frontend.</li> <li>If <code>bytes</code>, it will be sent as <code>ArrayBuffer</code> to the frontend.</li> </ul> required Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: _InvokeResponseBody) -&gt; None:\n    \"\"\"Consumes this `Invoke` and resolves the command with the given value.\n\n    Args:\n        value: The value to resolve the command with.\n\n            - If `str`, it will be serialized as JSON on the frontend.\n            - If `bytes`, it will be sent as `ArrayBuffer` to the frontend.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.resolve(value)","title":"<code>value</code>","text":""},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `Invoke` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver","title":"InvokeResolver","text":"<p>               Bases: <code>Generic[_ArgumentsTypeVar]</code></p> <p>tauri::ipc::InvokeResolver</p> <p>Methods:</p> Name Description <code>resolve</code> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>arguments</code> <code>_ArgumentsTypeVar</code> <p>The bound arguments of the current command.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: _ArgumentsTypeVar\n</code></pre> <p>The bound arguments of the current command.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver.resolve","title":"resolve","text":"<pre><code>resolve(value: _InvokeResponseBody) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> <p>Parameters:</p> Name Type Description Default <code>_InvokeResponseBody</code> <p>The value to resolve the command with.</p> <ul> <li>If <code>str</code>, it will be serialized as JSON on the frontend.</li> <li>If <code>bytes</code>, it will be sent as <code>ArrayBuffer</code> to the frontend.</li> </ul> required Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: _InvokeResponseBody) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and resolves the command with the given value.\n\n    Args:\n        value: The value to resolve the command with.\n\n            - If `str`, it will be serialized as JSON on the frontend.\n            - If `bytes`, it will be sent as `ArrayBuffer` to the frontend.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver.resolve(value)","title":"<code>value</code>","text":""},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.JavaScriptChannelId","title":"JavaScriptChannelId","text":"<p>tauri::ipc::JavaScriptChannelId</p> <p>Methods:</p> Name Description <code>from_str</code> <p>Parse a string to a <code>JavaScriptChannelId</code>.</p> <code>channel_on</code> <p>Gets a <code>Channel</code> for this channel ID on the given <code>Webview</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.JavaScriptChannelId.from_str","title":"from_str  <code>staticmethod</code>","text":"<pre><code>from_str(value: str) -&gt; JavaScriptChannelId\n</code></pre> <p>Parse a string to a <code>JavaScriptChannelId</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is ivnalid.</p> <code>TypeError</code> <p>If the <code>value</code> is not a string.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>@staticmethod\ndef from_str(value: str, /) -&gt; \"JavaScriptChannelId\":\n    \"\"\"Parse a string to a `JavaScriptChannelId`.\n\n    Raises:\n        ValueError: If the string is ivnalid.\n        TypeError: If the `value` is not a string.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.JavaScriptChannelId.channel_on","title":"channel_on","text":"<pre><code>channel_on(webview: Webview) -&gt; Channel\n</code></pre> <p>Gets a <code>Channel</code> for this channel ID on the given <code>Webview</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def channel_on(self, webview: Webview, /) -&gt; \"Channel\":\n    \"\"\"Gets a `Channel` for this channel ID on the given `Webview`.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Channel","title":"Channel","text":"<p>tauri::ipc::Channel</p> <p>Methods:</p> Name Description <code>id</code> <p>The channel identifier.</p> <code>send</code> <p>Sends the given data through the channel.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Channel.id","title":"id","text":"<pre><code>id() -&gt; int\n</code></pre> <p>The channel identifier.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def id(self, /) -&gt; int:\n    \"\"\"The channel identifier.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Channel.send","title":"send","text":"<pre><code>send(data: _InvokeResponseBody) -&gt; None\n</code></pre> <p>Sends the given data through the channel.</p> <p>Parameters:</p> Name Type Description Default <code>_InvokeResponseBody</code> <p>The data to send.</p> <ul> <li>If <code>str</code>, it will be deserialized as JSON on the frontend.</li> <li>If <code>bytes</code>, it will be sent as <code>ArrayBuffer</code> to the frontend.</li> </ul> required Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def send(self, data: _InvokeResponseBody, /) -&gt; None:\n    \"\"\"Sends the given data through the channel.\n\n    Args:\n        data: The data to send.\n\n            - If `str`, it will be deserialized as JSON on the frontend.\n            - If `bytes`, it will be sent as `ArrayBuffer` to the frontend.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Channel.send(data)","title":"<code>data</code>","text":""},{"location":"reference/py/pytauri/ffi/lib/","title":"lib","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib","title":"pytauri.ffi.lib","text":"<p>tauri::self</p> <p>Classes:</p> Name Description <code>App</code> <p>Tauri::app</p> <code>AppHandle</code> <p>tauri::AppHandle</p> <code>Builder</code> <p>tauri::Builder</p> <code>Context</code> <p>tauri::Context</p> <code>RunEvent</code> <p>tauri::RunEvent</p> <code>ExitRequestApi</code> <p>tauri::ExitRequestApi</p> <code>CloseRequestApi</code> <p>tauri::CloseRequestApi</p> <code>DragDropEvent</code> <p>tauri::DragDropEvent</p> <code>WebviewEvent</code> <p>tauri::WebviewEvent</p> <code>WindowEvent</code> <p>tauri::WindowEvent</p> <code>Manager</code> <p>tauri::Manager</p> <code>Event</code> <p>tauri::Event</p> <code>Listener</code> <p>tauri::Listener</p> <code>Position</code> <p>tauri::Position</p> <code>Size</code> <p>tauri::Size</p> <code>Rect</code> <p>tauri::Rect</p> <code>EventTarget</code> <p>tauri::EventTarget</p> <code>Emitter</code> <p>tauri::Emitter</p> <code>Theme</code> <p>tauri::Theme</p> <code>BuilderArgs</code> <p>tauri::Builder</p> <code>Assets</code> <p>tauri::Assets</p> <p>Functions:</p> Name Description <code>builder_factory</code> <p>A factory function for creating a <code>Builder</code> instance.</p> <code>context_factory</code> <p>A factory function for creating a <code>Context</code> instance.</p> <p>Attributes:</p> Name Type Description <code>RunEventType</code> <p>See RunEvent for details.</p> <code>DragDropEventType</code> <p>See DragDropEvent for details.</p> <code>WebviewEventType</code> <p>See WebviewEvent for details.</p> <code>WindowEventType</code> <p>See WindowEvent for details.</p> <code>ImplManager</code> <code>EventId</code> <p>tauri::EventId</p> <code>ImplListener</code> <code>PositionType</code> <p>See Position for details.</p> <code>SizeType</code> <p>See Size for details.</p> <code>Url</code> <p>tauri::Url</p> <code>ImplEmitter</code> <code>EventTargetType</code> <p>See EventTarget for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['App', 'AppHandle', 'Assets', 'Builder', 'BuilderArgs', 'CloseRequestApi', 'Context', 'DragDropEvent', 'DragDropEventType', 'Emitter', 'Event', 'EventId', 'EventTarget', 'EventTargetType', 'ExitRequestApi', 'ImplEmitter', 'ImplListener', 'ImplManager', 'Listener', 'Manager', 'Position', 'PositionType', 'Rect', 'RunEvent', 'RunEventType', 'Size', 'SizeType', 'Theme', 'Url', 'WebviewEvent', 'WebviewEventType', 'WindowEvent', 'WindowEventType', 'builder_factory', 'context_factory']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventType","title":"RunEventType  <code>module-attribute</code>","text":"<pre><code>RunEventType = TypeAliasType('RunEventType', Union[Exit, ExitRequested, WindowEvent, WebviewEvent, Ready, Resumed, MainEventsCleared, MenuEvent, TrayIconEvent, _NonExhaustive])\n</code></pre> <p>See RunEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEventType","title":"DragDropEventType  <code>module-attribute</code>","text":"<pre><code>DragDropEventType = TypeAliasType('DragDropEventType', Union[Enter, Over, Drop, Leave, _NonExhaustive])\n</code></pre> <p>See DragDropEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WebviewEventType","title":"WebviewEventType  <code>module-attribute</code>","text":"<pre><code>WebviewEventType = TypeAliasType('WebviewEventType', Union[DragDrop, _NonExhaustive])\n</code></pre> <p>See WebviewEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEventType","title":"WindowEventType  <code>module-attribute</code>","text":"<pre><code>WindowEventType = TypeAliasType('WindowEventType', Union[Resized, Moved, CloseRequested, Destroyed, Focused, ScaleFactorChanged, DragDrop, ThemeChanged, _NonExhaustive])\n</code></pre> <p>See WindowEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.ImplManager","title":"ImplManager  <code>module-attribute</code>","text":"<pre><code>ImplManager = TypeAliasType('ImplManager', Union[App, AppHandle, 'WebviewWindow'])\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventId","title":"EventId  <code>module-attribute</code>","text":"<pre><code>EventId = NewType('EventId', int)\n</code></pre> <p>tauri::EventId</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.ImplListener","title":"ImplListener  <code>module-attribute</code>","text":"<pre><code>ImplListener = ImplManager\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.PositionType","title":"PositionType  <code>module-attribute</code>","text":"<pre><code>PositionType = TypeAliasType('PositionType', Union[Physical, Logical])\n</code></pre> <p>See Position for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.SizeType","title":"SizeType  <code>module-attribute</code>","text":"<pre><code>SizeType = TypeAliasType('SizeType', Union[Physical, Logical])\n</code></pre> <p>See Size for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Url","title":"Url  <code>module-attribute</code>","text":"<pre><code>Url = TypeAliasType('Url', str)\n</code></pre> <p>tauri::Url</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.ImplEmitter","title":"ImplEmitter  <code>module-attribute</code>","text":"<pre><code>ImplEmitter = ImplManager\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTargetType","title":"EventTargetType  <code>module-attribute</code>","text":"<pre><code>EventTargetType = TypeAliasType('EventTargetType', Union[Any, AnyLabel, App, Window, Webview, WebviewWindow, _NonExhaustive])\n</code></pre> <p>See EventTarget for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App","title":"App","text":"<p>Tauri::app</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>run</code> <p>Consume and run this app, will block until the app is exited.</p> <code>run_return</code> <p>Consume and run this application, returning its intended exit code.</p> <code>run_iteration</code> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <code>cleanup_before_exit</code> <p>Runs necessary cleanup tasks before exiting the process.</p> <code>handle</code> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.run","title":"run","text":"<pre><code>run(callback: Optional[_AppRunCallbackType] = None) -&gt; NoReturn\n</code></pre> <p>Consume and run this app, will block until the app is exited.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each event. It will be called on the same thread that the app was created on, so you should not block in this function.</p> <code>None</code> <p>Note</p> <p>This function will call <code>std::process::exit</code> at the end to terminate the entire process, which means the Python interpreter cannot be properly finalized. If this is a problem for you, please use pytauri.App.run_return.</p> <p>Warning</p> <p>If <code>callback</code> is specified, it must not raise an exception, otherwise it is logical undefined behavior, and in most cases, the program will panic.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; NoReturn:\n    \"\"\"Consume and run this app, will block until the app is exited.\n\n    Args:\n        callback: a callback function that will be called on each event.\n            It will be called on the same thread that the app was created on,\n            so you should not block in this function.\n\n    !!! note\n        This function will call `std::process::exit` at the end to terminate the entire process,\n        which means the Python interpreter cannot be properly finalized.\n        If this is a problem for you, please use [pytauri.App.run_return][].\n\n    !!! warning\n        If `callback` is specified, it must not raise an exception,\n        otherwise it is logical undefined behavior, and in most cases, the program will panic.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.run(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.run_return","title":"run_return","text":"<pre><code>run_return(callback: Optional[_AppRunCallbackType] = None) -&gt; int\n</code></pre> <p>Consume and run this application, returning its intended exit code.</p> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_return(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; int:\n    \"\"\"Consume and run this application, returning its intended exit code.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.run_iteration","title":"run_iteration  <code>deprecated</code>","text":"<pre><code>run_iteration(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> Deprecated <p>When called in a loop (as suggested by the name), this function will busy-loop.             To re-gain control of control flow after the app has exited, use <code>App::run_return</code> instead.             See https://docs.rs/tauri/latest/tauri/struct.App.html#method.run_iteration for more details.</p> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each iteration.</p> <code>None</code> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> <p>Tip</p> <p>Approximately 2ms per calling in debug mode.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@deprecated(\n    \"\"\"When called in a loop (as suggested by the name), this function will busy-loop.\n    To re-gain control of control flow after the app has exited, use `App::run_return` instead.\n    See &lt;https://docs.rs/tauri/latest/tauri/struct.App.html#method.run_iteration&gt; for more details.\"\"\",\n    category=None,\n)\ndef run_iteration(\n    self, callback: Optional[_AppRunCallbackType] = None, /\n) -&gt; None:\n    \"\"\"Run this app iteratively without consuming it, calling `callback` on each iteration.\n\n    Args:\n        callback: a callback function that will be called on each iteration.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n\n    !!! tip\n        Approximately 2ms per calling in debug mode.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.run_iteration(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.cleanup_before_exit","title":"cleanup_before_exit","text":"<pre><code>cleanup_before_exit() -&gt; None\n</code></pre> <p>Runs necessary cleanup tasks before exiting the process.</p> <p>You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def cleanup_before_exit(self, /) -&gt; None:\n    \"\"\"Runs necessary cleanup tasks before exiting the process.\n\n    **You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.**\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.handle","title":"handle","text":"<pre><code>handle() -&gt; AppHandle\n</code></pre> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def handle(self, /) -&gt; \"AppHandle\":\n    \"\"\"Get a handle to this app, which can be used to interact with the app from another thread.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle","title":"AppHandle","text":"<p>tauri::AppHandle</p> <p>Methods:</p> Name Description <code>run_on_main_thread</code> <p>Runs the given closure on the main thread.</p> <code>exit</code> <code>restart</code> <code>on_menu_event</code> <p>Registers a global menu event listener.</p> <code>on_tray_icon_event</code> <p>Registers a global tray icon menu event listener.</p> <code>tray_by_id</code> <code>remove_tray_by_id</code> <code>set_theme</code> <code>default_window_icon</code> <p>Returns the default window icon.</p> <code>menu</code> <code>set_menu</code> <code>remove_menu</code> <code>hide_menu</code> <code>show_menu</code> <code>invoke_key</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.run_on_main_thread","title":"run_on_main_thread","text":"<pre><code>run_on_main_thread(handler: Callable[[], object]) -&gt; None\n</code></pre> <p>Runs the given closure on the main thread.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_on_main_thread(self, handler: Callable[[], object], /) -&gt; None:\n    \"\"\"Runs the given closure on the main thread.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.exit","title":"exit","text":"<pre><code>exit(exit_code: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def exit(self, exit_code: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.restart","title":"restart","text":"<pre><code>restart() -&gt; Never\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def restart(self, /) -&gt; Never: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[Self, MenuEvent], None]) -&gt; None\n</code></pre> <p>Registers a global menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[\"Self\", \"MenuEvent\"], None], /\n) -&gt; None:\n    \"\"\"Registers a global menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.on_tray_icon_event","title":"on_tray_icon_event","text":"<pre><code>on_tray_icon_event(handler: Callable[[Self, TrayIconEventType], None]) -&gt; None\n</code></pre> <p>Registers a global tray icon menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_tray_icon_event(\n    self, handler: Callable[[Self, TrayIconEventType], None], /\n) -&gt; None:\n    \"\"\"Registers a global tray icon menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.tray_by_id","title":"tray_by_id","text":"<pre><code>tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.remove_tray_by_id","title":"remove_tray_by_id","text":"<pre><code>remove_tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.set_theme","title":"set_theme","text":"<pre><code>set_theme(theme: Optional[Theme]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_theme(self, theme: Optional[\"Theme\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.default_window_icon","title":"default_window_icon","text":"<pre><code>default_window_icon() -&gt; Optional[Image]\n</code></pre> <p>Returns the default window icon.</p> <p>Warning</p> <p>Each time you call this function, a new image instance will be created. So you should cache the result if you need to use it multiple times.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def default_window_icon(self, /) -&gt; Optional[Image]:\n    \"\"\"Returns the default window icon.\n\n    !!! warning\n        Each time you call this function, a new image instance will be created.\n        So you should cache the result if you need to use it multiple times.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.menu","title":"menu","text":"<pre><code>menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Menu) -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_menu(self, menu: Menu, /) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.remove_menu","title":"remove_menu","text":"<pre><code>remove_menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.hide_menu","title":"hide_menu","text":"<pre><code>hide_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def hide_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.show_menu","title":"show_menu","text":"<pre><code>show_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def show_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.invoke_key","title":"invoke_key","text":"<pre><code>invoke_key() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def invoke_key(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Builder","title":"Builder","text":"<p>tauri::Builder</p> <p>use builder_factory to instantiate this class.</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>build</code> <p>tauri::Builder::build</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Builder.build","title":"build","text":"<pre><code>build(context: Context, **kwargs: Unpack[BuilderArgs]) -&gt; App\n</code></pre> <p>tauri::Builder::build</p> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>Context</code> <p>use context_factory to get it.</p> required <code>Unpack[BuilderArgs]</code> <p>see BuilderArgs for details.</p> <code>{}</code> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def build(self, context: \"Context\", **kwargs: Unpack[\"BuilderArgs\"]) -&gt; App:\n    \"\"\"[tauri::Builder::build](https://docs.rs/tauri/latest/tauri/struct.Builder.html#method.build)\n\n    Consume this builder and build an app with the given `BuilderArgs`.\n\n    Args:\n        context: use [context_factory][pytauri.context_factory] to get it.\n        **kwargs: see [BuilderArgs][pytauri.BuilderArgs] for details.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Builder.build(context)","title":"<code>context</code>","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Builder.build(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Context","title":"Context","text":"<p>tauri::Context</p> <p>Methods:</p> Name Description <code>set_assets</code> <p>Use custom assets instead of the assets bundled by Tauri.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Context.set_assets","title":"set_assets","text":"<pre><code>set_assets(assets: Assets) -&gt; None\n</code></pre> <p>Use custom assets instead of the assets bundled by Tauri.</p> <p>To make this work:</p> <ul> <li>You need to enable the <code>tauri/custom-protocol</code> feature.<ul> <li>Or build using <code>tauri build</code>.</li> </ul> </li> <li>Set <code>frontendDist</code> in <code>tauri.conf.json</code> to an empty directory (do not set it to a URL).<ul> <li> <p>Or generate <code>Context</code> via:</p> <pre><code>use tauri::{generate_context, test::noop_assets};\n\nlet context = generate_context!(assets=noop_assets());\n</code></pre> <p>then we will use this method to set the assets.</p> <p>see: https://github.com/tauri-apps/tauri/pull/9141</p> </li> </ul> </li> </ul> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_assets(self, assets: \"Assets\", /) -&gt; None:\n    \"\"\"Use custom assets instead of the assets bundled by Tauri.\n\n    To make this work:\n\n    - You need to enable the `tauri/custom-protocol` feature.\n        - Or build using `tauri build`.\n    - Set `frontendDist` in `tauri.conf.json` to an empty directory (do not set it to a URL).\n        - Or generate `Context` via:\n\n            ```rust\n            use tauri::{generate_context, test::noop_assets};\n\n            let context = generate_context!(assets=noop_assets());\n            ```\n\n            then we will use this method to set the assets.\n\n            see: &lt;https://github.com/tauri-apps/tauri/pull/9141&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent","title":"RunEvent","text":"<p>tauri::RunEvent</p> <p>Classes:</p> Name Description <code>Exit</code> <p>tauri::RunEvent::Exit</p> <code>ExitRequested</code> <p>tauri::RunEvent::ExitRequested</p> <code>WindowEvent</code> <p>tauri::RunEvent::WindowEvent</p> <code>WebviewEvent</code> <p>tauri::RunEvent::WebviewEvent</p> <code>Ready</code> <p>tauri::RunEvent::Ready</p> <code>Resumed</code> <p>tauri::RunEvent::Resumed</p> <code>MainEventsCleared</code> <p>tauri::RunEvent::MainEventsCleared</p> <code>MenuEvent</code> <p>tauri::RunEvent::MenuEvent</p> <code>TrayIconEvent</code> <p>tauri::RunEvent::TrayIconEvent</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.Exit","title":"Exit","text":"<p>tauri::RunEvent::Exit</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.ExitRequested","title":"ExitRequested","text":"<p>tauri::RunEvent::ExitRequested</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>Optional[int]</code> <code>api</code> <code>ExitRequestApi</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.ExitRequested.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Optional[int]\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.ExitRequested.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api: ExitRequestApi\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.WindowEvent","title":"WindowEvent","text":"<p>tauri::RunEvent::WindowEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <code>event</code> <code>WindowEventType</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.WindowEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.WindowEvent.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: WindowEventType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::RunEvent::WebviewEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <code>event</code> <code>WebviewEventType</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.WebviewEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.WebviewEvent.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: WebviewEventType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.Ready","title":"Ready","text":"<p>tauri::RunEvent::Ready</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.Resumed","title":"Resumed","text":"<p>tauri::RunEvent::Resumed</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.MainEventsCleared","title":"MainEventsCleared","text":"<p>tauri::RunEvent::MainEventsCleared</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.MenuEvent","title":"MenuEvent","text":"<p>               Bases: <code>tuple[MenuEvent]</code></p> <p>tauri::RunEvent::MenuEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.MenuEvent.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.MenuEvent.__new__","title":"__new__","text":"<pre><code>__new__(_0: MenuEvent) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: MenuEvent, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.TrayIconEvent","title":"TrayIconEvent","text":"<p>               Bases: <code>tuple[TrayIconEventType]</code></p> <p>tauri::RunEvent::TrayIconEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.TrayIconEvent.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.TrayIconEvent.__new__","title":"__new__","text":"<pre><code>__new__(_0: TrayIconEventType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: TrayIconEventType, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.ExitRequestApi","title":"ExitRequestApi","text":"<p>tauri::ExitRequestApi</p> <p>Methods:</p> Name Description <code>prevent_exit</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.ExitRequestApi.prevent_exit","title":"prevent_exit","text":"<pre><code>prevent_exit() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def prevent_exit(self, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.CloseRequestApi","title":"CloseRequestApi","text":"<p>tauri::CloseRequestApi</p> <p>Methods:</p> Name Description <code>prevent_close</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.CloseRequestApi.prevent_close","title":"prevent_close","text":"<pre><code>prevent_close() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def prevent_close(self, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEvent","title":"DragDropEvent","text":"<p>tauri::DragDropEvent</p> <p>Classes:</p> Name Description <code>Enter</code> <p>tauri::DragDropEvent::Enter</p> <code>Over</code> <p>tauri::DragDropEvent::Over</p> <code>Drop</code> <p>tauri::DragDropEvent::Drop</p> <code>Leave</code> <p>tauri::DragDropEvent::Leave</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEvent.Enter","title":"Enter","text":"<p>tauri::DragDropEvent::Enter</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>_VecPathBuf</code> <code>position</code> <code>_PhysicalPositionF64</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEvent.Enter.paths","title":"paths  <code>instance-attribute</code>","text":"<pre><code>paths: _VecPathBuf\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEvent.Enter.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEvent.Over","title":"Over","text":"<p>tauri::DragDropEvent::Over</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>_PhysicalPositionF64</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEvent.Over.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEvent.Drop","title":"Drop","text":"<p>tauri::DragDropEvent::Drop</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>_VecPathBuf</code> <code>position</code> <code>_PhysicalPositionF64</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEvent.Drop.paths","title":"paths  <code>instance-attribute</code>","text":"<pre><code>paths: _VecPathBuf\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEvent.Drop.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.DragDropEvent.Leave","title":"Leave","text":"<p>tauri::DragDropEvent::Leave</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::WebviewEvent</p> <p>Classes:</p> Name Description <code>DragDrop</code> <p>tauri::WebviewEvent::DragDrop</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WebviewEvent.DragDrop","title":"DragDrop","text":"<p>               Bases: <code>tuple['DragDropEventType']</code></p> <p>tauri::WebviewEvent::DragDrop</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WebviewEvent.DragDrop.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WebviewEvent.DragDrop.__new__","title":"__new__","text":"<pre><code>__new__(_0: DragDropEventType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: \"DragDropEventType\", /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent","title":"WindowEvent","text":"<p>tauri::WindowEvent</p> <p>Classes:</p> Name Description <code>Resized</code> <p>tauri::WindowEvent::Resized</p> <code>Moved</code> <p>tauri::WindowEvent::Moved</p> <code>CloseRequested</code> <p>tauri::WindowEvent::CloseRequested</p> <code>Destroyed</code> <p>tauri::WindowEvent::Destroyed</p> <code>Focused</code> <p>tauri::WindowEvent::Focused</p> <code>ScaleFactorChanged</code> <p>tauri::WindowEvent::ScaleFactorChanged</p> <code>DragDrop</code> <p>tauri::WindowEvent::DragDrop</p> <code>ThemeChanged</code> <p>tauri::WindowEvent::ThemeChanged</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.Resized","title":"Resized","text":"<p>               Bases: <code>tuple[_PhysicalSizeU32]</code></p> <p>tauri::WindowEvent::Resized</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.Resized.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.Resized.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalSizeU32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalSizeU32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.Moved","title":"Moved","text":"<p>               Bases: <code>tuple[_PhysicalPositionI32]</code></p> <p>tauri::WindowEvent::Moved</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.Moved.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.Moved.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalPositionI32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalPositionI32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.CloseRequested","title":"CloseRequested","text":"<p>tauri::WindowEvent::CloseRequested</p> <p>Attributes:</p> Name Type Description <code>api</code> <code>CloseRequestApi</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.CloseRequested.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api: CloseRequestApi\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.Destroyed","title":"Destroyed","text":"<p>tauri::WindowEvent::Destroyed</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.Focused","title":"Focused","text":"<p>               Bases: <code>tuple[bool]</code></p> <p>tauri::WindowEvent::Focused</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.Focused.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.Focused.__new__","title":"__new__","text":"<pre><code>__new__(_0: bool) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: bool, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.ScaleFactorChanged","title":"ScaleFactorChanged","text":"<p>tauri::WindowEvent::ScaleFactorChanged</p> <p>Attributes:</p> Name Type Description <code>scale_factor</code> <code>float</code> <code>new_inner_size</code> <code>_PhysicalSizeU32</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.ScaleFactorChanged.scale_factor","title":"scale_factor  <code>instance-attribute</code>","text":"<pre><code>scale_factor: float\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.ScaleFactorChanged.new_inner_size","title":"new_inner_size  <code>instance-attribute</code>","text":"<pre><code>new_inner_size: _PhysicalSizeU32\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.DragDrop","title":"DragDrop","text":"<p>               Bases: <code>tuple['DragDropEventType']</code></p> <p>tauri::WindowEvent::DragDrop</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.DragDrop.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.DragDrop.__new__","title":"__new__","text":"<pre><code>__new__(_0: DragDropEventType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: \"DragDropEventType\", /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.ThemeChanged","title":"ThemeChanged","text":"<p>               Bases: <code>tuple['Theme']</code></p> <p>tauri::WindowEvent::ThemeChanged</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.ThemeChanged.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.WindowEvent.ThemeChanged.__new__","title":"__new__","text":"<pre><code>__new__(_0: Theme) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: \"Theme\", /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Manager","title":"Manager","text":"<p>tauri::Manager</p> <p>Methods:</p> Name Description <code>app_handle</code> <p>The application handle associated with this manager.</p> <code>get_webview_window</code> <p>Fetch a single webview window from the manager.</p> <code>webview_windows</code> <p>Fetch all managed webview windows.</p> <code>path</code> <p>The path resolver is a helper class for general and application-specific path APIs.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Manager.app_handle","title":"app_handle  <code>staticmethod</code>","text":"<pre><code>app_handle(slf: ImplManager) -&gt; AppHandle\n</code></pre> <p>The application handle associated with this manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef app_handle(slf: \"ImplManager\", /) -&gt; AppHandle:\n    \"\"\"The application handle associated with this manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Manager.get_webview_window","title":"get_webview_window  <code>staticmethod</code>","text":"<pre><code>get_webview_window(slf: ImplManager, label: str) -&gt; Optional[WebviewWindow]\n</code></pre> <p>Fetch a single webview window from the manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef get_webview_window(\n    slf: \"ImplManager\", label: str, /\n) -&gt; Optional[WebviewWindow]:\n    \"\"\"Fetch a single webview window from the manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Manager.webview_windows","title":"webview_windows  <code>staticmethod</code>","text":"<pre><code>webview_windows(slf: ImplManager) -&gt; dict[str, WebviewWindow]\n</code></pre> <p>Fetch all managed webview windows.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef webview_windows(slf: \"ImplManager\", /) -&gt; dict[str, WebviewWindow]:\n    \"\"\"Fetch all managed webview windows.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Manager.path","title":"path  <code>staticmethod</code>","text":"<pre><code>path(slf: ImplManager) -&gt; PathResolver\n</code></pre> <p>The path resolver is a helper class for general and application-specific path APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef path(slf: \"ImplManager\", /) -&gt; PathResolver:\n    \"\"\"The path resolver is a helper class for general and application-specific path APIs.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Event","title":"Event","text":"<p>tauri::Event</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>EventId</code> <p>The <code>EventId</code> of the handler that was triggered.</p> <code>payload</code> <code>str</code> <p>The event payload.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Event.id","title":"id  <code>property</code>","text":"<pre><code>id: EventId\n</code></pre> <p>The <code>EventId</code> of the handler that was triggered.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Event.payload","title":"payload  <code>property</code>","text":"<pre><code>payload: str\n</code></pre> <p>The event payload.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener","title":"Listener","text":"<p>tauri::Listener</p> <p>See also: https://tauri.app/develop/calling-rust/#event-system</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener--examples","title":"Examples","text":"<pre><code>from pydantic import BaseModel\nfrom pytauri import AppHandle, Event, Listener\n\n\nclass Payload(BaseModel):  # or `RootModel`\n    url: str\n    num: int\n\n\ndef listen(app_handle: AppHandle) -&gt; None:\n    def handler(event: Event):\n        assert event.id == event_id\n\n        serialized_event = Payload.model_validate_json(event.payload)\n        print(serialized_event.url, serialized_event.num)\n\n    event_id = Listener.listen(app_handle, \"event_name\", handler)\n</code></pre> <p>Methods:</p> Name Description <code>listen</code> <p>Listen to an emitted event on this manager.</p> <code>once</code> <p>Listen to an event on this manager only once.</p> <code>unlisten</code> <p>Remove an event listener.</p> <code>listen_any</code> <p>Listen to an emitted event to any target.</p> <code>once_any</code> <p>Listens once to an emitted event to any target .</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener.listen","title":"listen  <code>staticmethod</code>","text":"<pre><code>listen(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event on this manager.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event on this manager.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener.once","title":"once  <code>staticmethod</code>","text":"<pre><code>once(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an event on this manager only once.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an event on this manager only once.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener.unlisten","title":"unlisten  <code>staticmethod</code>","text":"<pre><code>unlisten(slf: ImplListener, id: EventId) -&gt; None\n</code></pre> <p>Remove an event listener.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef unlisten(\n    slf: \"ImplListener\",\n    id: \"EventId\",  # noqa: A002\n    /,\n) -&gt; None:\n    \"\"\"Remove an event listener.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener.listen_any","title":"listen_any  <code>staticmethod</code>","text":"<pre><code>listen_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event to any target.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event to any target.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener.once_any","title":"once_any  <code>staticmethod</code>","text":"<pre><code>once_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listens once to an emitted event to any target .</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listens once to an emitted event to any target .\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Position","title":"Position","text":"<p>tauri::Position</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Position::Physical</p> <code>Logical</code> <p>tauri::Position::Logical</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Position.Physical","title":"Physical","text":"<p>               Bases: <code>tuple[_PhysicalPositionI32]</code></p> <p>tauri::Position::Physical</p> <p>Warning</p> <p>This is actually a <code>Class</code> disguised as an <code>NamedTuple</code>. See also: https://pyo3.rs/v0.23.4/class.html#pyclass-enums.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Position.Physical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Position.Physical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalPositionI32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalPositionI32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Position.Logical","title":"Logical","text":"<p>               Bases: <code>tuple[_LogicalPositionF64]</code></p> <p>tauri::Position::Logical</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Position.Logical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Position.Logical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _LogicalPositionF64) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _LogicalPositionF64, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Size","title":"Size","text":"<p>tauri::Size</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Size::Physical</p> <code>Logical</code> <p>tauri::Size::Logical</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Size.Physical","title":"Physical","text":"<p>               Bases: <code>tuple[_PhysicalSizeU32]</code></p> <p>tauri::Size::Physical</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Size.Physical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Size.Physical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _PhysicalSizeU32) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _PhysicalSizeU32, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Size.Logical","title":"Logical","text":"<p>               Bases: <code>tuple[_LogicalSizeF64]</code></p> <p>tauri::Size::Logical</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Size.Logical.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Size.Logical.__new__","title":"__new__","text":"<pre><code>__new__(_0: _LogicalSizeF64) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, _0: _LogicalSizeF64, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Rect","title":"Rect","text":"<p>tauri::Rect</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>position</code> <code>PositionType</code> <code>size</code> <code>SizeType</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Rect.position","title":"position  <code>property</code>","text":"<pre><code>position: PositionType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Rect.size","title":"size  <code>property</code>","text":"<pre><code>size: SizeType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Rect.__new__","title":"__new__","text":"<pre><code>__new__(*, position: PositionType, size: SizeType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    position: \"PositionType\",\n    size: \"SizeType\",\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget","title":"EventTarget","text":"<p>tauri::EventTarget</p> <p>Classes:</p> Name Description <code>Any</code> <p>Any and all event targets.</p> <code>AnyLabel</code> <p>Any <code>Window</code>, <code>Webview</code> or <code>WebviewWindow</code> that have this label.</p> <code>App</code> <p>App and AppHandle targets.</p> <code>Window</code> <p><code>Window</code> target.</p> <code>Webview</code> <p>Webview target.</p> <code>WebviewWindow</code> <p>WebviewWindow target.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.Any","title":"Any","text":"<p>Any and all event targets.</p> <p>Methods:</p> Name Description <code>__new__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.Any.__new__","title":"__new__","text":"<pre><code>__new__() -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.AnyLabel","title":"AnyLabel","text":"<p>Any <code>Window</code>, <code>Webview</code> or <code>WebviewWindow</code> that have this label.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Target label.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.AnyLabel.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>Target label.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.AnyLabel.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.App","title":"App","text":"<p>App and AppHandle targets.</p> <p>Methods:</p> Name Description <code>__new__</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.App.__new__","title":"__new__","text":"<pre><code>__new__() -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.Window","title":"Window","text":"<p><code>Window</code> target.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>window label.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.Window.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>window label.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.Window.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.Webview","title":"Webview","text":"<p>Webview target.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>webview label.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.Webview.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>webview label.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.Webview.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.WebviewWindow","title":"WebviewWindow","text":"<p>WebviewWindow target.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>webview window label.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.WebviewWindow.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre> <p>webview window label.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventTarget.WebviewWindow.__new__","title":"__new__","text":"<pre><code>__new__(label: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(cls, label: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Emitter","title":"Emitter","text":"<p>tauri::Emitter</p> <p>Methods:</p> Name Description <code>emit_str</code> <p>Similar to [<code>Emitter::emit</code>] but the payload is json serialized.</p> <code>emit_str_to</code> <p>Similar to [<code>Emitter::emit_to</code>] but the payload is json serialized.</p> <code>emit_str_filter</code> <p>Similar to [<code>Emitter::emit_filter</code>] but the payload is json serialized.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Emitter.emit_str","title":"emit_str  <code>staticmethod</code>","text":"<pre><code>emit_str(slf: ImplEmitter, event: str, payload: str) -&gt; None\n</code></pre> <p>Similar to [<code>Emitter::emit</code>] but the payload is json serialized.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef emit_str(\n    slf: \"ImplEmitter\",\n    event: str,\n    payload: str,\n    /,\n) -&gt; None:\n    \"\"\"Similar to [`Emitter::emit`] but the payload is json serialized.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Emitter.emit_str_to","title":"emit_str_to  <code>staticmethod</code>","text":"<pre><code>emit_str_to(slf: ImplEmitter, target: EventTargetType, event: str, payload: str) -&gt; None\n</code></pre> <p>Similar to [<code>Emitter::emit_to</code>] but the payload is json serialized.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef emit_str_to(\n    slf: \"ImplEmitter\",\n    target: \"EventTargetType\",\n    event: str,\n    payload: str,\n    /,\n) -&gt; None:\n    \"\"\"Similar to [`Emitter::emit_to`] but the payload is json serialized.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Emitter.emit_str_filter","title":"emit_str_filter  <code>staticmethod</code>","text":"<pre><code>emit_str_filter(slf: ImplEmitter, event: str, payload: str, filter: Callable[[EventTargetType], bool]) -&gt; None\n</code></pre> <p>Similar to [<code>Emitter::emit_filter</code>] but the payload is json serialized.</p> <p>Warning</p> <p><code>filter</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef emit_str_filter(\n    slf: \"ImplEmitter\",\n    event: str,\n    payload: str,\n    filter: Callable[[\"EventTargetType\"], bool],  # noqa: A002\n    /,\n) -&gt; None:\n    \"\"\"Similar to [`Emitter::emit_filter`] but the payload is json serialized.\n\n    !!! warning\n        `filter` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Theme","title":"Theme","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::Theme</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Light</code> <code>Dark</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Theme.Light","title":"Light  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Light = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Theme.Dark","title":"Dark  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Dark = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs","title":"BuilderArgs","text":"<p>               Bases: <code>TypedDict</code></p> <p>tauri::Builder</p> <p>Attributes:</p> Name Type Description <code>invoke_handler</code> <code>Required[Optional[_InvokeHandlerProto]]</code> <p>Use Commands to get it.</p> <code>setup</code> <code>Callable[[AppHandle], object]</code> <p>See rust <code>tauri::Builder::setup</code></p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs.invoke_handler","title":"invoke_handler  <code>instance-attribute</code>","text":"<pre><code>invoke_handler: Required[Optional[_InvokeHandlerProto]]\n</code></pre> <p>Use Commands to get it.</p> <p>Warning</p> <p>The implement of <code>invoke_handler</code> must never raise an exception, otherwise it is considered logical undefined behavior. Additionally, <code>invoke_handler</code> must not block.</p> <p>Warning</p> <p>If you do not specify <code>invoke_handler</code>, <code>pytauri</code> will not register the <code>tauri-plugin-pytauri</code> plugin, which means you cannot use <code>pyInvoke</code> in the frontend to call <code>Commands</code> (you will receive an error like \"plugin pytauri not found\"). If this is indeed the behavior you expect, explicitly pass None.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs.setup","title":"setup  <code>instance-attribute</code>","text":"<pre><code>setup: Callable[[AppHandle], object]\n</code></pre> <p>See rust <code>tauri::Builder::setup</code></p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Assets","title":"Assets","text":"<p>               Bases: <code>ABC</code></p> <p>tauri::Assets</p> <p>This is an abstract class that you can subclass to implement a custom asset loader.</p> <p>See <code>tauri::Assets</code> rust docs for more details.</p> <p>Warning</p> <p>The implement has the same restrictions as App.run.</p> <p>Methods:</p> Name Description <code>get</code> <code>iter</code> <code>setup</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Assets.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key: _AssetKey) -&gt; Optional[bytes]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef get(self, key: _AssetKey, /) -&gt; Optional[bytes]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Assets.iter","title":"iter  <code>abstractmethod</code>","text":"<pre><code>iter() -&gt; Iterator[tuple[str, bytes]]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef iter(self, /) -&gt; Iterator[tuple[str, bytes]]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Assets.setup","title":"setup","text":"<pre><code>setup(_app: AppHandle) -&gt; object\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def setup(self, _app: AppHandle, /) -&gt; object:\n    return None\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.builder_factory","title":"builder_factory","text":"<pre><code>builder_factory(*args: Any, **kwargs: Any) -&gt; Builder\n</code></pre> <p>A factory function for creating a <code>Builder</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def builder_factory(*args: Any, **kwargs: Any) -&gt; Builder:\n    \"\"\"A factory function for creating a `Builder` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.context_factory","title":"context_factory","text":"<pre><code>context_factory(*args: Any, **kwargs: Any) -&gt; Context\n</code></pre> <p>A factory function for creating a <code>Context</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def context_factory(*args: Any, **kwargs: Any) -&gt; Context:\n    \"\"\"A factory function for creating a `Context` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/","title":"menu","text":""},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu","title":"pytauri.ffi.menu","text":"<p>tauri::menu</p> <p>Classes:</p> Name Description <code>Menu</code> <p>tauri::menu::Menu</p> <code>MenuItem</code> <p>tauri::menu::MenuItem</p> <code>Submenu</code> <p>tauri::menu::Submenu</p> <code>PredefinedMenuItem</code> <p>tauri::menu::PredefinedMenuItem</p> <code>CheckMenuItem</code> <p>tauri::menu::CheckMenuItem</p> <code>AboutMetadata</code> <p>tauri::menu::AboutMetadata</p> <code>IconMenuItem</code> <p>tauri::menu::IconMenuItem</p> <code>NativeIcon</code> <p>tauri::menu::NativeIcon</p> <code>ContextMenu</code> <p>tauri::menu::ContextMenu</p> <p>Attributes:</p> Name Type Description <code>MenuID</code> <p>tauri::menu::MenuID</p> <code>MenuEvent</code> <p>tauri::menu::MenuEvent</p> <code>HELP_SUBMENU_ID</code> <code>LiteralString</code> <p>tauri::menu::HELP_SUBMENU_ID</p> <code>WINDOW_SUBMENU_ID</code> <code>LiteralString</code> <p>tauri::menu::WINDOW_SUBMENU_ID</p> <code>MenuItemKind</code> <p>tauri::menu::MenuItemKind</p> <code>ImplContextMenu</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['HELP_SUBMENU_ID', 'WINDOW_SUBMENU_ID', 'AboutMetadata', 'CheckMenuItem', 'ContextMenu', 'IconMenuItem', 'ImplContextMenu', 'Menu', 'MenuEvent', 'MenuID', 'MenuItem', 'MenuItemKind', 'NativeIcon', 'PredefinedMenuItem', 'Submenu']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuID","title":"MenuID  <code>module-attribute</code>","text":"<pre><code>MenuID = TypeAliasType('MenuID', str)\n</code></pre> <p>tauri::menu::MenuID</p>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuEvent","title":"MenuEvent  <code>module-attribute</code>","text":"<pre><code>MenuEvent = TypeAliasType('MenuEvent', MenuID)\n</code></pre> <p>tauri::menu::MenuEvent</p>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.HELP_SUBMENU_ID","title":"HELP_SUBMENU_ID  <code>module-attribute</code>","text":"<pre><code>HELP_SUBMENU_ID: LiteralString\n</code></pre> <p>tauri::menu::HELP_SUBMENU_ID</p>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.WINDOW_SUBMENU_ID","title":"WINDOW_SUBMENU_ID  <code>module-attribute</code>","text":"<pre><code>WINDOW_SUBMENU_ID: LiteralString\n</code></pre> <p>tauri::menu::WINDOW_SUBMENU_ID</p>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItemKind","title":"MenuItemKind  <code>module-attribute</code>","text":"<pre><code>MenuItemKind = TypeAliasType('MenuItemKind', Union[MenuItem, Submenu, PredefinedMenuItem, CheckMenuItem, IconMenuItem])\n</code></pre> <p>tauri::menu::MenuItemKind</p>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.ImplContextMenu","title":"ImplContextMenu  <code>module-attribute</code>","text":"<pre><code>ImplContextMenu = TypeAliasType('ImplContextMenu', Union[Menu, Submenu])\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu","title":"Menu","text":"<p>tauri::menu::Menu</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_items</code> <code>with_id_and_items</code> <code>default</code> <code>app_handle</code> <code>id</code> <code>append</code> <code>append_items</code> <code>prepend</code> <code>prepend_items</code> <code>insert</code> <code>insert_items</code> <code>remove</code> <code>remove_at</code> <code>get</code> <code>items</code> <code>set_as_app_menu</code> <code>set_as_window_menu</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(cls, manager: ImplManager, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(manager: ImplManager, id: MenuID, /) -&gt; \"Menu\": ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.with_items","title":"with_items  <code>staticmethod</code>","text":"<pre><code>with_items(manager: ImplManager, items: Sequence[MenuItemKind]) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_items(\n    manager: ImplManager, items: Sequence[\"MenuItemKind\"], /\n) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.with_id_and_items","title":"with_id_and_items  <code>staticmethod</code>","text":"<pre><code>with_id_and_items(manager: ImplManager, id: MenuID, items: Sequence[MenuItemKind]) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_items(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.default","title":"default  <code>staticmethod</code>","text":"<pre><code>default(app_handle: AppHandle) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef default(app_handle: AppHandle, /) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.append","title":"append","text":"<pre><code>append(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.append_items","title":"append_items","text":"<pre><code>append_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.prepend","title":"prepend","text":"<pre><code>prepend(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.prepend_items","title":"prepend_items","text":"<pre><code>prepend_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.insert","title":"insert","text":"<pre><code>insert(item: MenuItemKind, position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert(self, item: \"MenuItemKind\", position: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.insert_items","title":"insert_items","text":"<pre><code>insert_items(items: Sequence[MenuItemKind], position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert_items(\n    self, items: Sequence[\"MenuItemKind\"], position: int, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.remove","title":"remove","text":"<pre><code>remove(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.remove_at","title":"remove_at","text":"<pre><code>remove_at(position: int) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove_at(self, position: int, /) -&gt; Optional[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.get","title":"get","text":"<pre><code>get(id: MenuID) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def get(self, id: MenuID, /) -&gt; Optional[\"MenuItemKind\"]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.items","title":"items","text":"<pre><code>items() -&gt; list[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def items(self, /) -&gt; list[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.set_as_app_menu","title":"set_as_app_menu","text":"<pre><code>set_as_app_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_as_app_menu(self, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.set_as_window_menu","title":"set_as_window_menu","text":"<pre><code>set_as_window_menu(window: Window) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_as_window_menu(self, window: Window, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem","title":"MenuItem","text":"<p>tauri::menu::MenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, accelerator: Optional[str] = None) -&gt; MenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"MenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu","title":"Submenu","text":"<p>tauri::menu::Submenu</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_items</code> <code>with_id_and_items</code> <code>app_handle</code> <code>id</code> <code>append</code> <code>append_items</code> <code>prepend</code> <code>prepend_items</code> <code>insert</code> <code>insert_items</code> <code>remove</code> <code>remove_at</code> <code>get</code> <code>items</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(cls, manager: ImplManager, text: str, enabled: bool, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.with_items","title":"with_items  <code>staticmethod</code>","text":"<pre><code>with_items(manager: ImplManager, text: str, enabled: bool, items: Sequence[MenuItemKind]) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_items(\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.with_id_and_items","title":"with_id_and_items  <code>staticmethod</code>","text":"<pre><code>with_id_and_items(manager: ImplManager, id: MenuID, text: str, enabled: bool, items: Sequence[MenuItemKind]) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_items(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.append","title":"append","text":"<pre><code>append(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.append_items","title":"append_items","text":"<pre><code>append_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.prepend","title":"prepend","text":"<pre><code>prepend(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.prepend_items","title":"prepend_items","text":"<pre><code>prepend_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.insert","title":"insert","text":"<pre><code>insert(item: MenuItemKind, position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert(self, item: \"MenuItemKind\", position: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.insert_items","title":"insert_items","text":"<pre><code>insert_items(items: Sequence[MenuItemKind], position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert_items(\n    self, items: Sequence[\"MenuItemKind\"], position: int, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.remove","title":"remove","text":"<pre><code>remove(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.remove_at","title":"remove_at","text":"<pre><code>remove_at(position: int) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove_at(self, position: int, /) -&gt; Optional[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.get","title":"get","text":"<pre><code>get(id: MenuID) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def get(self, id: MenuID, /) -&gt; Optional[\"MenuItemKind\"]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.items","title":"items","text":"<pre><code>items() -&gt; list[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def items(self, /) -&gt; list[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem","title":"PredefinedMenuItem","text":"<p>tauri::menu::PredefinedMenuItem</p> <p>Methods:</p> Name Description <code>separator</code> <code>copy</code> <code>cut</code> <code>paste</code> <code>select_all</code> <code>undo</code> <code>redo</code> <code>minimize</code> <code>maximize</code> <code>fullscreen</code> <code>hide</code> <code>hide_others</code> <code>show_all</code> <code>close_window</code> <code>quit</code> <code>about</code> <code>services</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.separator","title":"separator  <code>staticmethod</code>","text":"<pre><code>separator(manager: ImplManager) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef separator(manager: ImplManager, /) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.copy","title":"copy  <code>staticmethod</code>","text":"<pre><code>copy(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef copy(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.cut","title":"cut  <code>staticmethod</code>","text":"<pre><code>cut(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef cut(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.paste","title":"paste  <code>staticmethod</code>","text":"<pre><code>paste(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef paste(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.select_all","title":"select_all  <code>staticmethod</code>","text":"<pre><code>select_all(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef select_all(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.undo","title":"undo  <code>staticmethod</code>","text":"<pre><code>undo(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef undo(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.redo","title":"redo  <code>staticmethod</code>","text":"<pre><code>redo(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef redo(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.minimize","title":"minimize  <code>staticmethod</code>","text":"<pre><code>minimize(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef minimize(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.maximize","title":"maximize  <code>staticmethod</code>","text":"<pre><code>maximize(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef maximize(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.fullscreen","title":"fullscreen  <code>staticmethod</code>","text":"<pre><code>fullscreen(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef fullscreen(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.hide","title":"hide  <code>staticmethod</code>","text":"<pre><code>hide(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef hide(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.hide_others","title":"hide_others  <code>staticmethod</code>","text":"<pre><code>hide_others(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef hide_others(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.show_all","title":"show_all  <code>staticmethod</code>","text":"<pre><code>show_all(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef show_all(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.close_window","title":"close_window  <code>staticmethod</code>","text":"<pre><code>close_window(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef close_window(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.quit","title":"quit  <code>staticmethod</code>","text":"<pre><code>quit(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef quit(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.about","title":"about  <code>staticmethod</code>","text":"<pre><code>about(manager: ImplManager, text: Optional[str] = None, metadata: Optional[AboutMetadata] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef about(\n    manager: ImplManager,\n    text: Optional[str] = None,\n    metadata: Optional[\"AboutMetadata\"] = None,\n    /,\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.services","title":"services  <code>staticmethod</code>","text":"<pre><code>services(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef services(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem","title":"CheckMenuItem","text":"<p>tauri::menu::CheckMenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code> <code>is_checked</code> <code>set_checked</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, checked: bool, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    checked: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, checked: bool, accelerator: Optional[str] = None) -&gt; CheckMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    checked: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"CheckMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.is_checked","title":"is_checked","text":"<pre><code>is_checked() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_checked(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.set_checked","title":"set_checked","text":"<pre><code>set_checked(checked: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_checked(self, checked: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.AboutMetadata","title":"AboutMetadata","text":"<p>tauri::menu::AboutMetadata</p> <p>Methods:</p> Name Description <code>__new__</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.AboutMetadata.__new__","title":"__new__","text":"<pre><code>__new__(*, name: Optional[str] = None, version: Optional[str] = None, short_version: Optional[str] = None, authors: Optional[Sequence[str]] = None, comments: Optional[str] = None, copyright: Optional[str] = None, license: Optional[str] = None, website: Optional[str] = None, website_label: Optional[str] = None, credits: Optional[str] = None, icon: Optional[Image] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    name: Optional[str] = None,\n    version: Optional[str] = None,\n    short_version: Optional[str] = None,\n    authors: Optional[Sequence[str]] = None,\n    comments: Optional[str] = None,\n    copyright: Optional[str] = None,  # noqa: A002\n    license: Optional[str] = None,  # noqa: A002\n    website: Optional[str] = None,\n    website_label: Optional[str] = None,\n    credits: Optional[str] = None,  # noqa: A002\n    icon: Optional[\"Image\"] = None,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem","title":"IconMenuItem","text":"<p>tauri::menu::IconMenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_native_icon</code> <code>with_id_and_native_icon</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code> <code>set_icon</code> <code>set_native_icon</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, icon: Optional[Image] = None, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    icon: Optional[\"Image\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, icon: Optional[Image] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    icon: Optional[\"Image\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.with_native_icon","title":"with_native_icon  <code>staticmethod</code>","text":"<pre><code>with_native_icon(manager: ImplManager, text: str, enabled: bool, native_icon: Optional[NativeIcon] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_native_icon(\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    native_icon: Optional[\"NativeIcon\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.with_id_and_native_icon","title":"with_id_and_native_icon  <code>staticmethod</code>","text":"<pre><code>with_id_and_native_icon(manager: ImplManager, id: MenuID, text: str, enabled: bool, native_icon: Optional[NativeIcon] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_native_icon(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    native_icon: Optional[\"NativeIcon\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Optional[Image]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_icon(self, icon: Optional[\"Image\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.set_native_icon","title":"set_native_icon","text":"<pre><code>set_native_icon(native_icon: Optional[NativeIcon]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_native_icon(self, native_icon: Optional[\"NativeIcon\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon","title":"NativeIcon","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::menu::NativeIcon</p> <p>Warning</p> <p>This is actually a <code>Class</code> disguised as an <code>Enum</code>. The order of fields is not guaranteed. See also: https://pyo3.rs/v0.23.4/class.html#pyclass-enums.</p> <p>Attributes:</p> Name Type Description <code>Add</code> <code>Advanced</code> <code>Bluetooth</code> <code>Bookmarks</code> <code>Caution</code> <code>ColorPanel</code> <code>ColumnView</code> <code>Computer</code> <code>EnterFullScreen</code> <code>Everyone</code> <code>ExitFullScreen</code> <code>FlowView</code> <code>Folder</code> <code>FolderBurnable</code> <code>FolderSmart</code> <code>FollowLinkFreestanding</code> <code>FontPanel</code> <code>GoLeft</code> <code>GoRight</code> <code>Home</code> <code>IChatTheater</code> <code>IconView</code> <code>Info</code> <code>InvalidDataFreestanding</code> <code>LeftFacingTriangle</code> <code>ListView</code> <code>LockLocked</code> <code>LockUnlocked</code> <code>MenuMixedState</code> <code>MenuOnState</code> <code>MobileMe</code> <code>MultipleDocuments</code> <code>Network</code> <code>Path</code> <code>PreferencesGeneral</code> <code>QuickLook</code> <code>RefreshFreestanding</code> <code>Refresh</code> <code>Remove</code> <code>RevealFreestanding</code> <code>RightFacingTriangle</code> <code>Share</code> <code>Slideshow</code> <code>SmartBadge</code> <code>StatusAvailable</code> <code>StatusNone</code> <code>StatusPartiallyAvailable</code> <code>StatusUnavailable</code> <code>StopProgressFreestanding</code> <code>StopProgress</code> <code>TrashEmpty</code> <code>TrashFull</code> <code>User</code> <code>UserAccounts</code> <code>UserGroup</code> <code>UserGuest</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Add","title":"Add  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Add = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Advanced","title":"Advanced  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Advanced = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Bluetooth","title":"Bluetooth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Bluetooth = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Bookmarks","title":"Bookmarks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Bookmarks = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Caution","title":"Caution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Caution = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.ColorPanel","title":"ColorPanel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ColorPanel = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.ColumnView","title":"ColumnView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ColumnView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Computer","title":"Computer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Computer = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.EnterFullScreen","title":"EnterFullScreen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EnterFullScreen = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Everyone","title":"Everyone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Everyone = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.ExitFullScreen","title":"ExitFullScreen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ExitFullScreen = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.FlowView","title":"FlowView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FlowView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Folder","title":"Folder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Folder = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.FolderBurnable","title":"FolderBurnable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FolderBurnable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.FolderSmart","title":"FolderSmart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FolderSmart = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.FollowLinkFreestanding","title":"FollowLinkFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FollowLinkFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.FontPanel","title":"FontPanel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FontPanel = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.GoLeft","title":"GoLeft  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GoLeft = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.GoRight","title":"GoRight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GoRight = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Home","title":"Home  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Home = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.IChatTheater","title":"IChatTheater  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IChatTheater = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.IconView","title":"IconView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IconView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Info","title":"Info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Info = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.InvalidDataFreestanding","title":"InvalidDataFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>InvalidDataFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.LeftFacingTriangle","title":"LeftFacingTriangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LeftFacingTriangle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.ListView","title":"ListView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ListView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.LockLocked","title":"LockLocked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LockLocked = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.LockUnlocked","title":"LockUnlocked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LockUnlocked = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.MenuMixedState","title":"MenuMixedState  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MenuMixedState = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.MenuOnState","title":"MenuOnState  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MenuOnState = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.MobileMe","title":"MobileMe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MobileMe = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.MultipleDocuments","title":"MultipleDocuments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MultipleDocuments = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Network","title":"Network  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Network = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Path","title":"Path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Path = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.PreferencesGeneral","title":"PreferencesGeneral  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PreferencesGeneral = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.QuickLook","title":"QuickLook  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QuickLook = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.RefreshFreestanding","title":"RefreshFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RefreshFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Refresh","title":"Refresh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Refresh = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Remove","title":"Remove  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Remove = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.RevealFreestanding","title":"RevealFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RevealFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.RightFacingTriangle","title":"RightFacingTriangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RightFacingTriangle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Share","title":"Share  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Share = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Slideshow","title":"Slideshow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Slideshow = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.SmartBadge","title":"SmartBadge  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SmartBadge = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StatusAvailable","title":"StatusAvailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusAvailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StatusNone","title":"StatusNone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusNone = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StatusPartiallyAvailable","title":"StatusPartiallyAvailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusPartiallyAvailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StatusUnavailable","title":"StatusUnavailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusUnavailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StopProgressFreestanding","title":"StopProgressFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StopProgressFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StopProgress","title":"StopProgress  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StopProgress = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.TrashEmpty","title":"TrashEmpty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TrashEmpty = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.TrashFull","title":"TrashFull  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TrashFull = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.User","title":"User  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>User = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.UserAccounts","title":"UserAccounts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserAccounts = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.UserGroup","title":"UserGroup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserGroup = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.UserGuest","title":"UserGuest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserGuest = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.ContextMenu","title":"ContextMenu","text":"<p>tauri::menu::ContextMenu</p> <p>Methods:</p> Name Description <code>popup</code> <code>popup_at</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.ContextMenu.popup","title":"popup  <code>staticmethod</code>","text":"<pre><code>popup(slf: ImplContextMenu, window: Window) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef popup(slf: \"ImplContextMenu\", window: Window, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.ContextMenu.popup_at","title":"popup_at  <code>staticmethod</code>","text":"<pre><code>popup_at(slf: ImplContextMenu, window: Window, position: PositionType) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef popup_at(\n    slf: \"ImplContextMenu\", window: Window, position: PositionType, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/","title":"path","text":""},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path","title":"pytauri.ffi.path","text":"<p>tauri::path</p> <p>Classes:</p> Name Description <code>PathResolver</code> <p>tauri::path::PathResolver</p>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['PathResolver']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver","title":"PathResolver","text":"<p>tauri::path::PathResolver</p>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver--examples","title":"Examples","text":"<pre><code>from pathlib import Path\nfrom typing import Union\n\nfrom pytauri import App, AppHandle, Manager\nfrom pytauri.path import PathResolver\nfrom pytauri.webview import WebviewWindow\n\n\ndef get_resource_dir(manager: Union[App, AppHandle, WebviewWindow]) -&gt; Path:\n    path_resolver: PathResolver = Manager.path(manager)\n    return path_resolver.resource_dir()\n</code></pre> <p>Methods:</p> Name Description <code>audio_dir</code> <code>cache_dir</code> <code>config_dir</code> <code>data_dir</code> <code>local_data_dir</code> <code>desktop_dir</code> <code>document_dir</code> <code>download_dir</code> <code>executable_dir</code> <code>font_dir</code> <code>home_dir</code> <code>picture_dir</code> <code>public_dir</code> <code>runtime_dir</code> <code>template_dir</code> <code>video_dir</code> <code>resource_dir</code> <code>app_config_dir</code> <code>app_data_dir</code> <code>app_local_data_dir</code> <code>app_cache_dir</code> <code>app_log_dir</code> <code>temp_dir</code>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.audio_dir","title":"audio_dir","text":"<pre><code>audio_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def audio_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.cache_dir","title":"cache_dir","text":"<pre><code>cache_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def cache_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.config_dir","title":"config_dir","text":"<pre><code>config_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def config_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.data_dir","title":"data_dir","text":"<pre><code>data_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def data_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.local_data_dir","title":"local_data_dir","text":"<pre><code>local_data_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def local_data_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.desktop_dir","title":"desktop_dir","text":"<pre><code>desktop_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def desktop_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.document_dir","title":"document_dir","text":"<pre><code>document_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def document_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.download_dir","title":"download_dir","text":"<pre><code>download_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def download_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.executable_dir","title":"executable_dir","text":"<pre><code>executable_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def executable_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.font_dir","title":"font_dir","text":"<pre><code>font_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def font_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.home_dir","title":"home_dir","text":"<pre><code>home_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def home_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.picture_dir","title":"picture_dir","text":"<pre><code>picture_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def picture_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.public_dir","title":"public_dir","text":"<pre><code>public_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def public_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.runtime_dir","title":"runtime_dir","text":"<pre><code>runtime_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def runtime_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.template_dir","title":"template_dir","text":"<pre><code>template_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def template_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.video_dir","title":"video_dir","text":"<pre><code>video_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def video_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.resource_dir","title":"resource_dir","text":"<pre><code>resource_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def resource_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.app_config_dir","title":"app_config_dir","text":"<pre><code>app_config_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def app_config_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.app_data_dir","title":"app_data_dir","text":"<pre><code>app_data_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def app_data_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.app_local_data_dir","title":"app_local_data_dir","text":"<pre><code>app_local_data_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def app_local_data_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.app_cache_dir","title":"app_cache_dir","text":"<pre><code>app_cache_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def app_cache_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.app_log_dir","title":"app_log_dir","text":"<pre><code>app_log_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def app_log_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/path/#pytauri.ffi.path.PathResolver.temp_dir","title":"temp_dir","text":"<pre><code>temp_dir() -&gt; Path\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/path.py</code> <pre><code>def temp_dir(self) -&gt; Path: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/","title":"tray","text":""},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray","title":"pytauri.ffi.tray","text":"<p>tauri::tray</p> <p>Classes:</p> Name Description <code>TrayIcon</code> <p>tauri::tray::TrayIcon</p> <code>TrayIconEvent</code> <p>tauri::tray::TrayIconEvent</p> <code>MouseButton</code> <p>tauri::tray::MouseButton</p> <code>MouseButtonState</code> <p>tauri::tray::MouseButtonState</p> <p>Attributes:</p> Name Type Description <code>TrayIconId</code> <p>tauri::tray::TrayIconId</p> <code>TrayIconEventType</code> <p>See TrayIconEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['MouseButton', 'MouseButtonState', 'TrayIcon', 'TrayIconEvent', 'TrayIconEventType', 'TrayIconId']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconId","title":"TrayIconId  <code>module-attribute</code>","text":"<pre><code>TrayIconId = TypeAliasType('TrayIconId', str)\n</code></pre> <p>tauri::tray::TrayIconId</p>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEventType","title":"TrayIconEventType  <code>module-attribute</code>","text":"<pre><code>TrayIconEventType = TypeAliasType('TrayIconEventType', Union[Click, DoubleClick, Enter, Move, Leave, _NonExhaustive])\n</code></pre> <p>See TrayIconEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon","title":"TrayIcon","text":"<p>tauri::tray::TrayIcon</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>on_menu_event</code> <p>This is an alias for pytauri.ffi.AppHandle.on_menu_event.</p> <code>on_tray_icon_event</code> <p>Set a handler for this tray icon events.</p> <code>id</code> <code>set_icon</code> <code>set_menu</code> <code>set_tooltip</code> <code>set_title</code> <code>set_visible</code> <code>set_temp_dir_path</code> <code>set_icon_as_template</code> <code>set_show_menu_on_left_click</code> <code>rect</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def __new__(cls, manager: ImplManager, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: TrayIconId) -&gt; TrayIcon\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>@staticmethod\ndef with_id(manager: ImplManager, id: TrayIconId, /) -&gt; \"TrayIcon\": ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[AppHandle, MenuEvent], None]) -&gt; None\n</code></pre> <p>This is an alias for pytauri.ffi.AppHandle.on_menu_event.</p> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[AppHandle, MenuEvent], None], /\n) -&gt; None:\n    \"\"\"This is an alias for [pytauri.ffi.AppHandle.on_menu_event][].\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.on_tray_icon_event","title":"on_tray_icon_event","text":"<pre><code>on_tray_icon_event(handler: Callable[[Self, TrayIconEventType], None]) -&gt; None\n</code></pre> <p>Set a handler for this tray icon events.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def on_tray_icon_event(\n    self, handler: Callable[[Self, \"TrayIconEventType\"], None], /\n) -&gt; None:\n    \"\"\"Set a handler for this tray icon events.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.id","title":"id","text":"<pre><code>id() -&gt; TrayIconId\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def id(self, /) -&gt; TrayIconId: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Optional[Image]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_icon(self, icon: Optional[Image], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Optional[ImplContextMenu]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_menu(self, menu: Optional[ImplContextMenu], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_tooltip","title":"set_tooltip","text":"<pre><code>set_tooltip(tooltip: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_tooltip(self, tooltip: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_title","title":"set_title","text":"<pre><code>set_title(title: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_title(self, title: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_visible","title":"set_visible","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_visible(self, visible: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_temp_dir_path","title":"set_temp_dir_path","text":"<pre><code>set_temp_dir_path(path: Optional[Pyo3Path]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_temp_dir_path(self, path: Optional[Pyo3Path], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_icon_as_template","title":"set_icon_as_template","text":"<pre><code>set_icon_as_template(is_template: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_icon_as_template(self, is_template: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_show_menu_on_left_click","title":"set_show_menu_on_left_click","text":"<pre><code>set_show_menu_on_left_click(enable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_show_menu_on_left_click(self, enable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.rect","title":"rect","text":"<pre><code>rect() -&gt; Optional[Rect]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def rect(self, /) -&gt; Optional[Rect]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent","title":"TrayIconEvent","text":"<p>tauri::tray::TrayIconEvent</p> <p>Classes:</p> Name Description <code>Click</code> <p>tauri::tray::TrayIconEvent::Click</p> <code>DoubleClick</code> <p>tauri::tray::TrayIconEvent::DoubleClick</p> <code>Enter</code> <p>tauri::tray::TrayIconEvent::Enter</p> <code>Move</code> <p>tauri::tray::TrayIconEvent::Move</p> <code>Leave</code> <p>tauri::tray::TrayIconEvent::Leave</p>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click","title":"Click","text":"<p>tauri::tray::TrayIconEvent::Click</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PhysicalPositionF64</code> <code>rect</code> <code>Rect</code> <code>button</code> <code>MouseButton</code> <code>button_state</code> <code>MouseButtonState</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click.position","title":"position  <code>property</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click.button","title":"button  <code>property</code>","text":"<pre><code>button: MouseButton\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click.button_state","title":"button_state  <code>property</code>","text":"<pre><code>button_state: MouseButtonState\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.DoubleClick","title":"DoubleClick","text":"<p>tauri::tray::TrayIconEvent::DoubleClick</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PhysicalPositionF64</code> <code>rect</code> <code>Rect</code> <code>button</code> <code>MouseButton</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.DoubleClick.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.DoubleClick.position","title":"position  <code>property</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.DoubleClick.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.DoubleClick.button","title":"button  <code>property</code>","text":"<pre><code>button: MouseButton\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Enter","title":"Enter","text":"<p>tauri::tray::TrayIconEvent::Enter</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Enter.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Enter.position","title":"position  <code>property</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Enter.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Move","title":"Move","text":"<p>tauri::tray::TrayIconEvent::Move</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Move.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Move.position","title":"position  <code>property</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Move.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Leave","title":"Leave","text":"<p>tauri::tray::TrayIconEvent::Leave</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Leave.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Leave.position","title":"position  <code>property</code>","text":"<pre><code>position: _PhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Leave.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButton","title":"MouseButton","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::tray::MouseButton</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Left</code> <code>Right</code> <code>Middle</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButton.Left","title":"Left  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Left = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButton.Right","title":"Right  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Right = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButton.Middle","title":"Middle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Middle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButtonState","title":"MouseButtonState","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::tray::MouseButtonState</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Up</code> <code>Down</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButtonState.Up","title":"Up  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Up = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButtonState.Down","title":"Down  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Down = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/","title":"webview","text":""},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview","title":"pytauri.ffi.webview","text":"<p>tauri::webview</p> <p>Classes:</p> Name Description <code>WebviewWindow</code> <p>tauri::webview::WebviewWindow</p> <code>Webview</code> <p>tauri::webview::Webview</p>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Webview', 'WebviewWindow']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow","title":"WebviewWindow","text":"<p>tauri::webview::WebviewWindow</p> <p>Methods:</p> Name Description <code>run_on_main_thread</code> <p>Runs the given closure on the main thread.</p> <code>label</code> <code>on_window_event</code> <p>Registers a window event listener.</p> <code>on_menu_event</code> <p>Registers a global menu event listener.</p> <code>menu</code> <code>set_menu</code> <code>remove_menu</code> <code>hide_menu</code> <code>show_menu</code> <code>is_menu_visible</code> <code>popup_menu</code> <code>popup_menu_at</code> <code>is_fullscreen</code> <code>is_minimized</code> <code>is_maximized</code> <code>is_focused</code> <code>is_decorated</code> <code>is_resizable</code> <code>is_enabled</code> <code>is_maximizable</code> <code>is_minimizable</code> <code>is_closable</code> <code>is_visible</code> <code>title</code> <code>theme</code> <code>center</code> <code>set_resizable</code> <code>set_enabled</code> <code>set_maximizable</code> <code>set_minimizable</code> <code>set_closable</code> <code>set_title</code> <code>maximize</code> <code>unmaximize</code> <code>minimize</code> <code>unminimize</code> <code>show</code> <code>hide</code> <code>close</code> <code>destroy</code> <code>set_decorations</code> <code>set_shadow</code> <code>set_always_on_bottom</code> <code>set_always_on_top</code> <code>set_visible_on_all_workspaces</code> <code>set_content_protected</code> <code>set_fullscreen</code> <code>set_focus</code> <code>set_icon</code> <code>set_skip_taskbar</code> <code>set_cursor_grab</code> <code>set_cursor_visible</code> <code>set_ignore_cursor_events</code> <code>start_dragging</code> <code>set_badge_count</code> <code>set_theme</code> <code>print</code> <code>url</code> <code>navigate</code> <code>eval</code> <code>set_zoom</code> <code>clear_all_browsing_data</code> <code>as_ref_webview</code> <code>on_webview_event</code> <p>Registers a window event listener.</p>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.run_on_main_thread","title":"run_on_main_thread","text":"<pre><code>run_on_main_thread(handler: Callable[[], object]) -&gt; None\n</code></pre> <p>Runs the given closure on the main thread.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def run_on_main_thread(self, handler: Callable[[], object], /) -&gt; None:\n    \"\"\"Runs the given closure on the main thread.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.label","title":"label","text":"<pre><code>label() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def label(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.on_window_event","title":"on_window_event","text":"<pre><code>on_window_event(handler: Callable[[WindowEventType], None]) -&gt; None\n</code></pre> <p>Registers a window event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def on_window_event(\n    self, handler: Callable[[WindowEventType], None], /\n) -&gt; None:\n    \"\"\"Registers a window event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[Self, MenuEvent], None]) -&gt; None\n</code></pre> <p>Registers a global menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[\"Self\", \"MenuEvent\"], None], /\n) -&gt; None:\n    \"\"\"Registers a global menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.menu","title":"menu","text":"<pre><code>menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Menu) -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_menu(self, menu: Menu, /) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.remove_menu","title":"remove_menu","text":"<pre><code>remove_menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def remove_menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.hide_menu","title":"hide_menu","text":"<pre><code>hide_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def hide_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.show_menu","title":"show_menu","text":"<pre><code>show_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def show_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_menu_visible","title":"is_menu_visible","text":"<pre><code>is_menu_visible() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_menu_visible(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.popup_menu","title":"popup_menu","text":"<pre><code>popup_menu(menu: ImplContextMenu) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def popup_menu(self, menu: ImplContextMenu, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.popup_menu_at","title":"popup_menu_at","text":"<pre><code>popup_menu_at(menu: ImplContextMenu, position: PositionType) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def popup_menu_at(\n    self, menu: ImplContextMenu, position: PositionType, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_fullscreen","title":"is_fullscreen","text":"<pre><code>is_fullscreen() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_fullscreen(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_minimized","title":"is_minimized","text":"<pre><code>is_minimized() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_minimized(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_maximized","title":"is_maximized","text":"<pre><code>is_maximized() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_maximized(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_focused","title":"is_focused","text":"<pre><code>is_focused() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_focused(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_decorated","title":"is_decorated","text":"<pre><code>is_decorated() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_decorated(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_resizable","title":"is_resizable","text":"<pre><code>is_resizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_resizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_enabled(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_maximizable","title":"is_maximizable","text":"<pre><code>is_maximizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_maximizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_minimizable","title":"is_minimizable","text":"<pre><code>is_minimizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_minimizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_closable","title":"is_closable","text":"<pre><code>is_closable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_closable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_visible","title":"is_visible","text":"<pre><code>is_visible() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_visible(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.title","title":"title","text":"<pre><code>title() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def title(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.theme","title":"theme","text":"<pre><code>theme() -&gt; Theme\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def theme(self) -&gt; Theme: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.center","title":"center","text":"<pre><code>center() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def center(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_resizable","title":"set_resizable","text":"<pre><code>set_resizable(resizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_resizable(self, resizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_maximizable","title":"set_maximizable","text":"<pre><code>set_maximizable(maximizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_maximizable(self, maximizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_minimizable","title":"set_minimizable","text":"<pre><code>set_minimizable(minimizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_minimizable(self, minimizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_closable","title":"set_closable","text":"<pre><code>set_closable(closable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_closable(self, closable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_title","title":"set_title","text":"<pre><code>set_title(title: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_title(self, title: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.maximize","title":"maximize","text":"<pre><code>maximize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def maximize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.unmaximize","title":"unmaximize","text":"<pre><code>unmaximize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def unmaximize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.minimize","title":"minimize","text":"<pre><code>minimize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def minimize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.unminimize","title":"unminimize","text":"<pre><code>unminimize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def unminimize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def show(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def hide(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def close(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.destroy","title":"destroy","text":"<pre><code>destroy() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def destroy(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_decorations","title":"set_decorations","text":"<pre><code>set_decorations(decorations: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_decorations(self, decorations: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_shadow","title":"set_shadow","text":"<pre><code>set_shadow(shadow: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_shadow(self, shadow: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_always_on_bottom","title":"set_always_on_bottom","text":"<pre><code>set_always_on_bottom(always_on_bottom: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_always_on_bottom(self, always_on_bottom: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_always_on_top","title":"set_always_on_top","text":"<pre><code>set_always_on_top(always_on_top: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_always_on_top(self, always_on_top: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_visible_on_all_workspaces","title":"set_visible_on_all_workspaces","text":"<pre><code>set_visible_on_all_workspaces(visible_on_all_workspaces: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_visible_on_all_workspaces(\n    self, visible_on_all_workspaces: bool, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_content_protected","title":"set_content_protected","text":"<pre><code>set_content_protected(protected: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_content_protected(self, protected: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_fullscreen","title":"set_fullscreen","text":"<pre><code>set_fullscreen(fullscreen: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_fullscreen(self, fullscreen: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_focus","title":"set_focus","text":"<pre><code>set_focus() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_focus(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Image) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_icon(self, icon: Image, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_skip_taskbar","title":"set_skip_taskbar","text":"<pre><code>set_skip_taskbar(skip: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_skip_taskbar(self, skip: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_cursor_grab","title":"set_cursor_grab","text":"<pre><code>set_cursor_grab(grab: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_cursor_grab(self, grab: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_cursor_visible","title":"set_cursor_visible","text":"<pre><code>set_cursor_visible(visible: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_cursor_visible(self, visible: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_ignore_cursor_events","title":"set_ignore_cursor_events","text":"<pre><code>set_ignore_cursor_events(ignore: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_ignore_cursor_events(self, ignore: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.start_dragging","title":"start_dragging","text":"<pre><code>start_dragging() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def start_dragging(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_badge_count","title":"set_badge_count","text":"<pre><code>set_badge_count(count: Optional[int]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_badge_count(self, count: Optional[int], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_theme","title":"set_theme","text":"<pre><code>set_theme(theme: Optional[Theme]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_theme(self, theme: Optional[Theme], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.print","title":"print","text":"<pre><code>print() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def print(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.url","title":"url","text":"<pre><code>url() -&gt; Url\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def url(self) -&gt; Url: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.navigate","title":"navigate","text":"<pre><code>navigate(url: Url) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def navigate(self, url: Url, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.eval","title":"eval","text":"<pre><code>eval(js: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def eval(self, js: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_zoom","title":"set_zoom","text":"<pre><code>set_zoom(scale_factor: float) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_zoom(self, scale_factor: float, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.clear_all_browsing_data","title":"clear_all_browsing_data","text":"<pre><code>clear_all_browsing_data() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def clear_all_browsing_data(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.as_ref_webview","title":"as_ref_webview","text":"<pre><code>as_ref_webview() -&gt; Webview\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def as_ref_webview(self) -&gt; \"Webview\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.on_webview_event","title":"on_webview_event","text":"<pre><code>on_webview_event(handler: Callable[[WebviewEventType], None]) -&gt; None\n</code></pre> <p>Registers a window event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def on_webview_event(\n    self, handler: Callable[[WebviewEventType], None], /\n) -&gt; None:\n    \"\"\"Registers a window event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.Webview","title":"Webview","text":"<p>tauri::webview::Webview</p> <p>Methods:</p> Name Description <code>window</code>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.Webview.window","title":"window","text":"<pre><code>window() -&gt; Window\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def window(self) -&gt; \"Window\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/window/","title":"window","text":""},{"location":"reference/py/pytauri/ffi/window/#pytauri.ffi.window","title":"pytauri.ffi.window","text":"<p>tauri::window</p> <p>Classes:</p> Name Description <code>Window</code> <p>tauri::Window</p>"},{"location":"reference/py/pytauri/ffi/window/#pytauri.ffi.window.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Window']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/window/#pytauri.ffi.window.Window","title":"Window","text":"<p>tauri::Window</p>"},{"location":"reference/py/pytauri_plugins/","title":"pytauri_plugins","text":""},{"location":"reference/py/pytauri_plugins/#pytauri_plugins","title":"pytauri_plugins","text":"<p>This module provides pytauri/tauri plugins.</p> <p>Currently, it is distributed as part of the <code>pytauri</code> package on PyPI. Therefore, running <code>pip install pytauri</code> will also install this module.</p> <p>Modules:</p> Name Description <code>dialog</code> <p>tauri_plugin_dialog::self</p> <code>notification</code> <p>tauri_plugin_notification::self</p> <p>Attributes:</p> Name Type Description <code>PLUGIN_NOTIFICATION</code> <code>Final[bool]</code> <p>Whether the <code>plugin-notification</code> feature is enabled.</p> <code>PLUGIN_DIALOG</code> <code>Final[bool]</code> <p>Whether the <code>plugin-dialog</code> feature is enabled.</p>"},{"location":"reference/py/pytauri_plugins/#pytauri_plugins.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['PLUGIN_DIALOG', 'PLUGIN_NOTIFICATION']\n</code></pre>"},{"location":"reference/py/pytauri_plugins/#pytauri_plugins.PLUGIN_NOTIFICATION","title":"PLUGIN_NOTIFICATION  <code>module-attribute</code>","text":"<pre><code>PLUGIN_NOTIFICATION: Final[bool] = PLUGIN_NOTIFICATION\n</code></pre> <p>Whether the <code>plugin-notification</code> feature is enabled.</p>"},{"location":"reference/py/pytauri_plugins/#pytauri_plugins.PLUGIN_DIALOG","title":"PLUGIN_DIALOG  <code>module-attribute</code>","text":"<pre><code>PLUGIN_DIALOG: Final[bool] = PLUGIN_DIALOG\n</code></pre> <p>Whether the <code>plugin-dialog</code> feature is enabled.</p>"},{"location":"reference/py/pytauri_plugins/dialog/","title":"dialog","text":""},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog","title":"pytauri_plugins.dialog","text":"<p>tauri_plugin_dialog::self</p> <p>Modules:</p> Name Description <code>ffi</code> <p>Original FFI interface module.</p> <p>Classes:</p> Name Description <code>DialogExt</code> <p>tauri_plugin_dialog::DialogExt</p> <code>FileDialogBuilder</code> <p>tauri_plugin_dialog::FileDialogBuilder</p> <code>FileDialogBuilderArgs</code> <p>tauri_plugin_dialog::FileDialogBuilder</p> <code>MessageDialogBuilder</code> <p>tauri_plugin_dialog::MessageDialogBuilder</p> <code>MessageDialogBuilderArgs</code> <p>tauri_plugin_dialog::MessageDialogBuilder</p> <code>MessageDialogButtons</code> <p>tauri_plugin_dialog::MessageDialogButtons</p> <code>MessageDialogKind</code> <p>tauri_plugin_dialog::MessageDialogKind</p> <p>Attributes:</p> Name Type Description <code>FilePath</code> <p>tauri_plugin_dialog::FilePath</p> <code>ImplDialogExt</code> <code>TypeAlias</code> <p>The implementers of <code>DialogExt</code>.</p> <code>MessageDialogButtonsType</code> <p>See MessageDialogButtons for details.</p>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FilePath","title":"FilePath  <code>module-attribute</code>","text":"<pre><code>FilePath = TypeAliasType('FilePath', StrictPyo3Path)\n</code></pre> <p>tauri_plugin_dialog::FilePath</p>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.ImplDialogExt","title":"ImplDialogExt  <code>module-attribute</code>","text":"<pre><code>ImplDialogExt: TypeAlias = ImplManager\n</code></pre> <p>The implementers of <code>DialogExt</code>.</p>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtonsType","title":"MessageDialogButtonsType  <code>module-attribute</code>","text":"<pre><code>MessageDialogButtonsType = TypeAliasType('MessageDialogButtonsType', Union[Ok, OkCancel, YesNo, OkCustom, OkCancelCustom])\n</code></pre> <p>See MessageDialogButtons for details.</p>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['DialogExt', 'FileDialogBuilder', 'FileDialogBuilderArgs', 'FilePath', 'ImplDialogExt', 'MessageDialogBuilder', 'MessageDialogBuilderArgs', 'MessageDialogButtons', 'MessageDialogButtonsType', 'MessageDialogKind']\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.DialogExt","title":"DialogExt","text":"<p>tauri_plugin_dialog::DialogExt</p> <p>Methods:</p> Name Description <code>message</code> <code>file</code>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.DialogExt.message","title":"message  <code>staticmethod</code>","text":"<pre><code>message(slf: ImplDialogExt, message: str) -&gt; MessageDialogBuilder\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>@staticmethod\ndef message(slf: \"ImplDialogExt\", message: str, /) -&gt; MessageDialogBuilder: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.DialogExt.file","title":"file  <code>staticmethod</code>","text":"<pre><code>file(slf: ImplDialogExt) -&gt; FileDialogBuilder\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>@staticmethod\ndef file(slf: \"ImplDialogExt\", /) -&gt; FileDialogBuilder: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder","title":"FileDialogBuilder","text":"<p>tauri_plugin_dialog::FileDialogBuilder</p> <p>Methods:</p> Name Description <code>pick_file</code> <code>blocking_pick_file</code> <code>pick_files</code> <code>blocking_pick_files</code> <code>pick_folder</code> <code>blocking_pick_folder</code> <code>pick_folders</code> <code>blocking_pick_folders</code> <code>save_file</code> <code>blocking_save_file</code>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder.pick_file","title":"pick_file","text":"<pre><code>pick_file(handler: Callable[[Optional[FilePath]], object], /, **kwargs: Unpack[FileDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def pick_file(\n    self,\n    handler: Callable[[Optional[FilePath]], object],\n    /,\n    **kwargs: Unpack[\"FileDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder.blocking_pick_file","title":"blocking_pick_file","text":"<pre><code>blocking_pick_file(**kwargs: Unpack[FileDialogBuilderArgs]) -&gt; Optional[FilePath]\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_pick_file(\n    self, /, **kwargs: Unpack[\"FileDialogBuilderArgs\"]\n) -&gt; Optional[FilePath]: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder.pick_files","title":"pick_files","text":"<pre><code>pick_files(handler: Callable[[Optional[list[FilePath]]], object], /, **kwargs: Unpack[FileDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def pick_files(\n    self,\n    handler: Callable[[Optional[list[FilePath]]], object],\n    /,\n    **kwargs: Unpack[\"FileDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder.blocking_pick_files","title":"blocking_pick_files","text":"<pre><code>blocking_pick_files(**kwargs: Unpack[FileDialogBuilderArgs]) -&gt; Optional[list[FilePath]]\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_pick_files(\n    self, /, **kwargs: Unpack[\"FileDialogBuilderArgs\"]\n) -&gt; Optional[list[FilePath]]: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder.pick_folder","title":"pick_folder","text":"<pre><code>pick_folder(handler: Callable[[Optional[FilePath]], object], /, **kwargs: Unpack[FileDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def pick_folder(\n    self,\n    handler: Callable[[Optional[FilePath]], object],\n    /,\n    **kwargs: Unpack[\"FileDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder.blocking_pick_folder","title":"blocking_pick_folder","text":"<pre><code>blocking_pick_folder(**kwargs: Unpack[FileDialogBuilderArgs]) -&gt; Optional[FilePath]\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_pick_folder(\n    self, /, **kwargs: Unpack[\"FileDialogBuilderArgs\"]\n) -&gt; Optional[FilePath]: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder.pick_folders","title":"pick_folders","text":"<pre><code>pick_folders(handler: Callable[[Optional[list[FilePath]]], object], /, **kwargs: Unpack[FileDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def pick_folders(\n    self,\n    handler: Callable[[Optional[list[FilePath]]], object],\n    /,\n    **kwargs: Unpack[\"FileDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder.blocking_pick_folders","title":"blocking_pick_folders","text":"<pre><code>blocking_pick_folders(**kwargs: Unpack[FileDialogBuilderArgs]) -&gt; Optional[list[FilePath]]\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_pick_folders(\n    self, /, **kwargs: Unpack[\"FileDialogBuilderArgs\"]\n) -&gt; Optional[list[FilePath]]: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder.save_file","title":"save_file","text":"<pre><code>save_file(handler: Callable[[Optional[FilePath]], object], /, **kwargs: Unpack[FileDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def save_file(\n    self,\n    handler: Callable[[Optional[FilePath]], object],\n    /,\n    **kwargs: Unpack[\"FileDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilder.blocking_save_file","title":"blocking_save_file","text":"<pre><code>blocking_save_file(**kwargs: Unpack[FileDialogBuilderArgs]) -&gt; Optional[FilePath]\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_save_file(\n    self, /, **kwargs: Unpack[\"FileDialogBuilderArgs\"]\n) -&gt; Optional[FilePath]: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilderArgs","title":"FileDialogBuilderArgs","text":"<p>               Bases: <code>TypedDict</code></p> <p>tauri_plugin_dialog::FileDialogBuilder</p> <p>Attributes:</p> Name Type Description <code>add_filter</code> <code>tuple[str, Sequence[str]]</code> <p>(name, extensions)</p> <code>set_directory</code> <code>Pyo3Path</code> <code>set_file_name</code> <code>str</code> <code>set_parent</code> <code>_HasWindowHandleAndHasDisplayHandle</code> <code>set_title</code> <code>str</code> <code>set_can_create_directories</code> <code>bool</code>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilderArgs.add_filter","title":"add_filter  <code>instance-attribute</code>","text":"<pre><code>add_filter: tuple[str, Sequence[str]]\n</code></pre> <p>(name, extensions)</p>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilderArgs.set_directory","title":"set_directory  <code>instance-attribute</code>","text":"<pre><code>set_directory: Pyo3Path\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilderArgs.set_file_name","title":"set_file_name  <code>instance-attribute</code>","text":"<pre><code>set_file_name: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilderArgs.set_parent","title":"set_parent  <code>instance-attribute</code>","text":"<pre><code>set_parent: _HasWindowHandleAndHasDisplayHandle\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilderArgs.set_title","title":"set_title  <code>instance-attribute</code>","text":"<pre><code>set_title: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.FileDialogBuilderArgs.set_can_create_directories","title":"set_can_create_directories  <code>instance-attribute</code>","text":"<pre><code>set_can_create_directories: bool\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogBuilder","title":"MessageDialogBuilder","text":"<p>tauri_plugin_dialog::MessageDialogBuilder</p> <p>Methods:</p> Name Description <code>blocking_show</code> <code>show</code>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogBuilder.blocking_show","title":"blocking_show","text":"<pre><code>blocking_show(**kwargs: Unpack[MessageDialogBuilderArgs]) -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_show(\n    self, /, **kwargs: Unpack[\"MessageDialogBuilderArgs\"]\n) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogBuilder.show","title":"show","text":"<pre><code>show(handler: Callable[[bool], object], /, **kwargs: Unpack[MessageDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def show(\n    self,\n    handler: Callable[[bool], object],\n    /,\n    **kwargs: Unpack[\"MessageDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogBuilderArgs","title":"MessageDialogBuilderArgs","text":"<p>               Bases: <code>TypedDict</code></p> <p>tauri_plugin_dialog::MessageDialogBuilder</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>str</code> <code>parent</code> <code>_HasWindowHandleAndHasDisplayHandle</code> <code>buttons</code> <code>MessageDialogButtonsType</code> <code>kind</code> <code>MessageDialogKind</code>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogBuilderArgs.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogBuilderArgs.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: _HasWindowHandleAndHasDisplayHandle\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogBuilderArgs.buttons","title":"buttons  <code>instance-attribute</code>","text":"<pre><code>buttons: MessageDialogButtonsType\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogBuilderArgs.kind","title":"kind  <code>instance-attribute</code>","text":"<pre><code>kind: MessageDialogKind\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtons","title":"MessageDialogButtons","text":"<p>tauri_plugin_dialog::MessageDialogButtons</p> <p>Classes:</p> Name Description <code>Ok</code> <code>OkCancel</code> <code>YesNo</code> <code>OkCustom</code> <code>OkCancelCustom</code>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtons.Ok","title":"Ok","text":""},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtons.OkCancel","title":"OkCancel","text":""},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtons.YesNo","title":"YesNo","text":""},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtons.OkCustom","title":"OkCustom","text":"<p>               Bases: <code>tuple[str]</code></p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtons.OkCustom.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtons.OkCustom.__new__","title":"__new__","text":"<pre><code>__new__(_0: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def __new__(cls, _0: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtons.OkCancelCustom","title":"OkCancelCustom","text":"<p>               Bases: <code>tuple[str, str]</code></p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtons.OkCancelCustom.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0', '_1')\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogButtons.OkCancelCustom.__new__","title":"__new__","text":"<pre><code>__new__(_0: str, _1: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def __new__(cls, _0: str, _1: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogKind","title":"MessageDialogKind","text":"<p>               Bases: <code>Enum</code></p> <p>tauri_plugin_dialog::MessageDialogKind</p> <p>Attributes:</p> Name Type Description <code>Info</code> <code>Warning</code> <code>Error</code>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogKind.Info","title":"Info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Info = auto()\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogKind.Warning","title":"Warning  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Warning = auto()\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/#pytauri_plugins.dialog.MessageDialogKind.Error","title":"Error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Error = auto()\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/","title":"ffi","text":""},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi","title":"pytauri_plugins.dialog.ffi","text":"<p>Original FFI interface module.</p> <p>Warning</p> <p>All APIs under this module should not be considered stable. You should use the re-exported APIs under the top-level module.</p> <p>Classes:</p> Name Description <code>MessageDialogButtons</code> <p>tauri_plugin_dialog::MessageDialogButtons</p> <code>MessageDialogKind</code> <p>tauri_plugin_dialog::MessageDialogKind</p> <code>MessageDialogBuilder</code> <p>tauri_plugin_dialog::MessageDialogBuilder</p> <code>FileDialogBuilder</code> <p>tauri_plugin_dialog::FileDialogBuilder</p> <code>DialogExt</code> <p>tauri_plugin_dialog::DialogExt</p> <code>MessageDialogBuilderArgs</code> <p>tauri_plugin_dialog::MessageDialogBuilder</p> <code>FileDialogBuilderArgs</code> <p>tauri_plugin_dialog::FileDialogBuilder</p> <p>Attributes:</p> Name Type Description <code>FilePath</code> <p>tauri_plugin_dialog::FilePath</p> <code>MessageDialogButtonsType</code> <p>See MessageDialogButtons for details.</p> <code>ImplDialogExt</code> <code>TypeAlias</code> <p>The implementers of <code>DialogExt</code>.</p>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['DialogExt', 'FileDialogBuilder', 'FileDialogBuilderArgs', 'FilePath', 'ImplDialogExt', 'MessageDialogBuilder', 'MessageDialogBuilderArgs', 'MessageDialogButtons', 'MessageDialogButtonsType', 'MessageDialogKind']\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FilePath","title":"FilePath  <code>module-attribute</code>","text":"<pre><code>FilePath = TypeAliasType('FilePath', StrictPyo3Path)\n</code></pre> <p>tauri_plugin_dialog::FilePath</p>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtonsType","title":"MessageDialogButtonsType  <code>module-attribute</code>","text":"<pre><code>MessageDialogButtonsType = TypeAliasType('MessageDialogButtonsType', Union[Ok, OkCancel, YesNo, OkCustom, OkCancelCustom])\n</code></pre> <p>See MessageDialogButtons for details.</p>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.ImplDialogExt","title":"ImplDialogExt  <code>module-attribute</code>","text":"<pre><code>ImplDialogExt: TypeAlias = ImplManager\n</code></pre> <p>The implementers of <code>DialogExt</code>.</p>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtons","title":"MessageDialogButtons","text":"<p>tauri_plugin_dialog::MessageDialogButtons</p> <p>Classes:</p> Name Description <code>Ok</code> <code>OkCancel</code> <code>YesNo</code> <code>OkCustom</code> <code>OkCancelCustom</code>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtons.Ok","title":"Ok","text":""},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtons.OkCancel","title":"OkCancel","text":""},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtons.YesNo","title":"YesNo","text":""},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtons.OkCustom","title":"OkCustom","text":"<p>               Bases: <code>tuple[str]</code></p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtons.OkCustom.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0')\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtons.OkCustom.__new__","title":"__new__","text":"<pre><code>__new__(_0: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def __new__(cls, _0: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtons.OkCancelCustom","title":"OkCancelCustom","text":"<p>               Bases: <code>tuple[str, str]</code></p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>__match_args__</code>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtons.OkCancelCustom.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('_0', '_1')\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogButtons.OkCancelCustom.__new__","title":"__new__","text":"<pre><code>__new__(_1)\" optional&gt;_1: str, _1: str) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def __new__(cls, _0: str, _1: str, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogKind","title":"MessageDialogKind","text":"<p>               Bases: <code>Enum</code></p> <p>tauri_plugin_dialog::MessageDialogKind</p> <p>Attributes:</p> Name Type Description <code>Info</code> <code>Warning</code> <code>Error</code>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogKind.Info","title":"Info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Info = auto()\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogKind.Warning","title":"Warning  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Warning = auto()\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogKind.Error","title":"Error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Error = auto()\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogBuilder","title":"MessageDialogBuilder","text":"<p>tauri_plugin_dialog::MessageDialogBuilder</p> <p>Methods:</p> Name Description <code>blocking_show</code> <code>show</code>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogBuilder.blocking_show","title":"blocking_show","text":"<pre><code>blocking_show(**kwargs: Unpack[MessageDialogBuilderArgs]) -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_show(\n    self, /, **kwargs: Unpack[\"MessageDialogBuilderArgs\"]\n) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogBuilder.show","title":"show","text":"<pre><code>show(handler: Callable[[bool], object], /, **kwargs: Unpack[MessageDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def show(\n    self,\n    handler: Callable[[bool], object],\n    /,\n    **kwargs: Unpack[\"MessageDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder","title":"FileDialogBuilder","text":"<p>tauri_plugin_dialog::FileDialogBuilder</p> <p>Methods:</p> Name Description <code>pick_file</code> <code>blocking_pick_file</code> <code>pick_files</code> <code>blocking_pick_files</code> <code>pick_folder</code> <code>blocking_pick_folder</code> <code>pick_folders</code> <code>blocking_pick_folders</code> <code>save_file</code> <code>blocking_save_file</code>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder.pick_file","title":"pick_file","text":"<pre><code>pick_file(handler: Callable[[Optional[FilePath]], object], /, **kwargs: Unpack[FileDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def pick_file(\n    self,\n    handler: Callable[[Optional[FilePath]], object],\n    /,\n    **kwargs: Unpack[\"FileDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder.blocking_pick_file","title":"blocking_pick_file","text":"<pre><code>blocking_pick_file(**kwargs: Unpack[FileDialogBuilderArgs]) -&gt; Optional[FilePath]\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_pick_file(\n    self, /, **kwargs: Unpack[\"FileDialogBuilderArgs\"]\n) -&gt; Optional[FilePath]: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder.pick_files","title":"pick_files","text":"<pre><code>pick_files(handler: Callable[[Optional[list[FilePath]]], object], /, **kwargs: Unpack[FileDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def pick_files(\n    self,\n    handler: Callable[[Optional[list[FilePath]]], object],\n    /,\n    **kwargs: Unpack[\"FileDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder.blocking_pick_files","title":"blocking_pick_files","text":"<pre><code>blocking_pick_files(**kwargs: Unpack[FileDialogBuilderArgs]) -&gt; Optional[list[FilePath]]\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_pick_files(\n    self, /, **kwargs: Unpack[\"FileDialogBuilderArgs\"]\n) -&gt; Optional[list[FilePath]]: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder.pick_folder","title":"pick_folder","text":"<pre><code>pick_folder(handler: Callable[[Optional[FilePath]], object], /, **kwargs: Unpack[FileDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def pick_folder(\n    self,\n    handler: Callable[[Optional[FilePath]], object],\n    /,\n    **kwargs: Unpack[\"FileDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder.blocking_pick_folder","title":"blocking_pick_folder","text":"<pre><code>blocking_pick_folder(**kwargs: Unpack[FileDialogBuilderArgs]) -&gt; Optional[FilePath]\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_pick_folder(\n    self, /, **kwargs: Unpack[\"FileDialogBuilderArgs\"]\n) -&gt; Optional[FilePath]: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder.pick_folders","title":"pick_folders","text":"<pre><code>pick_folders(handler: Callable[[Optional[list[FilePath]]], object], /, **kwargs: Unpack[FileDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def pick_folders(\n    self,\n    handler: Callable[[Optional[list[FilePath]]], object],\n    /,\n    **kwargs: Unpack[\"FileDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder.blocking_pick_folders","title":"blocking_pick_folders","text":"<pre><code>blocking_pick_folders(**kwargs: Unpack[FileDialogBuilderArgs]) -&gt; Optional[list[FilePath]]\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_pick_folders(\n    self, /, **kwargs: Unpack[\"FileDialogBuilderArgs\"]\n) -&gt; Optional[list[FilePath]]: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder.save_file","title":"save_file","text":"<pre><code>save_file(handler: Callable[[Optional[FilePath]], object], /, **kwargs: Unpack[FileDialogBuilderArgs]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def save_file(\n    self,\n    handler: Callable[[Optional[FilePath]], object],\n    /,\n    **kwargs: Unpack[\"FileDialogBuilderArgs\"],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilder.blocking_save_file","title":"blocking_save_file","text":"<pre><code>blocking_save_file(**kwargs: Unpack[FileDialogBuilderArgs]) -&gt; Optional[FilePath]\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>def blocking_save_file(\n    self, /, **kwargs: Unpack[\"FileDialogBuilderArgs\"]\n) -&gt; Optional[FilePath]: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.DialogExt","title":"DialogExt","text":"<p>tauri_plugin_dialog::DialogExt</p> <p>Methods:</p> Name Description <code>message</code> <code>file</code>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.DialogExt.message","title":"message  <code>staticmethod</code>","text":"<pre><code>message(slf: ImplDialogExt, message: str) -&gt; MessageDialogBuilder\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>@staticmethod\ndef message(slf: \"ImplDialogExt\", message: str, /) -&gt; MessageDialogBuilder: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.DialogExt.file","title":"file  <code>staticmethod</code>","text":"<pre><code>file(slf: ImplDialogExt) -&gt; FileDialogBuilder\n</code></pre> Source code in <code>python/pytauri/src/pytauri_plugins/dialog/ffi.py</code> <pre><code>@staticmethod\ndef file(slf: \"ImplDialogExt\", /) -&gt; FileDialogBuilder: ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogBuilderArgs","title":"MessageDialogBuilderArgs","text":"<p>               Bases: <code>TypedDict</code></p> <p>tauri_plugin_dialog::MessageDialogBuilder</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>str</code> <code>parent</code> <code>_HasWindowHandleAndHasDisplayHandle</code> <code>buttons</code> <code>MessageDialogButtonsType</code> <code>kind</code> <code>MessageDialogKind</code>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogBuilderArgs.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogBuilderArgs.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: _HasWindowHandleAndHasDisplayHandle\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogBuilderArgs.buttons","title":"buttons  <code>instance-attribute</code>","text":"<pre><code>buttons: MessageDialogButtonsType\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.MessageDialogBuilderArgs.kind","title":"kind  <code>instance-attribute</code>","text":"<pre><code>kind: MessageDialogKind\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilderArgs","title":"FileDialogBuilderArgs","text":"<p>               Bases: <code>TypedDict</code></p> <p>tauri_plugin_dialog::FileDialogBuilder</p> <p>Attributes:</p> Name Type Description <code>add_filter</code> <code>tuple[str, Sequence[str]]</code> <p>(name, extensions)</p> <code>set_directory</code> <code>Pyo3Path</code> <code>set_file_name</code> <code>str</code> <code>set_parent</code> <code>_HasWindowHandleAndHasDisplayHandle</code> <code>set_title</code> <code>str</code> <code>set_can_create_directories</code> <code>bool</code>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilderArgs.add_filter","title":"add_filter  <code>instance-attribute</code>","text":"<pre><code>add_filter: tuple[str, Sequence[str]]\n</code></pre> <p>(name, extensions)</p>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilderArgs.set_directory","title":"set_directory  <code>instance-attribute</code>","text":"<pre><code>set_directory: Pyo3Path\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilderArgs.set_file_name","title":"set_file_name  <code>instance-attribute</code>","text":"<pre><code>set_file_name: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilderArgs.set_parent","title":"set_parent  <code>instance-attribute</code>","text":"<pre><code>set_parent: _HasWindowHandleAndHasDisplayHandle\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilderArgs.set_title","title":"set_title  <code>instance-attribute</code>","text":"<pre><code>set_title: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/dialog/ffi/#pytauri_plugins.dialog.ffi.FileDialogBuilderArgs.set_can_create_directories","title":"set_can_create_directories  <code>instance-attribute</code>","text":"<pre><code>set_can_create_directories: bool\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/","title":"notification","text":""},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification","title":"pytauri_plugins.notification","text":"<p>tauri_plugin_notification::self</p> <p>Modules:</p> Name Description <code>ffi</code> <p>Original FFI interface module.</p> <p>Classes:</p> Name Description <code>NotificationBuilder</code> <p>tauri_plugin_notification::NotificationBuilder</p> <code>NotificationBuilderArgs</code> <p>tauri_plugin_notification::NotificationBuilder</p> <code>NotificationExt</code> <p>tauri_plugin_notification::NotificationExt</p> <p>Attributes:</p> Name Type Description <code>ImplNotificationExt</code> <code>TypeAlias</code> <p>The implementers of <code>NotificationExt</code>.</p>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.ImplNotificationExt","title":"ImplNotificationExt  <code>module-attribute</code>","text":"<pre><code>ImplNotificationExt: TypeAlias = ImplManager\n</code></pre> <p>The implementers of <code>NotificationExt</code>.</p>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ImplNotificationExt', 'NotificationBuilder', 'NotificationBuilderArgs', 'NotificationExt']\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilder","title":"NotificationBuilder","text":"<p>tauri_plugin_notification::NotificationBuilder</p> <p>Methods:</p> Name Description <code>show</code> <p>Consume this builder and show the notification.</p>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilder.show","title":"show","text":"<pre><code>show(**kwargs: Unpack[NotificationBuilderArgs]) -&gt; None\n</code></pre> <p>Consume this builder and show the notification.</p>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilder.show--fixme-xxx-todo","title":"FIXME, XXX, TODO:","text":"<p>See: https://github.com/tauri-apps/tauri/issues/3700</p> <p>On windows, you must install the package via the <code>.msi</code> or <code>nsis</code>, or <code>tauri-plugin-notification</code> will not work.</p> <p>Tracker issue: https://github.com/tauri-apps/plugins-workspace/issues/2156</p> Source code in <code>python/pytauri/src/pytauri_plugins/notification/ffi.py</code> <pre><code>def show(self, /, **kwargs: Unpack[NotificationBuilderArgs]) -&gt; None:\n    \"\"\"Consume this builder and show the notification.\n\n    # FIXME, XXX, TODO:\n\n    See: &lt;https://github.com/tauri-apps/tauri/issues/3700&gt;\n\n    On windows, you must install the package via the `.msi` or `nsis`, or `tauri-plugin-notification` will not work.\n\n    Tracker issue: &lt;https://github.com/tauri-apps/plugins-workspace/issues/2156&gt;\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs","title":"NotificationBuilderArgs","text":"<p>               Bases: <code>TypedDict</code></p> <p>tauri_plugin_notification::NotificationBuilder</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <code>channel_id</code> <code>str</code> <code>title</code> <code>str</code> <code>body</code> <code>str</code> <code>large_body</code> <code>str</code> <code>summary</code> <code>str</code> <code>action_type_id</code> <code>str</code> <code>group</code> <code>str</code> <code>group_summary</code> <code>bool</code> <code>sound</code> <code>str</code> <code>inbox_line</code> <code>str</code> <code>icon</code> <code>str</code> <code>large_icon</code> <code>str</code> <code>icon_color</code> <code>str</code> <code>ongoing</code> <code>bool</code> <code>auto_cancel</code> <code>bool</code> <code>silent</code> <code>bool</code>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.channel_id","title":"channel_id  <code>instance-attribute</code>","text":"<pre><code>channel_id: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.large_body","title":"large_body  <code>instance-attribute</code>","text":"<pre><code>large_body: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.summary","title":"summary  <code>instance-attribute</code>","text":"<pre><code>summary: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.action_type_id","title":"action_type_id  <code>instance-attribute</code>","text":"<pre><code>action_type_id: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.group","title":"group  <code>instance-attribute</code>","text":"<pre><code>group: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.group_summary","title":"group_summary  <code>instance-attribute</code>","text":"<pre><code>group_summary: bool\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.sound","title":"sound  <code>instance-attribute</code>","text":"<pre><code>sound: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.inbox_line","title":"inbox_line  <code>instance-attribute</code>","text":"<pre><code>inbox_line: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.icon","title":"icon  <code>instance-attribute</code>","text":"<pre><code>icon: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.large_icon","title":"large_icon  <code>instance-attribute</code>","text":"<pre><code>large_icon: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.icon_color","title":"icon_color  <code>instance-attribute</code>","text":"<pre><code>icon_color: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.ongoing","title":"ongoing  <code>instance-attribute</code>","text":"<pre><code>ongoing: bool\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.auto_cancel","title":"auto_cancel  <code>instance-attribute</code>","text":"<pre><code>auto_cancel: bool\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationBuilderArgs.silent","title":"silent  <code>instance-attribute</code>","text":"<pre><code>silent: bool\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationExt","title":"NotificationExt","text":"<p>tauri_plugin_notification::NotificationExt</p> <p>Methods:</p> Name Description <code>builder</code> <p>Create a new notification builder.</p>"},{"location":"reference/py/pytauri_plugins/notification/#pytauri_plugins.notification.NotificationExt.builder","title":"builder  <code>staticmethod</code>","text":"<pre><code>builder(slf: ImplNotificationExt) -&gt; NotificationBuilder\n</code></pre> <p>Create a new notification builder.</p> Source code in <code>python/pytauri/src/pytauri_plugins/notification/ffi.py</code> <pre><code>@staticmethod\ndef builder(slf: \"ImplNotificationExt\", /) -&gt; NotificationBuilder:\n    \"\"\"Create a new notification builder.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/","title":"ffi","text":""},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi","title":"pytauri_plugins.notification.ffi","text":"<p>Original FFI interface module.</p> <p>Warning</p> <p>All APIs under this module should not be considered stable. You should use the re-exported APIs under the top-level module.</p> <p>Classes:</p> Name Description <code>NotificationBuilderArgs</code> <p>tauri_plugin_notification::NotificationBuilder</p> <code>NotificationBuilder</code> <p>tauri_plugin_notification::NotificationBuilder</p> <code>NotificationExt</code> <p>tauri_plugin_notification::NotificationExt</p> <p>Attributes:</p> Name Type Description <code>ImplNotificationExt</code> <code>TypeAlias</code> <p>The implementers of <code>NotificationExt</code>.</p>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ImplNotificationExt', 'NotificationBuilder', 'NotificationBuilderArgs', 'NotificationExt']\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.ImplNotificationExt","title":"ImplNotificationExt  <code>module-attribute</code>","text":"<pre><code>ImplNotificationExt: TypeAlias = ImplManager\n</code></pre> <p>The implementers of <code>NotificationExt</code>.</p>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs","title":"NotificationBuilderArgs","text":"<p>               Bases: <code>TypedDict</code></p> <p>tauri_plugin_notification::NotificationBuilder</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <code>channel_id</code> <code>str</code> <code>title</code> <code>str</code> <code>body</code> <code>str</code> <code>large_body</code> <code>str</code> <code>summary</code> <code>str</code> <code>action_type_id</code> <code>str</code> <code>group</code> <code>str</code> <code>group_summary</code> <code>bool</code> <code>sound</code> <code>str</code> <code>inbox_line</code> <code>str</code> <code>icon</code> <code>str</code> <code>large_icon</code> <code>str</code> <code>icon_color</code> <code>str</code> <code>ongoing</code> <code>bool</code> <code>auto_cancel</code> <code>bool</code> <code>silent</code> <code>bool</code>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.channel_id","title":"channel_id  <code>instance-attribute</code>","text":"<pre><code>channel_id: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.large_body","title":"large_body  <code>instance-attribute</code>","text":"<pre><code>large_body: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.summary","title":"summary  <code>instance-attribute</code>","text":"<pre><code>summary: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.action_type_id","title":"action_type_id  <code>instance-attribute</code>","text":"<pre><code>action_type_id: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.group","title":"group  <code>instance-attribute</code>","text":"<pre><code>group: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.group_summary","title":"group_summary  <code>instance-attribute</code>","text":"<pre><code>group_summary: bool\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.sound","title":"sound  <code>instance-attribute</code>","text":"<pre><code>sound: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.inbox_line","title":"inbox_line  <code>instance-attribute</code>","text":"<pre><code>inbox_line: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.icon","title":"icon  <code>instance-attribute</code>","text":"<pre><code>icon: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.large_icon","title":"large_icon  <code>instance-attribute</code>","text":"<pre><code>large_icon: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.icon_color","title":"icon_color  <code>instance-attribute</code>","text":"<pre><code>icon_color: str\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.ongoing","title":"ongoing  <code>instance-attribute</code>","text":"<pre><code>ongoing: bool\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.auto_cancel","title":"auto_cancel  <code>instance-attribute</code>","text":"<pre><code>auto_cancel: bool\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilderArgs.silent","title":"silent  <code>instance-attribute</code>","text":"<pre><code>silent: bool\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilder","title":"NotificationBuilder","text":"<p>tauri_plugin_notification::NotificationBuilder</p> <p>Methods:</p> Name Description <code>show</code> <p>Consume this builder and show the notification.</p>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilder.show","title":"show","text":"<pre><code>show(**kwargs: Unpack[NotificationBuilderArgs]) -&gt; None\n</code></pre> <p>Consume this builder and show the notification.</p>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationBuilder.show--fixme-xxx-todo","title":"FIXME, XXX, TODO:","text":"<p>See: https://github.com/tauri-apps/tauri/issues/3700</p> <p>On windows, you must install the package via the <code>.msi</code> or <code>nsis</code>, or <code>tauri-plugin-notification</code> will not work.</p> <p>Tracker issue: https://github.com/tauri-apps/plugins-workspace/issues/2156</p> Source code in <code>python/pytauri/src/pytauri_plugins/notification/ffi.py</code> <pre><code>def show(self, /, **kwargs: Unpack[NotificationBuilderArgs]) -&gt; None:\n    \"\"\"Consume this builder and show the notification.\n\n    # FIXME, XXX, TODO:\n\n    See: &lt;https://github.com/tauri-apps/tauri/issues/3700&gt;\n\n    On windows, you must install the package via the `.msi` or `nsis`, or `tauri-plugin-notification` will not work.\n\n    Tracker issue: &lt;https://github.com/tauri-apps/plugins-workspace/issues/2156&gt;\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationExt","title":"NotificationExt","text":"<p>tauri_plugin_notification::NotificationExt</p> <p>Methods:</p> Name Description <code>builder</code> <p>Create a new notification builder.</p>"},{"location":"reference/py/pytauri_plugins/notification/ffi/#pytauri_plugins.notification.ffi.NotificationExt.builder","title":"builder  <code>staticmethod</code>","text":"<pre><code>builder(slf: ImplNotificationExt) -&gt; NotificationBuilder\n</code></pre> <p>Create a new notification builder.</p> Source code in <code>python/pytauri/src/pytauri_plugins/notification/ffi.py</code> <pre><code>@staticmethod\ndef builder(slf: \"ImplNotificationExt\", /) -&gt; NotificationBuilder:\n    \"\"\"Create a new notification builder.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri_wheel/","title":"pytauri_wheel","text":""},{"location":"reference/py/pytauri_wheel/#pytauri_wheel","title":"pytauri_wheel","text":"<p>PyTauri precompiled wheels.</p> <p>Due to the limitations of circular imports, we cannot import the <code>pytauri</code> module in <code>__init__.py</code>, so the related APIs are placed in the pytauri_wheel.lib module.</p> <p>Modules:</p> Name Description <code>lib</code> <p>PyTauri precompiled wheels.</p>"},{"location":"reference/py/pytauri_wheel/lib/","title":"lib","text":""},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib","title":"pytauri_wheel.lib","text":"<p>PyTauri precompiled wheels.</p>"},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib--usage","title":"Usage","text":"<p><code>pytauri-wheel</code> provides precompiled pytauri.EXT_MOD for pytauri, which means you can normally use the <code>pytauri</code> API, except for the following APIs provided by <code>pytauri-wheel</code>:</p> <ul> <li>pytauri.builder_factory -&gt; pytauri_wheel.lib.builder_factory</li> <li>pytauri.context_factory -&gt; pytauri_wheel.lib.context_factory</li> </ul> <p>Functions:</p> Name Description <code>builder_factory</code> <p>A factory function for creating a pytauri.Builder instance.</p> <code>context_factory</code> <p>Generate a <code>Context</code> based on <code>tauri.conf.json</code>, <code>capabilities/</code> and etc in the <code>src_tauri_dir</code> directory.</p>"},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['builder_factory', 'context_factory']\n</code></pre>"},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib.builder_factory","title":"builder_factory","text":"<pre><code>builder_factory(*, opener: bool = True, clipboard_manager: bool = True, dialog: bool = True, fs: bool = True, notification: bool = True) -&gt; Builder\n</code></pre> <p>A factory function for creating a pytauri.Builder instance.</p> <p>This is a type-hinted wrapper function for pytauri.builder_factory.</p> <p>Parameters:</p> Name Type Description Default <code>bool</code> <p>Whether to enable the plugin opener</p> <code>True</code> <code>bool</code> <p>Whether to enable the plugin clipboard-manager</p> <code>True</code> <code>bool</code> <p>Whether to enable the plugin dialog</p> <code>True</code> <code>bool</code> <p>Whether to enable the plugin fs</p> <code>True</code> <code>bool</code> <p>Whether to enable the plugin notification</p> <code>True</code> Source code in <code>python/pytauri-wheel/python/pytauri_wheel/lib.py</code> <pre><code>def builder_factory(\n    *,\n    opener: bool = True,\n    clipboard_manager: bool = True,\n    dialog: bool = True,\n    fs: bool = True,\n    notification: bool = True,\n) -&gt; Builder:\n    \"\"\"A factory function for creating a [pytauri.Builder][] instance.\n\n    This is a type-hinted wrapper function for [pytauri.builder_factory][].\n\n    Args:\n        opener: Whether to enable the plugin [opener]\n            [opener]: https://tauri.app/plugin/opener/\n        clipboard_manager: Whether to enable the plugin [clipboard-manager]\n            [clipboard-manager]: https://tauri.app/plugin/clipboard/\n        dialog: Whether to enable the plugin [dialog]\n            [dialog]: https://tauri.app/plugin/dialog/\n        fs: Whether to enable the plugin [fs]\n            [fs]: https://tauri.app/plugin/file-system/\n        notification: Whether to enable the plugin [notification]\n            [notification]: https://tauri.app/plugin/notification/\n    \"\"\"\n    return pytauri_builder_factory(\n        opener=opener,\n        clipboard_manager=clipboard_manager,\n        dialog=dialog,\n        fs=fs,\n        notification=notification,\n    )\n</code></pre>"},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib.builder_factory(opener)","title":"<code>opener</code>","text":""},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib.builder_factory(clipboard_manager)","title":"<code>clipboard_manager</code>","text":""},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib.builder_factory(dialog)","title":"<code>dialog</code>","text":""},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib.builder_factory(fs)","title":"<code>fs</code>","text":""},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib.builder_factory(notification)","title":"<code>notification</code>","text":""},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib.context_factory","title":"context_factory","text":"<pre><code>context_factory(src_tauri_dir: Path, /, *, tauri_config: Optional[str] = None) -&gt; Context\n</code></pre> <p>Generate a <code>Context</code> based on <code>tauri.conf.json</code>, <code>capabilities/</code> and etc in the <code>src_tauri_dir</code> directory.</p> <p>This type-hinted wrapper function for pytauri.context_factory.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>The absolute path of the pytauri project directory. In a typical Tauri project, it exists as the <code>src-tauri</code> directory; in the <code>pytauri-wheel</code> project, you only need to provide a similar file layout to <code>src-tauri</code>:     <pre><code>src-tauri/\n    __init__.py\n    tauri.conf.json\n    capabilities/\n    ...\n</code></pre></p> required <code>Optional[str]</code> <p>The config JSON string to be merged with <code>tauri.conf.json</code>, equivalent to the <code>--config</code> of <code>tauri-cli</code>. See: https://tauri.app/develop/configuration-files/#extending-the-configuration.</p> <code>None</code> Source code in <code>python/pytauri-wheel/python/pytauri_wheel/lib.py</code> <pre><code>def context_factory(\n    src_tauri_dir: Path, /, *, tauri_config: Optional[str] = None\n) -&gt; Context:\n    \"\"\"Generate a `Context` based on `tauri.conf.json`, `capabilities/` and etc in the `src_tauri_dir` directory.\n\n    This type-hinted wrapper function for [pytauri.context_factory][].\n\n    Args:\n        src_tauri_dir: The **absolute** path of the pytauri project directory.\n            In a typical Tauri project, it exists as the `src-tauri` directory;\n            in the `pytauri-wheel` project, you only need to provide a similar file layout to `src-tauri`:\n                ```text\n                src-tauri/\n                    __init__.py\n                    tauri.conf.json\n                    capabilities/\n                    ...\n                ```\n        tauri_config: The config JSON string to be merged with `tauri.conf.json`, equivalent to the `--config` of `tauri-cli`.\n            See: &lt;https://tauri.app/develop/configuration-files/#extending-the-configuration&gt;.\n    \"\"\"\n    if not src_tauri_dir.is_absolute():\n        raise ValueError(\"`src_tauri_dir` must be an absolute path.\")\n\n    return pytauri_context_factory(src_tauri_dir, tauri_config=tauri_config)\n</code></pre>"},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib.context_factory(src_tauri_dir)","title":"<code>src_tauri_dir</code>","text":""},{"location":"reference/py/pytauri_wheel/lib/#pytauri_wheel.lib.context_factory(tauri_config)","title":"<code>tauri_config</code>","text":""},{"location":"usage/using-unreleased-commits/","title":"Using Unreleased Commits","text":"<p>Since <code>v0.5</code>, all <code>pytauri</code> packages support installation from a Git repository via branch, commit <code>SHA</code>, or PR (pull request).</p>"},{"location":"usage/using-unreleased-commits/#install-rust-crate-from-source","title":"Install Rust crate from source","text":"<p>ref: https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html#the-patch-section</p> <p>Append this to your <code>Cargo.toml</code> file:</p> <pre><code>[patch.crates-io]\npytauri = { git = \"https://github.com/pytauri/pytauri.git\", branch = \"main\" }\npytauri-core = { git = \"https://github.com/pytauri/pytauri.git\", branch = \"main\" }\ntauri-plugin-pytauri = { git = \"https://github.com/pytauri/pytauri.git\", branch = \"main\" }\n# other pytauri dependencies which you need ...\n</code></pre> <p>This will force all your dependencies to use <code>pytauri</code> from Git instead of <code>crates.io</code>.</p>"},{"location":"usage/using-unreleased-commits/#install-python-package-from-source","title":"Install Python package from source","text":"<p>ref: https://docs.astral.sh/uv/concepts/projects/dependencies/#dependency-sources</p> <p>Append this to your <code>pyproject.toml</code> file:</p> <pre><code>[tool.uv.sources]\npytauri = { git = 'https://github.com/pytauri/pytauri.git', branch = \"main\", subdirectory = \"python/pytauri\" }\n# other pytauri dependencies which you need ...\n</code></pre> <p>Tip</p> <p>You can check the <code>[tool.uv.workspace]</code> section in pyproject.toml to find the <code>subdirectory</code> for each package.</p>"},{"location":"usage/using-unreleased-commits/#install-js-package-from-source","title":"Install JS package from source","text":"<p>Inspired by: https://vite.dev/guide/#using-unreleased-commits</p> <p>Thanks to https://pkg.pr.new/, you can install JS package from specific branch, commit <code>SHA</code>, or PR with:</p> <pre><code># or pnpm, yarn, bun, whatever\nnpm i https://pkg.pr.new/tauri-plugin-pytauri-api@main\n</code></pre> <p>Tip</p> <p>To replace the pytauri version used by dependencies transitively, you should use npm overrides or pnpm overrides.</p>"},{"location":"usage/concepts/ipc/","title":"IPC","text":""},{"location":"usage/concepts/ipc/#calling-python-from-the-frontend","title":"Calling Python from the Frontend","text":"<p>Ref:</p> <ul> <li>https://tauri.app/develop/calling-rust/</li> <li>pytauri.ipc.Commands</li> </ul> <p>pytauri implements IPC API consistent with rust tauri. Reading tauri's documentation is like reading pytauri's documentation.</p>"},{"location":"usage/concepts/ipc/#commands","title":"Commands","text":""},{"location":"usage/concepts/ipc/#registering-commands","title":"Registering Commands","text":"<p>You can register a command handler using the decorator @Commands.command.</p> <p>Similar to <code>tauri::command!</code>, the <code>handler</code> signature can be arbitrary. We will use inspect.signature to inspect its signature and dynamically pass the required parameters.</p> <p>Info</p> <p>You might have seen this pattern in <code>FastAPI</code>\ud83e\udd13.</p> <p>The currently supported signature pattern is ArgumentsType. You must ensure that the parameter names and type annotations are correct, and <code>@Commands.command</code> will check them.</p> <pre><code># pyright: reportRedeclaration=none\n# ruff: noqa: F811\n\nfrom pytauri import AppHandle, Commands\n\ncommands = Commands()\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: bytes) -&gt; bytes: ...\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: bytes, app_handle: AppHandle) -&gt; bytes: ...\n\n\n# \ud83d\udca5 ERROR: missing/wrong type annotation\n@commands.command()\nasync def command(\n    body: bytes,\n    app_handle,  # pyright: ignore[reportUnknownParameterType, reportMissingParameterType]  # noqa: ANN001\n) -&gt; bytes: ...\n\n\n# \ud83d\udca5 ERROR: wrong parameter name\n@commands.command()\nasync def command(body: bytes, foo: AppHandle) -&gt; bytes: ...\n\n\n# \ud83d\udca5 ERROR: not an async function\n@commands.command()  # pyright: ignore[reportArgumentType, reportUntypedFunctionDecorator]\ndef command(body: bytes) -&gt; bytes: ...\n</code></pre>"},{"location":"usage/concepts/ipc/#deserializing-the-body-using-basemodel","title":"Deserializing the Body using <code>BaseModel</code>","text":"<p>For the <code>body</code> argument, it is of type <code>bytes</code>, allowing you to pass binary data such as files between the frontend and backend.</p> <p>However, in most cases, we want strong type checking when calling. Rust <code>tauri</code> achieves this through <code>serde</code>, while <code>pytauri</code> uses pydantic.</p> <p>Info</p> <p><code>pydantic</code> is a super-fast Python validation and serialization library written in <code>rust</code>/<code>pyo3</code> \ud83e\udd13.</p> <p>If you use BaseModel/RootModel as the type annotation for the <code>body</code> parameter/return value, pytauri will automatically serialize/deserialize it for you:</p> <pre><code># pyright: reportRedeclaration=none\n# ruff: noqa: F811\n\nfrom pydantic import BaseModel, RootModel\nfrom pytauri import AppHandle, Commands\n\ncommands = Commands()\n\n\nclass Input(BaseModel):\n    foo: str\n    bar: int\n\n\nOutput = RootModel[list[str]]\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: Input, app_handle: AppHandle) -&gt; Output: ...\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: Input) -&gt; bytes: ...\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: bytes) -&gt; Output: ...\n</code></pre>"},{"location":"usage/concepts/ipc/#deserializing-the-body-using-arbitrary-types","title":"Deserializing the Body using arbitrary types","text":"<p>Info</p> <p>This is an experimental feature. If we find that it causes more problems than benefits, it may be removed in the future. You may also encounter some bugs\u2014please report them on GitHub issues!</p> <p>For types like <code>str</code>, it would be cumbersome to explicitly declare <code>StrModel = RootModel[str]</code> every time. Since pytauri <code>v0.7</code>, if you use types other than <code>bytes</code>/<code>BaseModel</code>/<code>RootModel</code> as the type annotation for the <code>body</code> parameter or return value, pytauri will automatically convert them to BaseModel/TypeAdapter behind the scenes.</p> <pre><code># pyright: reportRedeclaration=none\n# ruff: noqa: F811\n\nfrom datetime import datetime\nfrom typing import Optional, Union\n\nfrom pydantic import RootModel\nfrom pytauri import AppHandle, Commands\n\ncommands = Commands()\n\nStrModel = RootModel[str]\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: datetime, app_handle: AppHandle) -&gt; None: ...\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: Union[str, int]) -&gt; bytes: ...\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: Optional[str]) -&gt; StrModel: ...\n\n\n# \u2b50 OK\n@commands.command()\nasync def command() -&gt; bool: ...\n</code></pre> Implementation details <p>These are the current implementation details (which may change in the future). This means you need to pay attention to the lru_cache cache missing issue:</p> <pre><code>from functools import cache\nfrom typing import Any, Optional, cast\n\nfrom pydantic import BaseModel, RootModel\n\n__all__ = [\"to_model\"]\n\n\ndef to_model(type_: Any) -&gt; Optional[type[RootModel[Any]]]:\n    if type_ is bytes:\n        return\n    if isinstance(type_, type) and issubclass(type_, BaseModel):\n        return\n\n    type_ = cast(Any, type_)  # make pyright happy\n    return _to_model_cache(type_)\n\n\n@cache\ndef _to_model_cache(type_: Any) -&gt; type[RootModel[Any]]:\n    return RootModel[type_]\n</code></pre>"},{"location":"usage/concepts/ipc/#generate-invoke-handler-for-app","title":"Generate Invoke Handler for App","text":"<p>To execute async commands, we need an async runtime. We use anyio.from_thread.BlockingPortal as the async runtime in a child thread (the main thread is used for the Tauri app's event loop).</p> <p>Refer to the anyio docs for more information.</p> <p>You can obtain a <code>BlockingPortal</code> as follows:</p> <ul> <li>anyio.from_thread.start_blocking_portal</li> <li>anyio.from_thread.BlockingPortalProvider</li> </ul> <p>After that, you generate an <code>invoke_handler</code> and pass it to the <code>App</code>, similar to Rust's <code>tauri::generate_handler</code>:</p> <pre><code>from anyio.from_thread import start_blocking_portal\nfrom pytauri import Commands, builder_factory, context_factory\n\ncommands = Commands()\n\n\nwith start_blocking_portal(\"asyncio\") as portal:  # or \"trio\"\n    builder = builder_factory()\n    app = builder.build(\n        context_factory(),\n        invoke_handler=commands.generate_handler(portal),\n    )\n    exit_code = app.run_return()\n</code></pre> <p>The key point here is that you must not close the <code>BlockingPortal</code> (i.e., do not exit the context manager) while App.run is still running.</p> <p>If you want to obtain this <code>invoke_handler</code> and keep the <code>BlockingPortal</code> running, you can use contextlib.ExitStack to achieve this:</p> <pre><code>from contextlib import ExitStack\nfrom sys import exc_info\n\nfrom anyio.from_thread import start_blocking_portal\nfrom pytauri import Commands\n\ncommands = Commands()\n\nexit_stack = ExitStack()\nportal = exit_stack.enter_context(start_blocking_portal(\"asyncio\"))\n\n\n# \ud83d\udc49 the `invoke_handler` will keep available until the `ExitStack` is closed\ninvoke_handler = commands.generate_handler(portal)\n\n\"\"\"do some stuff ...\"\"\"\n\n# \ud83d\udc49 then remember to close the `ExitStack` to exit the portal\nexit_stack.__exit__(*exc_info())\n</code></pre> <p>You can also spawn tasks in the async runtime (in the child thread) from the main thread in a thread-safe manner using the <code>portal</code>: https://anyio.readthedocs.io/en/stable/threads.html#spawning-tasks-from-worker-threads</p>"},{"location":"usage/concepts/ipc/#calling-commands","title":"Calling Commands","text":"<pre><code>import { pyInvoke } from \"tauri-plugin-pytauri-api\";\n// or if tauri config `app.withGlobalTauri = true`:\n//\n// ```js\n// const { pyInvoke } = window.__TAURI__.pytauri;\n// ```\n\nconst output = await pyInvoke&lt;string&gt;(\"command\", { foo: \"foo\", bar: 42 });\n</code></pre> <p>The usage of <code>pyInvoke</code> is exactly the same as Tauri's <code>invoke</code>:</p> <ul> <li>https://tauri.app/develop/calling-rust/#basic-example</li> <li>https://tauri.app/reference/javascript/api/namespacecore/#invoke</li> </ul>"},{"location":"usage/concepts/ipc/#returning-errors-to-the-frontend","title":"Returning Errors to the Frontend","text":"<p>Similar to <code>FastAPI</code>, as long as you throw an InvokeException in the <code>command</code>, the promise will reject with the error message.</p> <pre><code>from pytauri import Commands\nfrom pytauri.ipc import InvokeException\n\ncommands = Commands()\n\n\n@commands.command()\nasync def command() -&gt; None:\n    raise InvokeException(\"error message\")\n</code></pre>"},{"location":"usage/concepts/ipc/#accessing-request-headers","title":"Accessing Request Headers","text":"<p>ref: https://tauri.app/develop/calling-rust/#accessing-raw-request</p> <p>When passing binary data, you may find it useful to send and access custom request headers:</p> <pre><code>from pytauri import Commands\nfrom pytauri.ipc import Headers\n\ncommands = Commands()\n\n\n@commands.command()\nasync def command(body: bytes, headers: Headers) -&gt; None:  # noqa: ARG001\n    print(headers)\n</code></pre> <pre><code>import { pyInvoke } from \"tauri-plugin-pytauri-api\";\n\nconst buffer = new ArrayBuffer(16);\nconst output = await pyInvoke&lt;null&gt;(\"command\", buffer, {\n  headers: {\n    foo: \"bar\"\n  }\n});\n</code></pre>"},{"location":"usage/concepts/ipc/#calling-frontend-from-python","title":"Calling Frontend from Python","text":"<p>Ref:</p> <ul> <li>https://tauri.app/develop/calling-frontend/</li> <li>pytauri.ipc.JavaScriptChannelId and pytauri.ipc.Channel</li> <li>pytauri.webview.WebviewWindow.eval</li> </ul>"},{"location":"usage/concepts/ipc/#channels","title":"Channels","text":"<p>Channels are designed to be fast and deliver ordered data. They are used internally for streaming operations such as download progress, child process output, and WebSocket messages.</p> <p>To use a <code>channel</code>, you only need to add the JavaScriptChannelId field to the <code>BaseModel</code>/<code>RootModel</code>, and then use JavaScriptChannelId.channel_on to get a Channel instance.</p> <p>Info</p> <p><code>JavaScriptChannelId</code> itself is a <code>RootModel</code>, so you can directly use it as the <code>body</code> parameter.</p> <pre><code>from pydantic import RootModel\nfrom pytauri import Commands\nfrom pytauri.ipc import Channel, JavaScriptChannelId\nfrom pytauri.webview import WebviewWindow\n\ncommands = Commands()\n\nMsg = RootModel[str]\n\n\n@commands.command()\nasync def command(\n    body: JavaScriptChannelId[Msg], webview_window: WebviewWindow\n) -&gt; None:\n    channel: Channel[Msg] = body.channel_on(webview_window.as_ref_webview())\n\n    # \ud83d\udc47 you should do this as background task, here just keep it simple as a example\n    channel.send_model(Msg(\"message\"))\n</code></pre> <pre><code>import { pyInvoke } from \"tauri-plugin-pytauri-api\";\nimport { Channel } from \"@tauri-apps/api/core\";\n// const { pyInvoke } = window.__TAURI__.pytauri;\n// const { Channel } = window.__TAURI__.core;\n\nconst channel = new Channel&lt;string&gt;((msg) =&gt; console.log(msg));\n\nawait pyInvoke(\"command\", channel);\n</code></pre>"},{"location":"usage/concepts/ipc/#evaluating-javascript","title":"Evaluating JavaScript","text":"<p>You can use WebviewWindow.eval to evaluate JavaScript code in the frontend.</p>"},{"location":"usage/concepts/ipc/#event-system","title":"Event System","text":"<p>Ref:</p> <ul> <li>https://tauri.app/develop/calling-frontend/#event-system</li> <li>https://tauri.app/develop/calling-rust/#event-system</li> <li>pytauri.Listener</li> <li>pytauri.Emitter</li> </ul> <p>Tauri ships a simple event system you can use to have bi-directional communication between Rust and your frontend.</p> <p>The event system was designed for situations where small amounts of data need to be streamed or you need to implement a multi consumer multi producer pattern (e.g. push notification system).</p> <p>The event system is not designed for low latency or high throughput situations. See the channels section for the implementation optimized for streaming data.</p> <p>The major differences between a Tauri command and a Tauri event are that events have no strong type support, event payloads are always JSON strings making them not suitable for bigger messages and there is no support of the capabilities system to fine grain control event data and channels.</p> <p>See:</p> <ul> <li>pytauri.Listener--examples</li> <li>pytauri.Emitter--examples</li> </ul>"},{"location":"usage/concepts/mutiprocessing/","title":"Using multiprocessing","text":"<p>When building as a <code>standalone</code> app, <code>pytauri</code> will automatically configure the following to support the use of multiprocessing:</p> <p>ref: pytauri::standalone::PythonInterpreterBuilder</p> <ul> <li>Set <code>sys.frozen</code> to <code>True</code></li> <li>Call multiprocessing.set_start_method with<ul> <li>windows: <code>spawn</code></li> <li>unix: <code>fork</code></li> </ul> </li> <li>Call multiprocessing.set_executable with <code>std::env::current_exe()</code></li> </ul> <p>What you need to do is call multiprocessing.freeze_support in <code>__main__.py</code> or in the <code>if __name__ == \"__main__\":</code> block.</p> <p>If you don't do this, you will get an endless spawn loop of your application process.</p> <p>See: https://pyinstaller.org/en/v6.11.1/common-issues-and-pitfalls.html#multi-processing.</p>"},{"location":"usage/pytauri-wheel/","title":"PyTauri Wheel","text":"<p>The <code>pytauri-wheel</code> is built using the method described in <code>tutorial/build-wheel</code> to provide a precompiled pytauri.EXT_MOD. This means you can use pytauri without writing any Rust code and needing a Rust compiler.</p>"},{"location":"usage/pytauri-wheel/#installation","title":"Installation","text":""},{"location":"usage/pytauri-wheel/#pypi","title":"PyPi","text":""},{"location":"usage/pytauri-wheel/#prerequisites","title":"Prerequisites","text":"windowslinuxmacOS <p>Install WebView2 by visiting the WebView2 Runtime download section. Download the \"Evergreen Bootstrapper\" and install it.</p> <p>As mentioned in https://tauri.app/distribute/debian/#debian:</p> <ul> <li><code>libwebkit2gtk-4.1-0</code></li> <li><code>libgtk-3-0</code></li> <li><code>libappindicator3-1</code></li> </ul> <p>Nothing</p>"},{"location":"usage/pytauri-wheel/#wheel","title":"Wheel","text":"<p>We provide precompiled Wheels for the following platforms and supported Python versions:</p> OS Arch windows-2022 x64 windows-11 arm64<sup>1</sup> manylinux_2_35 x64, arm64 macOS-13 intel macOS-14 arm64 <pre><code>pip install \"pytauri-wheel == 0.6.*\"  # (1)!\n</code></pre> <ol> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> </ol>"},{"location":"usage/pytauri-wheel/#sdist","title":"Sdist","text":"<p>If the above platform and Python version requirements are not met, the <code>Wheel</code> will be automatically built (compiled) from the <code>source distribution</code> when installing from <code>pypi</code>.</p> <p>This requires you to meet the <code>tutorial/#prerequisites</code>.</p>"},{"location":"usage/pytauri-wheel/#usage","title":"Usage","text":"<p>The development experience of <code>pytauri-wheel</code> is almost the same as Rust <code>tauri</code>. You can find a complete example in <code>examples/tauri-app-wheel</code>.</p>"},{"location":"usage/pytauri-wheel/#tauri-config","title":"Tauri Config","text":"<p>First, we need to create a <code>Tauri.toml</code>, refer to https://tauri.app/develop/configuration-files/#tauri-config:</p> /Tauri.toml<pre><code>\"$schema\" = \"https://schema.tauri.app/config/2\"\nproductName = \"pytauri-wheel-app\"\nversion = \"0.1.0\"\nidentifier = \"com.pytauri-wheel-app.app\"\n\n[build]\nfrontendDist = \"./frontend\"\n\n[app]\nwithGlobalTauri = true\n\n[[app.windows]]\ntitle = \"pytauri-wheel-app\"\nwidth = 800\nheight = 600\n</code></pre> <p>Tip</p> <p><code>pytauri-wheel</code> also support <code>tauri.conf.json</code> and <code>tauri.conf.json</code> and <code>tauri.linux.conf.json</code> and etc.</p>"},{"location":"usage/pytauri-wheel/#capabilities","title":"Capabilities","text":"<p>Refer to\uff1a</p> <ul> <li>https://tauri.app/security/capabilities/</li> <li><code>tutorial/py-js-ipc</code></li> </ul> <p>Create the following capabilities file to enable <code>ipc</code> permissions:</p> /capabilities/default.toml<pre><code># \"$schema\" = \"...\"  # we do not support this feature yet\nidentifier = \"default\"\ndescription = \"Capability for the main window\"\nwindows = [\"main\"]\npermissions = [\n    \"core:default\",\n    \"pytauri:default\", # need for pytauri ipc\n    \"dialog:default\"\n]\n</code></pre> <p>Tip</p> <p><code>pytauri-wheel</code> also support <code>json</code> and <code>json5</code> capabilities files.</p>"},{"location":"usage/pytauri-wheel/#pytauri-wheel-app","title":"PyTauri Wheel App","text":"<p>The final step, refer to:</p> <ul> <li><code>tutorial/using-pytauri</code></li> <li><code>tutorial/py-js-ipc/</code></li> <li>pytauri API</li> <li>pytauri_wheel API</li> </ul> /main.py<pre><code>import json\nimport sys\nfrom os import environ\nfrom pathlib import Path\n\nfrom anyio.from_thread import start_blocking_portal\nfrom pytauri import Commands\nfrom pytauri_wheel.lib import builder_factory, context_factory\n\nSRC_TAURI_DIR = Path(__file__).parent.absolute()\n\"\"\"In rust tauri project, it's usually `src-tauri` dir.\n\n\ud83d\udcc1 {SRC_TAURI_DIR}/\n\u251c\u2500\u2500 \ud83d\udcc1 capabilities/\n\u251c\u2500\u2500 \ud83d\udcc4 tauri.conf.json\n\u2514\u2500\u2500 ...\n\"\"\"\n\nDEV_SERVER = environ.get(\"DEV_SERVER\")\n\"\"\"Whether to use frontend dev server to serve frontend assets.\n\ne.g, `Vite` dev server on `http://localhost:1420`.\n\"\"\"\n\ncommands = Commands()\n\n\n@commands.command()\nasync def greet() -&gt; str:\n    return sys.version\n\n\nif DEV_SERVER is not None:\n    # ref: &lt;https://tauri.app/reference/config/#frontenddist-1&gt;\n    tauri_config = json.dumps(\n        {\n            \"build\": {\n                \"frontendDist\": DEV_SERVER,\n            },\n        }\n    )\nelse:\n    tauri_config = None\n\n\ndef main() -&gt; int:\n    with start_blocking_portal(\"asyncio\") as portal:  # or `trio`\n        app = builder_factory().build(\n            context=context_factory(SRC_TAURI_DIR, tauri_config=tauri_config),\n            invoke_handler=commands.generate_handler(portal),\n        )\n        exit_code = app.run_return()\n        return exit_code\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n</code></pre> <p>Note</p> <p>The frontend assets directory must the same as the one in <code>Tauri.toml</code>.</p> /frontend/index.html<pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n        &lt;title&gt;PyTauri-Wheel-App&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;button onclick=\"greet()\"&gt;Click me&lt;/button&gt;\n        &lt;script&gt;\n            // \ud83e\udd13 NOTE: you must set `[app.withGlobalTauri] = true` in `Tauri.toml,\n            // or you can't use `window.__TAURI__` in the frontend.\n            async function greet() {\n                const message =\n                    await window.__TAURI__.pytauri.pyInvoke(\"greet\");\n                alert(message);\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>You get following directory structure:</p> <pre><code>\ud83d\udcc1 {SRC_TAURI_DIR}\n\u251c\u2500\u2500 \ud83d\udcc1 capabilities\n\u2502   \u2514\u2500\u2500\u2500 \ud83d\udcc4 default.toml\n\u251c\u2500\u2500 \ud83d\udcc1 frontend\n\u2502   \u2514\u2500\u2500\u2500 \ud83d\udcc4 index.html\n\u251c\u2500\u2500 \ud83d\udcc4 Tauri.toml\n\u2514\u2500\u2500 \ud83d\udcc4 main.py\n</code></pre> <p>Then run the app:</p> <pre><code>python main.py\n</code></pre>"},{"location":"usage/pytauri-wheel/#development-mode","title":"Development Mode","text":"<p>If you want to use frontend dev server such as <code>vite</code> in development, or you want to dynamically/programmatically set tarui config, please refer to pytauri_wheel.lib.context_factory(tauri_config)</p>"},{"location":"usage/pytauri-wheel/#tauri-plugins","title":"Tauri Plugins","text":"<p><code>pytauri-wheel</code> enables a set of Tauri plugins during compilation, please refer to pytauri_wheel.lib.builder_factory.</p> <p>For example, the tauri-plugin-dialog can be used in the frontend as follows:</p> <pre><code>import { ask } from '@tauri-apps/plugin-dialog';\n// when using `\"withGlobalTauri\": true`, you may use\n// const { ask } = window.__TAURI__.dialog;\n</code></pre> <p>Warning</p> <p>Remember to enable the permissions for these plugins in <code>/capabilities</code>, otherwise you will receive an error on the frontend.</p> <p>Additionally, <code>pytauri-wheel</code> has integrated all the plugins from pytauri_plugins, making it easy for you to use them through the Python API.</p> <ol> <li> <p>Only Python &gt;= 3.11 supports arm64 on Windows, refer to setup-python and python-build-standalone.\u00a0\u21a9</p> </li> </ol>"},{"location":"usage/tutorial/","title":"Prerequisites","text":"<p>For Pythoneer</p> <p>For pure Python (i.e., without Rust) development, you might prefer to use pytauri-wheel \u2728.</p>"},{"location":"usage/tutorial/#platforms","title":"Platforms","text":"<ul> <li>Tier 1: my(author's) primary development environment<ul> <li>Windows 10</li> </ul> </li> <li>Tier 2: will got bugs fixed and tested on ci<ul> <li>Linux (WSL2)</li> </ul> </li> <li>Tier 3: will not be tested, may not work<ul> <li>MacOS</li> <li>Windows 7</li> </ul> </li> </ul> <p>Info</p> <p>I do not have MacOS, so I cannot debug issues on MacOS. That is why it is in Tier 3.</p> <p>If you would like better support for MacOS, please consider becoming a maintainer.</p>"},{"location":"usage/tutorial/#python","title":"Python","text":"<p>We support all Python versions that are currently in their lifecycle. The current version is <code>&gt;= 3.9</code>.</p> <p>https://www.python.org/downloads/</p> <p>Warning</p> <p>For linux development, you need to ensure that your Python installation contains a shared library.</p> <p>To install the Python shared library on Ubuntu: <code>sudo apt install python3-dev</code>.</p> <p>To install the Python shared library on RPM based distributions (e.g. Fedora, Red Hat, SuSE), install the <code>python3-devel</code> package.</p>"},{"location":"usage/tutorial/#rust","title":"Rust","text":"<p>The latest stable version.</p> <p>https://www.rust-lang.org/tools/install</p> <p>for python developers</p> <p>You can upgrade your existing Rust version by running <code>rustup update stable</code>.</p>"},{"location":"usage/tutorial/#system-dependencies","title":"System Dependencies","text":"<ul> <li>Tauri Prerequisites</li> </ul>"},{"location":"usage/tutorial/build-sdist/","title":"Build python source (sdist) distribution","text":""},{"location":"usage/tutorial/build-sdist/#setuptools-rust","title":"setuptools-rust","text":"<p>When you want to distribute your app in Python format, you need to compile pytauri into a Python extension module file, instead of providing it in memory through <code>pytauri::standalone::append_ext_mod</code> in the <code>main.rs</code> executable.</p> <p>To do this, we need to use setuptools-rust.</p> <p>Add it to <code>[build-system]</code>:</p> src-tauri/pyproject.toml<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61\", \"setuptools-rust==1.*\"]\nbuild-backend = \"setuptools.build_meta\"\n</code></pre> <p>And add the following file:</p> src-tauri/setup.py<pre><code>\"\"\"See: &lt;https://setuptools-rust.readthedocs.io/en/latest/setuppy_tutorial.html&gt;\"\"\"\n\nfrom os import getenv\n\nfrom setuptools import setup\nfrom setuptools_rust import RustExtension\n\nPYTAURI_STANDALONE = getenv(\"PYTAURI_STANDALONE\") == \"1\"\n\"\"\"Instead of building pytauri as an extension module file, it will be loaded in memory through Rust's `append_ext_mod`\"\"\"\n\nsetup(\n    rust_extensions=[\n        RustExtension(\n            # set `target` the same as `[project.entry-points.pytauri.ext_mod]` in `pyproject.toml`\n            target=\"tauri_app.ext_mod\",\n            # It is recommended to set other features in `Cargo.toml`, except the following features:\n            features=[\n                # see: &lt;https://pyo3.rs/v0.23.3/building-and-distribution.html#the-extension-module-feature&gt;,\n                # required to build the extension module\n                \"pyo3/extension-module\",\n                # This feature tells Tauri to use embedded frontend assets instead of using a frontend development server.\n                # Usually, this feature is enabled by `tauri-cli`, here we enable it manually.\n                \"tauri/custom-protocol\",\n            ],\n        )\n    ]\n    if not PYTAURI_STANDALONE\n    else [],\n)\n</code></pre>"},{"location":"usage/tutorial/build-sdist/#include-frontend-assets","title":"Include frontend assets","text":"<p>You need to include the frontend assets in the sdist so that users can build your app from the source.</p> <p>Configure Vite to output the frontend assets to <code>src-tauri/frontend</code>:</p> vite.config.ts<pre><code>// https://vitejs.dev/config/\nexport default defineConfig(async () =&gt; ({\n  build: {\n    // build dist into `src-tauri/` so that we can include it in Python sdist\n    outDir: \"src-tauri/frontend\",\n  },\n}));\n</code></pre> <p>Also, let tauri-cli know where the frontend assets are:</p> src-tauri/tauri.conf.json<pre><code>{\n  \"build\": {\n    \"frontendDist\": \"./frontend\"\n  },\n}\n</code></pre> <p>Include the frontend assets in the sdist:</p> <p>ref: https://setuptools.pypa.io/en/latest/userguide/miscellaneous.html</p> src-tauri/MANIFEST.in<pre><code>graft frontend/\n</code></pre>"},{"location":"usage/tutorial/build-sdist/#include-rust-files","title":"Include rust files","text":"<p>You will also need to tell Setuptools that the Rust files are required to build your project from the source distribution. That can be done either via <code>MANIFEST.in</code> or via a plugin like setuptools-scm.</p> setuptools-scmMANIFEST.in <p>Use <code>setuptools-scm</code> to include all files tracked by <code>git</code> (just add it as a dependency):</p> src-tauri/pyproject.toml<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61\", \"setuptools-rust==1.*\", \"setuptools_scm&gt;=8\"]\nbuild-backend = \"setuptools.build_meta\"\n</code></pre> <p>Info</p> <p>Normally, we do not track <code>src-tauri/frontend</code>, which is why we use <code>MANIFEST.in</code> to include it.</p> src-tauri/MANIFEST.in<pre><code>graft frontend/\ngraft capabilities/\ngraft icons/\ngraft src/\ninclude Cargo.toml\ninclude Cargo.lock\ninclude build.rs\ninclude tauri.conf.json\n</code></pre>"},{"location":"usage/tutorial/build-sdist/#build-sdist","title":"Build sdist","text":"<ul> <li> <p>Build frontend assets first: <code>pnpm build</code> (see <code>build.beforeBuildCommand</code> in <code>tau.conf.json</code>).</p> </li> <li> <p>Now you can build only sdist: <code>uv build src-tauri --sdist</code>.</p> <ul> <li>Or build both wheel and sdist: <code>uv build src-tauri</code>.</li> </ul> <p>Tip</p> <p>As long as you can build the wheel with <code>uv build src-tauri</code>, it means your Python sdist can be used normally. Otherwise, you might have forgotten to include some Rust files.</p> </li> </ul>"},{"location":"usage/tutorial/build-standalone-cython/","title":"Use <code>Cython</code> to Protect Source Code","text":"<p>When you use <code>uv pip install</code> to install your project into <code>pyembed/python</code>, your Python code is distributed as-is.</p> <p>If you want to protect your source code, you can use <code>Cython</code> or <code>Nuitka</code> to compile your Python code into binary modules.</p> <p>We recommend <code>Cython</code> because it integrates well with the <code>setuptools</code> used by PyTauri.</p> <p></p>"},{"location":"usage/tutorial/build-standalone-cython/#usage","title":"Usage","text":"<p>First, ensure that you meet the prerequisites for <code>Cython</code>.</p> <p>Then, add <code>Cython</code> as a build dependency:</p> src-tauri/pyproject.toml<pre><code>[build-system]\nrequires = [\n    # ...\n    \"Cython&gt;=3\",\n]\nbuild-backend = \"setuptools.build_meta\"\n</code></pre> <p>Add the following content to <code>setup.py</code>. Pay attention to the following parameters and their comments:</p> <ul> <li><code>USE_CYTHON</code></li> <li><code>SRC_PREFIX</code></li> <li><code>INCLUDE_FILE_PATTERNS</code></li> <li><code>EXCLUDE_FILE_PATTERNS</code></li> </ul> src-tauri/setup.py<pre><code>\"\"\"See: &lt;https://setuptools-rust.readthedocs.io/en/latest/setuppy_tutorial.html&gt;\"\"\"\n\nfrom collections.abc import Sequence\nfrom importlib.util import cache_from_source\nfrom logging import getLogger\nfrom os import getenv\nfrom os.path import abspath, normcase\nfrom pathlib import Path\n\nfrom Cython.Build import (  # pyright: ignore[reportMissingTypeStubs]\n    cythonize,  # pyright: ignore[reportUnknownVariableType]\n)\nfrom setuptools import setup\nfrom setuptools.command.install import install as _install\nfrom setuptools_rust import RustExtension\n\n########## Inputs ##########\n\nPYTAURI_STANDALONE = getenv(\"PYTAURI_STANDALONE\") == \"1\"\n\"\"\"Instead of building pytauri as a extension module file, it will be loaded in memory through Rust's `append_ext_mod`\"\"\"\n\nUSE_CYTHON = getenv(\"USE_CYTHON\") == \"1\"\n\"\"\"Whether to use Cython to compile the Python code into C extension module to protect the source code.\"\"\"\n\n\nSRC_PREFIX = \"python/\"\n# The glob pattern of the source files you want to protect,\n# or you can set it to `\"tauri_app/**/*.py\"` to protect all Python files in the project.\nINCLUDE_FILE_PATTERNS = (\"tauri_app/private.py\",)\n# Usually we dont need to protect the `**/__init__.py` files.\n# NOTE: you must exclude `**/__main__.py`: &lt;https://groups.google.com/g/cython-users/c/V-i0a8r-x00&gt;.\nEXCLUDE_FILE_PATTERNS = (\"tauri_app/**/__init__.py\", \"tauri_app/**/__main__.py\")\n\n##############################\n\n\n_logger = getLogger(__name__)\n\n\nclass install(_install):  # noqa: N801\n    \"\"\"Subclass `setuptools.command.install` to exclude protected files in the Wheel.\n\n    ref: &lt;https://setuptools.pypa.io/en/latest/userguide/extension.html&gt;\n    \"\"\"\n\n    def run(self) -&gt; None:\n        \"\"\"Remove protected files after installation and before writing into the Wheel,\n        to prevent them from being packaged into the Wheel.\"\"\"\n\n        super().run()  # pyright: ignore[reportUnknownMemberType]\n\n        # skip if `pip install -e`\n        build_py_obj = self.distribution.get_command_obj(\"build_py\")\n        build_py_obj.ensure_finalized()\n        if build_py_obj.editable_mode:\n            return\n\n        # ref: &lt;https://github.com/pypa/setuptools/blob/6ead555c5fb29bc57fe6105b1bffc163f56fd558/setuptools/_distutils/command/install_lib.py#L115-L124&gt;\n        assert self.install_lib is not None\n        install_lib = Path(self.install_lib)\n\n        def norm_files_set(patterns: Sequence[str]) -&gt; set[str]:\n            \"\"\"Normalized set of file paths\"\"\"\n            files_set: set[str] = set()\n            for pattern in patterns:\n                for file in install_lib.glob(pattern):\n                    files_set.add(normcase(abspath(file)))\n            return files_set\n\n        include_files_set = norm_files_set(INCLUDE_FILE_PATTERNS)\n        exclude_files_set = norm_files_set(EXCLUDE_FILE_PATTERNS)\n\n        for file in include_files_set.difference(exclude_files_set):\n            protected_file = Path(file)\n            _logger.info(f\"Removing protected file: {protected_file}\")\n\n            # remove the protected files from the Wheel\n            protected_file.unlink()\n            # remove C files generated by Cython\n            protected_file.with_suffix(\".c\").unlink(missing_ok=True)\n            # why `.cpp`: &lt;https://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html#specify-c-language-in-setup-py&gt;\n            protected_file.with_suffix(\".cpp\").unlink(missing_ok=True)\n            # remove *potential* python bytecode files (e.g., `pip install --compile-bytecode`)\n            # ref:\n            #   - &lt;https://docs.python.org/3/using/cmdline.html#cmdoption-O&gt;\n            #   - &lt;https://peps.python.org/pep-0488/&gt;\n            #   - &lt;https://docs.python.org/3/library/importlib.html#importlib.util.cache_from_source&gt;\n            for optimization in (\"\", 1, 2):\n                bytecode_file = cache_from_source(\n                    protected_file, optimization=optimization\n                )\n                Path(bytecode_file).unlink(missing_ok=True)\n\n\nsetup(\n    ####################\n    # pyo3 extension module\n    ####################\n    rust_extensions=[\n        RustExtension(\n            # set `target` the same as `[project.entry-points.pytauri.ext_mod]` in `pyproject.toml`\n            target=\"tauri_app.ext_mod\",\n            # It is recommended to set other features in `Cargo.toml`, except following features:\n            features=[\n                # see: &lt;https://pyo3.rs/v0.23.3/building-and-distribution.html#the-extension-module-feature&gt;,\n                # required to build the extension module\n                \"pyo3/extension-module\",\n                # This feature tells Tauri to use embedded frontend assets instead of using a frontend development server.\n                # Usually this feature is enabled by `tauri-cli`, here we enable it manually.\n                \"tauri/custom-protocol\",\n            ],\n        )\n    ]\n    if not PYTAURI_STANDALONE\n    else [],\n    ####################\n    # Cython\n    ####################\n    cmdclass={\"install\": install} if USE_CYTHON else {},\n    # See: &lt;https://cython.readthedocs.io/en/latest/src/quickstart/build.html#building-a-cython-module-using-setuptools&gt;\n    ext_modules=cythonize(  # pyright: ignore[reportUnknownArgumentType]\n        module_list=[SRC_PREFIX + pattern for pattern in INCLUDE_FILE_PATTERNS],\n        exclude=[SRC_PREFIX + pattern for pattern in EXCLUDE_FILE_PATTERNS],\n    )\n    if USE_CYTHON\n    else [],\n)\n</code></pre> <p>Add <code>*.c</code> (generated by <code>Cython</code>) to <code>.gitignore</code> to avoid committing them if you don't want to.</p> <p>When building a standalone binary (<code>uv pip install</code>), you only need to add the environment variable <code>USE_CYTHON=1</code> to compile your Python code with <code>Cython</code>.</p> <p>Check the following directories, and you will find that the <code>*.py</code> source files matching <code>INCLUDE_FILE_PATTERNS</code> have been compiled into <code>*.so</code>/<code>*.pyd</code> files. Additionally, the <code>*.c</code> files generated by <code>Cython</code> (which could also leak your source code) are not included:</p> <ul> <li>Windows: <code>src-tauri\\pyembed\\python\\Lib\\site-packages\\{your_package}</code></li> <li>Unix: <code>src-tauri/pyembed/python/lib/python{version}/site-packages/{your_package}</code></li> </ul> <p>Tip</p> <p>During development, you can still use <code>uv pip install -e</code> to install your project in development mode. This means you can modify <code>*.py</code> files and see the changes immediately (without compiling with <code>Cython</code>). That's awesome \ud83c\udf89!</p>"},{"location":"usage/tutorial/build-standalone-cython/#faq","title":"FAQ","text":""},{"location":"usage/tutorial/build-standalone-cython/#the-size-of-the-binary-modules","title":"The Size of the Binary Modules","text":"<p>It is not recommended to set <code>INCLUDE_FILE_PATTERNS</code> to a wildcard like <code>**/*.py</code>. Compiling a binary module can increase your application size from a few kilobytes for <code>*.py</code> files to several hundred kilobytes. Of course, if you don't mind the size increase, this is not an issue.</p> <p>If you do want to do this and still care about size, check out the <code>Cython</code> tutorial (NOTE: it is complex and requires manual steps): https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html#shared-utility-module</p> <p>If possible, consider consolidating the code you want to compile into a single file. This not only reduces size but also allows <code>Cython</code> to better optimize and accelerate them through inlining: https://cython.readthedocs.io/en/latest/src/userguide/faq.html#what-is-better-a-single-big-module-or-multiple-separate-modules.</p>"},{"location":"usage/tutorial/build-standalone-cython/#why-hack-the-setuptoolscommandinstallinstall","title":"Why Hack the <code>setuptools.command.install.install</code>","text":"<p>Setuptools does not provide an API to exclude certain files from the Wheel: https://github.com/pypa/setuptools/issues/511.</p>"},{"location":"usage/tutorial/build-standalone/","title":"Build standalone binary","text":"<p>pytauri can be distributed as a Python wheel or compiled into a standalone executable (a regular Tauri application).</p> <p>Unlike packaging with <code>pyinstaller</code> after building as a wheel, compiling pytauri into an executable allows you to enjoy all the benefits brought by <code>tauri-cli</code>.</p>"},{"location":"usage/tutorial/build-standalone/#get-portable-python","title":"Get portable Python","text":"<p>We will bundle python-build-standalone as a portable Python for distribution.</p> <p>Please download the Python version you need. Usually, you will use these versions:</p> <ul> <li><code>cpython-*-x86_64-pc-windows-msvc-install_only_stripped.tar.gz</code></li> <li><code>cpython-*-x86_64-unknown-linux-gnu-install_only_stripped.tar.gz</code></li> <li><code>cpython-*-aarch64-apple-darwin-install_only_stripped.tar.gz</code></li> </ul> <p>Extract it to <code>src-tauri/pyembed</code>, make sure the file layout is as follows:</p> windowsunix <pre><code>\u251c\u2500\u2500 src-tauri/pyembed/python\n    \u251c\u2500\u2500 python.exe\n    \u251c\u2500\u2500 python3.dll\n    \u2514\u2500\u2500 ...\n</code></pre> <pre><code>\u251c\u2500\u2500 src-tauri/pyembed/python\n    \u251c\u2500\u2500 bin/\n    \u251c\u2500\u2500 include/\n    \u251c\u2500\u2500 lib/\n    \u2514\u2500\u2500 share/\n</code></pre> <p>Tell <code>tauri-cli</code> to ignore it during <code>tauri dev</code>:</p> src-tauri/.taurignore<pre><code># ...\n/pyembed/\n</code></pre> <p>Tip</p> <p>If you are using an IDE based on <code>pyright</code>/<code>pylance</code>, please create a <code>pyproject.toml</code> file in the root directory of your project (not <code>src-tauri/pyproject.toml</code>) and add the following configuration to tell <code>pyright</code> not to analyze <code>src-tauri/pyembed</code>, as it will consume a large amount of memory:</p> pyproject.toml<pre><code>[tool.pyright]\n# see: &lt;https://github.com/microsoft/pyright/blob/1.1.391/docs/configuration.md#environment-options&gt;\nexclude = [\n    \"**/node_modules\",\n    \"**/__pycache__\",\n    # \ud83d\udc47 necessary, because when `tauri-cli bundles python,\n    # it will copy `pyembed` to the target directory (i.e., rust output dir).\n    \"**/target\",\n    # \ud83d\udc46\n    \"**/dist\",\n    \"**/.venv\",\n    \"**/.*\",\n    \"src-tauri/pyembed/\",\n    \"src-tauri/frontend/\",\n]\n</code></pre>"},{"location":"usage/tutorial/build-standalone/#install-your-project-into-the-embedded-python-environment","title":"Install your project into the embedded Python environment","text":"windowsunix <pre><code>$env:PYTAURI_STANDALONE=\"1\"  # see `setup.py`\n\n# `tauri-app` is your python package name.\nuv pip install `\n    --exact `\n    --python=\".\\src-tauri\\pyembed\\python\\python.exe\" `\n    --reinstall-package=tauri-app `\n    .\\src-tauri\n</code></pre> <pre><code>export PYTAURI_STANDALONE=\"1\"  # see `setup.py`\n\n# `tauri-app` is your python package name.\nuv pip install \\\n    --exact \\\n    --python=\"./src-tauri/pyembed/python/bin/python3\" \\\n    --reinstall-package=tauri-app \\\n    ./src-tauri\n</code></pre> <p>Warning</p> <p>Unlike <code>editable install</code> during development, you need to reinstall your project every time you modify the Python code.</p>"},{"location":"usage/tutorial/build-standalone/#configure-tauri-cli","title":"Configure <code>tauri-cli</code>","text":"<p>ref: https://tauri.app/reference/config/#bundle</p> <p>Create following <code>tauri-cli</code> configuration file:</p> src-tauri/tauri.bundle.json<pre><code>{\n    \"bundle\": {\n        \"active\": true,\n        \"targets\": \"all\",\n        \"resources\": {\n            \"pyembed/python\": \"./\"\n        }\n    }\n}\n</code></pre> <p>ref: https://doc.rust-lang.org/cargo/reference/profiles.html</p> <p>Add the following configuration to <code>Cargo.toml</code>:</p> src-tauri/Cargo.toml<pre><code># ...\n\n[profile.bundle-dev]\ninherits = \"dev\"\n\n[profile.bundle-release]\ninherits = \"release\"\n</code></pre>"},{"location":"usage/tutorial/build-standalone/#build-and-bundle","title":"Build and bundle","text":"<p>ref: https://pyo3.rs/v0.23.3/building-and-distribution.html#configuring-the-python-version</p> <p>Indicate pyo3 to use the embedded Python interpreter through environment variables, so it does not mistakenly use the system Python interpreter.</p> windowsunix <pre><code>$env:PYO3_PYTHON = (Resolve-Path -LiteralPath \".\\src-tauri\\pyembed\\python\\python.exe\").Path\n</code></pre> <pre><code>export PYO3_PYTHON=$(realpath ./src-tauri/pyembed/python/bin/python3)\n</code></pre> <p>Configure <code>RUSTFLAGS</code>:</p> windowsunix <p>Nothing you need to do. Only unix need to set <code>RUSTFLAGS</code>.</p> <ul> <li>There is currently an issue with the <code>sysconfig</code> of <code>python-build-standalone</code>,     which causes <code>pyo3</code> to fail to automatically find <code>libpython3</code> during compilation, so we need to set it manually.</li> <li>We use tauri's <code>resource_dir</code> to bundle the portable Python,     so we need to set <code>rpath</code> to tell our binary how to find the bundled <code>libpython3</code> at runtime.</li> </ul> linuxmacos <pre><code># `tauri-app` is your app `productName` in `tauri.conf.json`.\nexport RUSTFLAGS=\" \\\n    -C link-arg=-Wl,-rpath,\\$ORIGIN/../lib/tauri-app/lib \\\n    -L $(realpath ./src-tauri/pyembed/python/lib)\"\n</code></pre> <pre><code>export RUSTFLAGS=\" \\\n    -C link-arg=-Wl,-rpath,@executable_path/../Resources/lib \\\n    -L $(realpath ./src-tauri/pyembed/python/lib)\"\n</code></pre> <p>Finally, use <code>tauri-cli</code> to bundle:</p> <pre><code>pnpm -- tauri build --config=\"src-tauri/tauri.bundle.json\" -- --profile bundle-release\n</code></pre> <p>Warning</p> <p>DO NOT set <code>bundle.resources</code> in <code>tauri.conf.json</code> directly.</p> <p>The <code>tauri-cli</code> will copy <code>bundle.resources</code> to <code>target/release(debug)</code>, which is in the same location as your executable. This will incorrectly cause the copied Python environment to be the Python environment linked at runtime during <code>tauri dev</code>. However, during development, you should use a <code>venv</code> virtual environment.</p> <p>By using <code>--profile bundle-release</code>, we ensure that <code>target/release(debug)</code> is not affected, allowing you to use <code>tauri dev</code> normally.</p>"},{"location":"usage/tutorial/build-wheel/","title":"Build python Wheel distribution","text":"<p>Although you have built the sdist in the previous step and can build the wheel using <code>setuptools-rust</code>, take a look at the output wheel file name <code>tauri-app-0.1.0-cp39-cp39-linux_x86_64.whl</code>.</p> <p>According to https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/, this indicates that the wheel can only be used on <code>CPython == 3.9</code>.</p> <p>This means that if you want to distribute the wheel built in this way, you need to build a wheel for each CPython version.</p> <p>Additionally, PyPI will not allow you to upload wheels with the <code>linux*</code> tag because such a tag does not specify the libc version required to run the wheel. PyPI only allows manylinux and musllinux.</p> <p>Info</p> <p>This is not an issue for users who use your sdist, as they will build the wheel in their own environment and do not need to distribute that wheel.</p>"},{"location":"usage/tutorial/build-wheel/#maturin","title":"Maturin","text":"<p>To make it easier to build distributable wheels, we recommend using maturin, which is a <code>setuptools-rust</code> with batteries included.</p> <p>First, install it (<code>v1.8.0</code>) using uv:</p> windows or macoslinux <pre><code>uv pip install maturin\n</code></pre> <pre><code>uv pip install maturin[patchelf]\n</code></pre> <p>Add the following configuration, which is the same as the configuration for <code>setuptools-rust</code>:</p> src-tauri/pyproject.toml<pre><code># see: &lt;https://www.maturin.rs/config&gt;\n[tool.maturin]\n# the same as [tool.setuptools.packages.find.where]\npython-source = \"python\"\n# the same as `[project.entry-points.pytauri.ext_mod]`,\n# i.e., `target` in `setup.py`\nmodule-name = \"tauri_app.ext_mod\"\n# see `setup.py`\nfeatures = [\"pyo3/extension-module\", \"tauri/custom-protocol\"]\n# equivalent to `setuptools_scm`\nsdist-generator = \"git\"\n# equivalent to `MANIFEST.in`\ninclude = [{ path = \"frontend/**/*\", format = \"sdist\" }]\n</code></pre>"},{"location":"usage/tutorial/build-wheel/#build-manylinux-wheel","title":"Build manylinux wheel","text":"<p>ref: https://www.maturin.rs/distribution#build-wheels</p> <p>Maturin can automatically detect the current system's glibc version and assign the appropriate tag to the built wheel. Use the following command to build a manylinux wheel:</p> <pre><code>cd src-tauri\npnpm build  # build frontend assets\nmaturin build --release  # `--strip` &lt;-- optional to reduce the size\ncd ..\n</code></pre> <p>When you build on <code>ubuntu 22.04 (glibc 2.35)</code>, you will get a wheel file named <code>*-manylinux_2_35_*.whl</code>. The <code>manylinux_2_35</code> tag indicates that the wheel can run on systems with <code>glibc &gt;= 2.35</code>.</p> <p>If you want to support as many systems as possible, you should build the wheel on an older system. However, please note that the dependencies of <code>tauri v2</code> require you to use <code>ubuntu 22+</code>.</p>"},{"location":"usage/tutorial/build-wheel/#bundle-system-dependencies-with-the-wheel","title":"Bundle system dependencies with the wheel","text":"<p>According to PEP513, the manylinux wheel you built in the previous step can only link to a limited set of system libraries at runtime. To meet this requirement, maturin will copy and bundle these system libraries (including tauri's dependencies) during the build process, similar to how AppImage works.</p> <p>Tip</p> <p>Not all linked libraries will be bundled. Some libraries commonly found in various Linux distributions will be whitelisted. See more:</p> <ul> <li>https://github.com/pypa/auditwheel/issues/78</li> <li>https://github.com/kuelumbus/rdkit-pypi/issues/75</li> <li>https://github.com/PyO3/maturin/blob/f5b807eaf3f576ea08e6a574d699fc6f54e2be46/src/auditwheel/manylinux-policy.json#L454</li> </ul> <p>Building the wheel in this way means your users will no longer need to manually install dependencies. However, note that this will increase your wheel size from 10MB to 100MB.</p> <p>If you do not want this behavior, skip patching and manually specify the manylinux tag:</p> <pre><code>maturin build --release --auditwheel skip --manylinux 2_35 # &lt;-- your glibc version\n</code></pre> <p>Then, require your users to install these dependencies before running the wheel:</p> <p>ref: https://tauri.app/distribute/debian/#debian</p> <ul> <li>libwebkit2gtk-4.1-0</li> <li>libgtk-3-0</li> <li>libappindicator3-1 (if your app uses the system tray)</li> </ul>"},{"location":"usage/tutorial/build-wheel/#build-abi3-wheel","title":"Build abi3 wheel","text":"<p>ref: https://www.maturin.rs/bindings.html#py_limited_apiabi3</p> <p>add pyo3 feature <code>pyo3/abi3-py3*</code>:</p> src-tauri/pyproject.toml<pre><code>[tool.maturin]\n# ...\nfeatures = [\"pyo3/extension-module\", \"tauri/custom-protocol\", \"pyo3/abi3-py39\"]\n</code></pre> <p>then build your wheel:</p> <pre><code>maturin build --release  # your maturin args\n</code></pre> <p>you will get a wheel file named <code>*-cp39-abi3-*.whl</code>, which means that the wheel can run on <code>CPython &gt;= 3.9</code>.</p> <p>Info</p> <p>The <code>pytauri/standalone</code> feature is incompatible with the <code>pyo3/abi3</code> feature, which is why we only enable it in <code>[[bin]]</code> target.</p>"},{"location":"usage/tutorial/build-wheel/#whats-projectentry-pointspytauri-mean","title":"What's <code>project.entry-points.pytauri</code> mean?","text":"<p>Now it's time to explain <code>[project.entry-points.pytauri]</code>.</p> <p>Looking at the contents of the <code>.whl</code>, you will see the following structure:</p> <pre><code>\u2514\u2500\u2500 tauri_app-0.1.0-*.whl\n    \u251c\u2500\u2500 tauri_app\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 __main__.py\n    \u2502   \u2514\u2500\u2500 ext_mod.*.so/pyd\n    \u2514\u2500\u2500 ...\n</code></pre> <p>We indicate the extension module <code>mod ext_mod</code> in <code>lib.rs</code> to be compiled into the <code>tauri_app/ext_mod.*.so/pyd</code> file by:</p> <ul> <li><code>setup.py (setuptools-rust)</code>: <code>target=\"tauri_app.ext_mod\"</code></li> <li><code>pyproject.toml (maturin)</code>: <code>module-name = \"tauri_app.ext_mod\"</code></li> </ul> <p>Warning</p> <p><code>pytauri</code> does not have any opinion on where you place the extension module, but note that in <code>lib.rs</code> we specified the extension module name with <code>#[pyo3(name = \"ext_mod\")]</code>, so your extension module file name must match this name.</p> <p>Finally, we tell pytauri how to find it through <code>project.entry-points.pytauri.ext_mod = \"tauri_app.ext_mod\"</code> in <code>pyproject.toml</code>.</p>"},{"location":"usage/tutorial/gen-ts/","title":"Generate TypeScript Client for IPC","text":"<p>Info</p> <p>This is an experimental feature. You may also encounter some bugs\u2014please report them on GitHub issues!</p> <p>Since <code>v0.7</code>, pytauri natively supports generating a TypeScript client for Commands. This makes calling pytauri commands in TypeScript very simple and type-safe.</p>"},{"location":"usage/tutorial/gen-ts/#install-dependencies","title":"Install Dependencies","text":"<p>pytauri uses pydantic to generate jsonschema, then calls json-schema-to-typescript to convert it into TypeScript type definitions.</p> <p>Install the dependencies with the following commands:</p> <pre><code>pnpm add json-schema-to-typescript --save-dev\n\npnpm json2ts --help  # check if installed correctly\n</code></pre>"},{"location":"usage/tutorial/gen-ts/#usage-example","title":"Usage Example","text":"<p>Commands.experimental_gen_ts_background</p> src-tauri/python/__init__.py<pre><code>from os import getenv\nfrom pathlib import Path\n\nfrom anyio.from_thread import start_blocking_portal\nfrom pydantic import BaseModel, ConfigDict\nfrom pydantic.alias_generators import to_camel\nfrom pytauri import (\n    Commands,\n    builder_factory,\n    context_factory,\n)\n\n# \u2b50 You should only enable this feature in development (not production)\nPYTAURI_GEN_TS = getenv(\"PYTAURI_GEN_TS\") != \"0\"\n\n# \u2b50 Enable this feature first\ncommands = Commands(experimental_gen_ts=PYTAURI_GEN_TS)\n\n\nclass _BaseModel(BaseModel):\n    model_config = ConfigDict(\n        # Accepts camelCase js ipc arguments for snake_case python fields.\n        #\n        # See: &lt;https://docs.pydantic.dev/2.10/concepts/alias/#using-an-aliasgenerator&gt;\n        alias_generator=to_camel,\n        # By default, pydantic allows unknown fields,\n        # which results in TypeScript types having `[key: string]: unknown`.\n        #\n        # See: &lt;https://docs.pydantic.dev/2.10/concepts/models/#extra-data&gt;\n        extra=\"forbid\",\n    )\n\n\nclass Person(_BaseModel):\n    \"\"\"A simple model representing a person.\n\n    @property name - The name of the person.\n    \"\"\"\n\n    # \ud83d\udc46 This pydoc will be converted to tsdoc\n    name: str\n\n\n# \u2b50 Just use `commands` as usual\n@commands.command()\nasync def greet_to_person(body: Person) -&gt; str:\n    \"\"\"A simple command that returns a greeting message.\n\n    @param body - The person to greet.\n    \"\"\"\n    # \ud83d\udc46 This pydoc will be converted to tsdoc\n    return f\"Hello, {body.name}!\"\n\n\ndef main() -&gt; int:\n    with start_blocking_portal(\"asyncio\") as portal:\n        if PYTAURI_GEN_TS:\n            # \u2b50 Generate TypeScript Client to your frontend `src/client` directory\n            output_dir = Path(__file__).parent.parent.parent.parent / \"src\" / \"client\"\n            # \u2b50 The CLI to run `json-schema-to-typescript`,\n            # `--format=false` is optional to improve performance\n            json2ts_cmd = \"pnpm json2ts --format=false\"\n\n            # \u2b50 Start the background task to generate TypeScript types\n            portal.start_task_soon(\n                lambda: commands.experimental_gen_ts_background(\n                    output_dir, json2ts_cmd, cmd_alias=to_camel\n                )\n            )\n\n        app = builder_factory().build(\n            context=context_factory(),\n            invoke_handler=commands.generate_handler(portal),\n        )\n        exit_code = app.run_return()\n        return exit_code\n</code></pre> <p>When you run your app (<code>pnpm tauri dev</code>), the TypeScript client code will be generated in the <code>src/client</code> directory:</p> <p>Tip</p> <p>Every time you modify a command, the TypeScript client code will automatically update after hot reload. Awesome \ud83c\udf89!</p> src/client/apiClient.ts<pre><code>/* eslint-disable */\n/**\n * This file was automatically generated by pytauri-gen-ts.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source commands API,\n * and run pytauri-gen-ts to regenerate this file.\n */\n\nimport { pyInvoke } from \"tauri-plugin-pytauri-api\";\nimport { InvokeOptions } from \"@tauri-apps/api/core\";\n\nimport type { Commands } from \"./_apiTypes.d.ts\";\n\n/**\n * A simple command that returns a greeting message.\n *\n * @param body - The person to greet.\n */\nexport async function greetToPerson(\n    body: Commands[\"greet_to_person\"][\"input\"],\n    options?: InvokeOptions\n): Promise&lt;Commands[\"greet_to_person\"][\"output\"]&gt; {\n    return await pyInvoke(\"greet_to_person\", body, options);\n}\n</code></pre>"},{"location":"usage/tutorial/gen-ts/#faq","title":"FAQ","text":""},{"location":"usage/tutorial/gen-ts/#js-channel-and-py-javascriptchannelid-type-mismatch","title":"JS <code>Channel</code> and PY <code>JavaScriptChannelId</code> Type Mismatch","text":"<p><code>Argument of type 'Channel&lt;unknown&gt;' is not assignable to parameter of type 'string'.ts(2345)</code></p> <p>JavaScriptChannelId is serialized and deserialized as a <code>string</code> between the frontend and backend, so the generated ts type is <code>string</code>.</p> <p>You just need to pass <code>Channel.toJSON()</code> (i.e., <code>JSON.stringify(Channel)</code>):</p> <pre><code>import { Channel } from \"@tauri-apps/api/core\";\n\nconst channel = new Channel();\nawait fooCmd(channel.toJSON()); // pass the channel as a string\n</code></pre> <p>This is a known limitation, but we don't know how to solve it yet. If you have a good suggestion, please open a GitHub issue \ud83d\ude07.</p>"},{"location":"usage/tutorial/gen-ts/#how-to-generate-ts-types-for-event-and-channel","title":"How to Generate TS Types for <code>Event</code> and <code>Channel</code>?","text":"<p>Not supported yet. We haven't figured out an ergonomic API. If you have a good suggestion, please open a GitHub issue \ud83d\ude07.</p>"},{"location":"usage/tutorial/getting-started/","title":"Getting Started","text":""},{"location":"usage/tutorial/getting-started/#create-pytauri-app","title":"Create PyTauri App","text":"<p>Tip</p> <p>Since version <code>0.6</code>, create-pytauri-app is the recommended way to start a new PyTauri project, even if it is still in development. Refer to uv and copier, run the following command:</p> <pre><code>uvx copier copy https://github.com/pytauri/create-pytauri-app .\n</code></pre> <p>This will initialize the project in the form of an interactive questionnaire.</p> <p>However, we still recommend reading the entire \"Tutorial\" section, as it will help you understand all the details of pytauri.</p> <p>Before starting the tutorial, we recommend installing the following tools, which are considered best practices for initializing a pytauri project. We will use these tools throughout the tutorial.</p> <ul> <li>create-tauri-app: <code>v4.5.9</code></li> <li>uv: <code>v0.5.11</code></li> <li>tauri-cli: <code>v2.1.0</code></li> </ul> <p>Note</p> <p>The specified versions above are the ones used when writing this tutorial. You can use other versions, but the usage might differ from the examples in this tutorial.</p>"},{"location":"usage/tutorial/getting-started/#full-example","title":"Full Example","text":"<p>https://github.com/pytauri/pytauri/tree/main/examples/tauri-app</p>"},{"location":"usage/tutorial/getting-started/#create-a-new-tauri-project","title":"Create a new tauri project","text":"<p>ref: https://tauri.app/start/create-project/#using-create-tauri-app</p> <p>Note</p> <p>In this tutorial, we will use pnpm to manage the frontend.</p> <p>However, pytauri does not have any opinion on which frontend framework you use. You can even serve the frontend resources via a server using a URL.</p> <pre><code>pnpm create tauri-app\n\n? Project name (tauri-app) \u203a\n? Identifier (com.tauri-app.app) \u203a\n? Choose which language to use for your frontend \u203a\n    \u276f TypeScript / JavaScript  (pnpm, yarn, npm, deno, bun)\n? Choose your package manager \u203a\n    \u276f pnpm\n? Choose your UI template \u203a\n    \u276f Vanilla\n? Choose your UI flavor \u203a\n    \u276f TypeScript\n</code></pre> <p>You will get the following directory structure:</p> <pre><code>\u2514\u2500\u2500 tauri-app\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 index.html\n    \u251c\u2500\u2500 package.json\n    \u251c\u2500\u2500 src\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 assets\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 main.ts\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 styles.css\n    \u251c\u2500\u2500 src-tauri\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.toml\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 build.rs\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 capabilities\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 icons\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 tauri.conf.json\n    \u251c\u2500\u2500 tsconfig.json\n    \u2514\u2500\u2500 vite.config.ts\n</code></pre> <ul> <li><code>/tauri-app</code>: for the frontend</li> <li><code>/tauri-app/src-tauri</code>: for rust and python backend</li> </ul>"},{"location":"usage/tutorial/getting-started/#launch-the-tauri-app","title":"Launch the tauri app","text":"<pre><code>cd tauri-app\npnpm install  # (1)!\npnpm tauri dev  # (2)!\n</code></pre> <ol> <li>This command will install <code>tuari-cli</code></li> <li>use <code>tauri-cli</code> to start the app</li> </ol> <p>Info</p> <p>The first run will take some time to compile the dependencies, subsequent launches will be much faster.</p> <p>Congratulations! When you finally see a window with web content appear, you have successfully created a Tauri application.</p>"},{"location":"usage/tutorial/getting-started/#next-steps","title":"Next Steps","text":"<p>Next, we will demonstrate how to integrate Python into the Tauri application using pytauri.</p>"},{"location":"usage/tutorial/py-js-ipc/","title":"IPC between Python and JavaScript","text":"<p>See concepts/ipc for more information.</p> <p>pytauri implements the same IPC API as tauri. You can use it through pytauri.Commands.</p> <p>This tutorial will demonstrate how to use pytauri's IPC API by rewriting the <code>fn greet</code> command in <code>src-tauri/src/lib.rs</code> in Python.</p>"},{"location":"usage/tutorial/py-js-ipc/#enable-pytauri-ipc-permission","title":"Enable pytauri ipc permission","text":"<p>pytauri internally implements IPC through <code>tauri-plugin-pytauri</code>. You need to add it to the dependencies so that you can enable its permission in tauri.</p> src-tauri/Cargo.toml<pre><code># ...\n\n[dependencies]\n# ...\ntauri-plugin-pytauri = { version = \"0.6\" }  # (1)!\n</code></pre> <ol> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> </ol> <p>Refer to https://tauri.app/security/capabilities/ to add the permission:</p> src-tauri/capabilities/default.json<pre><code>{\n    // ...\n    \"permissions\": [\n        // ...\n        \"pytauri:default\"\n    ]\n}\n</code></pre>"},{"location":"usage/tutorial/py-js-ipc/#ipc-in-python","title":"IPC in python","text":""},{"location":"usage/tutorial/py-js-ipc/#install-dependencies","title":"install dependencies","text":"<p>pytauri relies on pydantic for serialization and validation, and on anyio for <code>asyncio</code>/<code>trio</code> support.</p> <p>Therefore, you need to install these dependencies:</p> src-tauri/pyproject.toml<pre><code># ...\n\n[project]\n# ...\ndependencies = [\n    # ...\n    \"pydantic == 2.*\",\n    \"anyio == 4.*\"\n]\n</code></pre> <p>Tip</p> <p>After adding dependencies, you need to use commands like <code>uv sync</code> or <code>uv pip install</code> to synchronize your dependency environment.</p>"},{"location":"usage/tutorial/py-js-ipc/#add-command","title":"add command","text":"<p>see concepts/ipc for more information.</p> src-tauri/python/__init__.py<pre><code>import sys\n\nfrom anyio.from_thread import start_blocking_portal\nfrom pydantic import BaseModel\nfrom pytauri import (\n    Commands,\n    builder_factory,\n    context_factory,\n)\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person) -&gt; Greeting:\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n</code></pre>"},{"location":"usage/tutorial/py-js-ipc/#generate-invoke-handler-for-app","title":"generate invoke handler for app","text":"src-tauri/python/__init__.py<pre><code># --8&lt;-- [start:command]\n\nimport sys\n\nfrom anyio.from_thread import start_blocking_portal\nfrom pydantic import BaseModel\nfrom pytauri import (\n    Commands,\n    builder_factory,\n    context_factory,\n)\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person) -&gt; Greeting:\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n\n\n# --8&lt;-- [end:command]\n\n\ndef main() -&gt; int:\n    with start_blocking_portal(\"asyncio\") as portal:  # or `trio`\n        app = builder_factory().build(\n            context=context_factory(),\n            # \ud83d\udc47\n            invoke_handler=commands.generate_handler(portal),\n            # \ud83d\udc46\n        )\n        exit_code = app.run_return()\n        return exit_code\n</code></pre>"},{"location":"usage/tutorial/py-js-ipc/#ipc-in-javascript","title":"IPC in JavaScript","text":"<p>pytauri provides an API similar to the <code>invoke</code> function in <code>@tauri-apps/api/core</code> through <code>tauri-plugin-pytauri-api</code>.</p> <p>First, install it: <code>pnpm add tauri-plugin-pytauri-api</code>.</p> <p>Now, you can invoke the command from your JavaScript code:</p> src/main.ts<pre><code>import { invoke } from \"@tauri-apps/api/core\";\nimport { pyInvoke } from \"tauri-plugin-pytauri-api\";\n// or if tauri config `app.withGlobalTauri = true`:\n//\n// ```js\n// const { invoke } = window.__TAURI__.core;\n// const { pyInvoke } = window.__TAURI__.pytauri;\n// ```\n\ninterface Greeting {\n  message: string;\n}\n\nasync function greet() {\n  if (greetMsgEl &amp;&amp; greetInputEl) {\n    // Learn more about Tauri commands at https://tauri.app/develop/calling-rust/\n    const rsGreeting = await invoke&lt;string&gt;(\"greet\", {\n      name: greetInputEl.value,\n    });\n    const pyGreeting = await pyInvoke&lt;Greeting&gt;(\"greet\", {\n      name: greetInputEl.value,\n    });\n    greetMsgEl.textContent = rsGreeting + \"\\n\" + pyGreeting.message;\n  }\n}\n</code></pre>"},{"location":"usage/tutorial/using-plugins/","title":"Using tauri plugins","text":"<p>The Tauri team and community have developed some plugins, you can use them by:</p> <ol> <li>Official Tauri plugins usually provide corresponding JavaScript APIs, which you can use directly on the frontend.</li> <li> <p>Write your own Rust functions using pyo3 and expose them to Python: https://github.com/pytauri/pytauri/discussions/45#discussioncomment-11870767</p> <p>We encourage you to distribute plugins written in this way to benefit the entire community \ud83d\udcaa.</p> </li> </ol> <p>In addition, PyTauri has already integrated some official Tauri plugins. Below, we use tauri-plugin-notification as an example to demonstrate how to use a PyTauri-integrated plugins.</p>"},{"location":"usage/tutorial/using-plugins/#all-plugins-we-support","title":"All plugins we support","text":"Plugin JS Docs Rust Docs Python Docs plugin-notification JS docs Rust docs Python docs plugin-dialog JS docs Rust docs Python docs"},{"location":"usage/tutorial/using-plugins/#using-the-plugin","title":"Using the plugin","text":""},{"location":"usage/tutorial/using-plugins/#install-tauri-plugin","title":"install tauri plugin","text":"<p>All PyTauri plugins are just Python bindings, which means you need to initialize the underlying Tauri extensions normally:</p> <pre><code>pnpm tauri add notification\n</code></pre>"},{"location":"usage/tutorial/using-plugins/#expose-the-pyo3-bingings-to-python","title":"expose the pyo3 bingings to python","text":"<p>Enable the <code>pytauri</code> feature:</p> src-tauri/Cargo.toml<pre><code>[dependencies]\n# ...\n-pytauri = { version = \"*\" }\n+pytauri = { version = \"*\", features = [\"plugin-notification\"] }\n</code></pre>"},{"location":"usage/tutorial/using-plugins/#use-plugin-api-from-python","title":"use plugin api from python","text":"<p>The PyTauri API maps very well to the original Rust API of the plugin. You can refer to the Js docs, Rust docs and Python docs to understand how to use it:</p> <p>Tip</p> <p><code>pytauri_plugins</code> is distributed as part of the <code>pytauri</code> package on PyPI. Therefore, running <code>pip install pytauri</code> will also install it.</p> src-tauri/python/__init__.py<pre><code>import sys\n\nfrom pydantic import BaseModel\nfrom pytauri import AppHandle, Commands\nfrom pytauri_plugins.notification import NotificationExt\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person, app_handle: AppHandle) -&gt; Greeting:\n    notification_builder = NotificationExt.builder(app_handle)\n    notification_builder.show(title=\"Greeting\", body=f\"Hello, {body.name}!\")\n\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/","title":"Using pytauri","text":"<p>Note</p> <p>The dependency versions specified in the following tutorial are the versions at the time of writing. There may be newer versions available when you use it.</p>"},{"location":"usage/tutorial/using-pytauri/#create-venv","title":"Create venv","text":"<p>Create a virtual environment using <code>uv</code>:</p> <pre><code>uv venv --python-preference only-system\n</code></pre> <p>Warning</p> <p><code>--python-preference only-system</code> is necessary. Using <code>uv</code>'s managed Python may result in not finding dynamic libraries.</p> <p>activate the virtual environment:</p> bashpowershell <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\Activate.ps1\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/#init-pyproject","title":"Init pyproject","text":"<p>Create the <code>src-tauri/python/tauri_app</code> folder to store Python code, and add the following file:</p> <p>ref: https://packaging.python.org/en/latest/guides/writing-pyproject-toml/</p> src-tauri/pyproject.toml<pre><code>[project]\nname = \"tauri-app\"  # (1)!\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \"&gt;=3.9\"\ndependencies = [\"pytauri == 0.6.*\"]  # (2)!\n\n[project.entry-points.pytauri]\next_mod = \"tauri_app.ext_mod\"\n\n[build-system]\nrequires = [\"setuptools&gt;=61\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools.packages]\nfind = { where = [\"python\"] }  # (3)!\n</code></pre> <ol> <li>your python package name.</li> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> <li>the folder where your python code is stored, i.e., <code>src-tauri/python</code>.</li> </ol> <p>Tip</p> <p>Note the highlighted <code>project.entry-points</code>. We will explain its specific meaning when building the Wheel. For now, let's continue with the tutorial.</p>"},{"location":"usage/tutorial/using-pytauri/#install-your-project","title":"Install your project","text":"<p>Use <code>uv</code> to install your Python package in editable mode:</p> <pre><code>uv pip install -e src-tauri\n</code></pre> <p>Add following code:</p> src-tauri/python/tauri_app/__init__.py<pre><code>\"\"\"The tauri-app.\"\"\"\n\nfrom pytauri import (\n    builder_factory,\n    context_factory,\n)\n\n\ndef main() -&gt; int:\n    \"\"\"Run the tauri-app.\"\"\"\n    app = builder_factory().build(\n        context=context_factory(),\n        invoke_handler=None,  # TODO\n    )\n    exit_code = app.run_return()\n    return exit_code\n</code></pre> src-tauri/python/tauri_app/__main__.py<pre><code>\"\"\"The main entry point for the Tauri app.\"\"\"\n\nimport sys\nfrom multiprocessing import freeze_support\n\nfrom tauri_app import main\n\n# - If you don't use `multiprocessing`, you can remove this line.\n# - If you do use `multiprocessing` but without this line,\n#   you will get endless spawn loop of your application process.\n#   See: &lt;https://pyinstaller.org/en/v6.11.1/common-issues-and-pitfalls.html#multi-processing&gt;.\nfreeze_support()\n\nsys.exit(main())\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/#run-pytauri-from-rust","title":"Run pytauri from rust","text":"<p>Add following dependencies to <code>Cargo.toml</code>:</p> <p>ref: https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries</p> src-tauri/Cargo.toml<pre><code># ...\n\n[[bin]]\n# the same as the package name\nname = \"tauri-app\"\npath = \"src/main.rs\"\nrequired-features = [\"pytauri/standalone\"]\n\n[dependencies]\n# ...\npytauri = { version = \"0.6\" }  # (1)!\npyo3 = { version = \"0.25\" }  # (2)!\n</code></pre> <ol> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> </ol> <p>Also, enable the <code>pytauri/standalone</code> feature:</p> src-tauri/tauri.conf.json<pre><code>{\n    \"build\": {\n        \"features\": [\"pytauri/standalone\"]\n    }\n}\n</code></pre> <p>Warning</p> <p>If you do not enable <code>required-features</code> in <code>tauri-cli</code>, cargo will silently skip building your <code>main.rs</code> executable file.</p> <p>Change following rust code:</p> src-tauri/src/lib.rs<pre><code>use pyo3::prelude::*;\n\n// Learn more about Tauri commands at https://tauri.app/develop/calling-rust/\n#[tauri::command]\nfn greet(name: &amp;str) -&gt; String {\n    format!(\"Hello, {}! You've been greeted from Rust!\", name)\n}\n\npub fn tauri_generate_context() -&gt; tauri::Context {\n    tauri::generate_context!()\n}\n\n#[pymodule(gil_used = false)]\n#[pyo3(name = \"ext_mod\")]\npub mod ext_mod {\n    use super::*;\n\n    #[pymodule_init]\n    fn init(module: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {\n        pytauri::pymodule_export(\n            module,\n            // i.e., `context_factory` function of python binding\n            |_args, _kwargs| Ok(tauri_generate_context()),\n            // i.e., `builder_factory` function of python binding\n            |_args, _kwargs| {\n                let builder = tauri::Builder::default()\n                    .plugin(tauri_plugin_opener::init())\n                    .invoke_handler(tauri::generate_handler![greet]);\n                Ok(builder)\n            },\n        )\n    }\n}\n</code></pre> src-tauri/src/main.rs<pre><code>// Prevents additional console window on Windows in release, DO NOT REMOVE!!\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::{convert::Infallible, env::var, error::Error, path::PathBuf};\n\nuse pyo3::wrap_pymodule;\nuse pytauri::standalone::{\n    dunce::simplified, PythonInterpreterBuilder, PythonInterpreterEnv, PythonScript,\n};\nuse tauri::utils::platform::resource_dir;\n\nuse tauri_app_lib::{ext_mod, tauri_generate_context};\n\nfn main() -&gt; Result&lt;Infallible, Box&lt;dyn Error&gt;&gt; {\n    let py_env = if cfg!(dev) {\n        // `cfg(dev)` is set by `tauri-build` in `build.rs`, which means running with `tauri dev`,\n        // see: &lt;https://github.com/tauri-apps/tauri/pull/8937&gt;.\n\n        let venv_dir = var(\"VIRTUAL_ENV\").map_err(|err| {\n            format!(\n                \"The app is running in tauri dev mode, \\\n                please activate the python virtual environment first \\\n                or set the `VIRTUAL_ENV` environment variable: {err}\",\n            )\n        })?;\n        PythonInterpreterEnv::Venv(PathBuf::from(venv_dir).into())\n    } else {\n        // embedded Python, i.e., bundle mode with `tauri build`.\n\n        let context = tauri_generate_context();\n        let resource_dir = resource_dir(context.package_info(), &amp;tauri::Env::default())\n            .map_err(|err| format!(\"failed to get resource dir: {err}\"))?;\n        // \ud83d\udc49 Remove the UNC prefix `\\\\?\\`, Python ecosystems don't like it.\n        let resource_dir = simplified(&amp;resource_dir).to_owned();\n\n        // \ud83d\udc49 When bundled as a standalone App, we will put python in the resource directory\n        PythonInterpreterEnv::Standalone(resource_dir.into())\n    };\n\n    // \ud83d\udc49 Equivalent to `python -m tauri_app`,\n    // i.e, run the `src-tauri/python/tauri_app/__main__.py`\n    let py_script = PythonScript::Module(\"tauri_app\".into());\n\n    // \ud83d\udc49 `ext_mod` is your extension module, we export it from memory,\n    // so you don't need to compile it into a binary file (.pyd/.so).\n    let builder =\n        PythonInterpreterBuilder::new(py_env, py_script, |py| wrap_pymodule!(ext_mod)(py));\n    let interpreter = builder.build()?;\n\n    let exit_code = interpreter.run();\n    std::process::exit(exit_code);\n}\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/#launch-the-app-in-dev-mode","title":"Launch the app in dev mode","text":"<p>The <code>tauri-cli</code> has the ability to watch code changes and hot reload. Before starting, we need to add the following file to tell <code>tauri-cli</code> to ignore the python bytecode:</p> <p>ref: https://tauri.app/develop/#reacting-to-source-code-changes</p> src-tauri/.taurignore<pre><code>__pycache__\n</code></pre> <p>Also, we need tell <code>vite</code> to ignore <code>.venv</code>:</p> vite.config.ts<pre><code>// https://vitejs.dev/config/\nexport default defineConfig(async () =&gt; ({\n  server: {\n    watch: {\n      // 3. tell vite to ignore watching `src-tauri`\n      ignored: [\"**/src-tauri/**\", \"**/.venv/**\"],\n    },\n  },\n}));\n</code></pre> <p>Run <code>pnpm tauri dev</code>, and after recompiling, you will see a window similar to the previous step.</p> <p>Try modifying the Python code, and you will notice that the Python code is quickly reloaded without needing to recompile the Rust code.</p>"},{"location":"usage/tutorial/using-pytauri/#next-steps","title":"Next Steps","text":"<p>Next, we will demonstrate how to package your application.</p>"}]}
import sys
from collections.abc import Iterable
from itertools import chain
from json import dumps
from os import PathLike
from string import Template
from typing import Annotated, Literal, Union

from anyio import Path, create_task_group, run_process, to_thread
from pydantic import BaseModel, Field
from pydantic.json_schema import JsonSchemaMode, JsonSchemaValue, models_json_schema
from typing_extensions import NamedTuple, TypeIs

if sys.version_info < (3, 10):
    NoneType = type(None)
else:
    from types import NoneType


_COMMANDS_TITLE = "Commands"
"""Default title for commands JSON schema."""

_INPUT_PROPERTIES = "input"
_OUTPUT_PROPERTIES = "output"

# Ref: <https://github.com/bcherny/json-schema-to-typescript/pull/168>
_VOID_TS_TYPE = {
    "tsType": "void | undefined",
}
_BYTES_TS_TYPE = {
    "tsType": "ArrayBuffer",
}

_API_TYPES_FILE_NAME = "_apiTypes.d.ts"
"""Default file name for generated TypeScript types for API."""

_API_CLIENT_FILE_NAME = "apiClient.ts"
"""Default file name for generated TypeScript API client."""

_CLIENT_PREFIX = f"""\
/* eslint-disable */
/**
* This file was automatically generated by pytauri-gen-ts.
* DO NOT MODIFY IT BY HAND. Instead, modify the source commands API,
* and run pytauri-gen-ts to regenerate this file.
*/

import {{ pyInvoke }} from "tauri-plugin-pytauri-api";
import {{ InvokeOptions }} from "@tauri-apps/api/core";

import type {{ {_COMMANDS_TITLE} }} from "./{_API_TYPES_FILE_NAME}";

"""

_INVOKE_CMD_TEMPLATE = Template(f"""\
export async function ${{cmd}}(
    body: {_COMMANDS_TITLE}["${{cmd}}"]["{_INPUT_PROPERTIES}"],
    options?: InvokeOptions
): Promise<{_COMMANDS_TITLE}["${{cmd}}"]["{_OUTPUT_PROPERTIES}"]> {{
    return await pyInvoke("${{cmd}}", body, options);
}};

""")


_Model = type[BaseModel]
_Bytes = type[bytes]
_Void = type[None]


class InputOutput(NamedTuple):
    input_type: Union[_Model, _Bytes, _Void]
    output_type: Union[_Model, _Bytes, _Void]


CommandInputOutput = dict[str, InputOutput]


class _InputOutputSerde(NamedTuple):
    input_type: Union[
        tuple[_Model, Literal["validation"]],
        _Bytes,
        _Void,
    ]
    output_type: Union[
        tuple[_Model, Literal["serialization"]],
        _Bytes,
        _Void,
    ]


_CommandInputOutputSerde = dict[str, _InputOutputSerde]


def _object_json_schema(properties: dict[str, JsonSchemaValue]) -> JsonSchemaValue:
    return {
        "type": "object",
        "properties": properties,
        "required": list(properties.keys()),
        "additionalProperties": False,
    }


def _is_model(
    type_: Union[_Model, _Bytes, _Void],
) -> TypeIs[_Model]:
    return issubclass(type_, BaseModel)


def _is_model_serde(
    type_: Union[tuple[_Model, JsonSchemaMode], _Bytes, _Void],
) -> TypeIs[tuple[_Model, JsonSchemaMode]]:
    return isinstance(type_, tuple)


def _gen_json_schemas(cmd_in_out: CommandInputOutput) -> JsonSchemaValue:
    cmd_in_out_serde: _CommandInputOutputSerde = {
        cmd: _InputOutputSerde(
            (input_type, "validation") if _is_model(input_type) else input_type,
            (output_type, "serialization") if _is_model(output_type) else output_type,
        )
        for cmd, (input_type, output_type) in cmd_in_out.items()
    }

    json_schemas_map, definitions = models_json_schema(
        tuple(filter(_is_model_serde, chain.from_iterable(cmd_in_out_serde.values()))),
        title=_COMMANDS_TITLE,
        description="Commands Input and Output Schemas",
    )

    json_schemas = {
        **_object_json_schema(
            {
                cmd: _object_json_schema(
                    {
                        _INPUT_PROPERTIES: json_schemas_map[input_type]
                        if _is_model_serde(input_type)
                        else _VOID_TS_TYPE
                        if issubclass(input_type, NoneType)
                        else _BYTES_TS_TYPE,
                        _OUTPUT_PROPERTIES: json_schemas_map[output_type]
                        if _is_model_serde(output_type)
                        else _VOID_TS_TYPE
                        if issubclass(output_type, NoneType)
                        else _BYTES_TS_TYPE,
                    }
                )
                for cmd, (input_type, output_type) in cmd_in_out_serde.items()
            }
        ),
        **definitions,  # $defs, title, description
    }

    return json_schemas


def _gen_client(cmds: Iterable[str]) -> str:
    return _CLIENT_PREFIX + "".join(
        _INVOKE_CMD_TEMPLATE.substitute(cmd=cmd) for cmd in cmds
    )


async def gen_ts(
    cmd_in_out: CommandInputOutput,
    json2ts_cmd: str,
    output_dir: Union[str, PathLike[str]],
):
    output_dir_path = Path(output_dir)
    await output_dir_path.mkdir(parents=True, exist_ok=True)

    async def gen_api_types():
        json_schemas = await to_thread.run_sync(
            _gen_json_schemas,
            cmd_in_out,
        )
        json_schemas_bytes = dumps(json_schemas).encode()
        process = await run_process(json2ts_cmd, input=json_schemas_bytes)

        api_types_file_path = output_dir_path / _API_TYPES_FILE_NAME
        await api_types_file_path.write_bytes(process.stdout)

    async def gen_api_client():
        api_client_code = _gen_client(cmd_in_out.keys())

        api_client_file_path = output_dir_path / _API_CLIENT_FILE_NAME
        await api_client_file_path.write_text(api_client_code)

    async with create_task_group() as tg:
        tg.start_soon(gen_api_types)
        tg.start_soon(gen_api_client)


if __name__ == "__main__":
    from anyio import run

    class Foo(BaseModel):
        a: int

    class Bar(BaseModel):
        a: Annotated[int, Field(serialization_alias="a_s")]
        b: Foo

    async def main():
        await gen_ts(
            {
                "commandA": InputOutput(type(None), Foo),
                "commandB": InputOutput(Bar, Bar),
                "commandC": InputOutput(Foo, type(None)),
            },
            "pnpm json2ts --format=false",
            ".",
        )

    run(main)

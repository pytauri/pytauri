from collections.abc import Iterable
from itertools import chain
from json import dumps
from os import PathLike
from string import Template
from typing import Annotated, Literal, Optional, Union

from anyio import Path, create_task_group, run_process, to_thread
from pydantic import BaseModel, Field
from pydantic.json_schema import JsonSchemaValue, models_json_schema
from typing_extensions import NamedTuple

_COMMANDS_TITLE = "Commands"
"""Default title for commands JSON schema."""

_INPUT_PROPERTIES = "input"
_OUTPUT_PROPERTIES = "output"

_BYTES_TS_TYPE = {
    "tsType": "ArrayBuffer",
}
"""Ref: <https://github.com/bcherny/json-schema-to-typescript/pull/168>."""

_API_TYPES_FILE_NAME = "_apiTypes.d.ts"
"""Default file name for generated TypeScript types for API."""

_API_CLIENT_FILE_NAME = "apiClient.ts"
"""Default file name for generated TypeScript API client."""

_CLIENT_PREFIX = f"""\
/* eslint-disable */
/**
* This file was automatically generated by pytauri-gen-ts.
* DO NOT MODIFY IT BY HAND. Instead, modify the source commands API,
* and run pytauri-gen-ts to regenerate this file.
*/

import {{ pyInvoke }} from "tauri-plugin-pytauri-api";
import {{ InvokeOptions }} from "@tauri-apps/api/core";

import type {{ {_COMMANDS_TITLE} }} from "./{_API_TYPES_FILE_NAME}";

"""

_INVOKE_CMD_TEMPLATE = Template(f"""\
export async function ${{cmd}}(
    body: {_COMMANDS_TITLE}["${{cmd}}"]["{_INPUT_PROPERTIES}"],
    options?: InvokeOptions
): Promise<{_COMMANDS_TITLE}["${{cmd}}"]["{_OUTPUT_PROPERTIES}"]> {{
    return await pyInvoke("${{cmd}}", body, options);
}};

""")


_Model = type[BaseModel]


class InputOutput(NamedTuple):
    input_model: Optional[_Model]
    output_model: Optional[_Model]


CommandInputOutput = dict[str, InputOutput]


class _InputOutputSerde(NamedTuple):
    input_model: Optional[tuple[_Model, Literal["validation"]]]
    output_model: Optional[tuple[_Model, Literal["serialization"]]]


_CommandInputOutputSerde = dict[str, _InputOutputSerde]


def _object_json_schema(properties: dict[str, JsonSchemaValue]) -> JsonSchemaValue:
    return {
        "type": "object",
        "properties": properties,
        "required": list(properties.keys()),
        "additionalProperties": False,
    }


def _gen_json_schemas(cmd_in_out: CommandInputOutput) -> JsonSchemaValue:
    cmd_in_out_serde: _CommandInputOutputSerde = {
        cmd: _InputOutputSerde(
            input_model=(input_model, "validation") if input_model else None,
            output_model=(output_model, "serialization") if output_model else None,
        )
        for cmd, (input_model, output_model) in cmd_in_out.items()
    }

    json_schemas_map, definitions = models_json_schema(
        tuple(filter(None, chain.from_iterable(cmd_in_out_serde.values()))),
        title=_COMMANDS_TITLE,
        description="Commands Input and Output Schemas",
    )

    json_schemas = {
        **_object_json_schema(
            {
                cmd: _object_json_schema(
                    {
                        _INPUT_PROPERTIES: json_schemas_map[input_model]
                        if input_model
                        else _BYTES_TS_TYPE,
                        _OUTPUT_PROPERTIES: json_schemas_map[output_model]
                        if output_model
                        else _BYTES_TS_TYPE,
                    }
                )
                for cmd, (input_model, output_model) in cmd_in_out_serde.items()
            }
        ),
        **definitions,  # $defs, title, description
    }

    return json_schemas


def _gen_client(cmds: Iterable[str]) -> str:
    return _CLIENT_PREFIX + "".join(
        _INVOKE_CMD_TEMPLATE.substitute(cmd=cmd) for cmd in cmds
    )


async def gen_ts(
    cmd_in_out: CommandInputOutput,
    json2ts_cmd: str,
    output_dir: Union[str, PathLike[str]],
):
    output_dir_path = Path(output_dir)
    await output_dir_path.mkdir(parents=True, exist_ok=True)

    async def gen_api_types():
        json_schemas = await to_thread.run_sync(
            _gen_json_schemas,
            cmd_in_out,
        )
        json_schemas_bytes = dumps(json_schemas).encode()
        process = await run_process(json2ts_cmd, input=json_schemas_bytes)

        api_types_file_path = output_dir_path / _API_TYPES_FILE_NAME
        await api_types_file_path.write_bytes(process.stdout)

    async def gen_api_client():
        api_client_code = _gen_client(cmd_in_out.keys())

        api_client_file_path = output_dir_path / _API_CLIENT_FILE_NAME
        await api_client_file_path.write_text(api_client_code)

    async with create_task_group() as tg:
        tg.start_soon(gen_api_types)
        tg.start_soon(gen_api_client)


if __name__ == "__main__":
    from anyio import run

    class Foo(BaseModel):
        a: int

    class Bar(BaseModel):
        a: Annotated[int, Field(serialization_alias="a_s")]
        b: Foo

    async def main():
        await gen_ts(
            {
                "commandA": InputOutput(Foo, None),
                "commandB": InputOutput(Bar, Bar),
            },
            "pnpm json2ts --format=false",
            ".",
        )

    run(main)

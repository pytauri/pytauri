{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pytauri","title":"PyTauri","text":"<p>Tauri bindings for Python through Pyo3</p> <p></p> <p>Documentation: https://wsh032.github.io/pytauri/</p> <p>Source Code: https://github.com/WSH032/pytauri/</p> <p>This is a completely free and open-source project, but it is difficult to maintain without incentives and contributions from the community.</p> <p>If you think this project is helpful, consider giving it a star , it would be very helpful for my work and studies. \ud83e\udd7a\ud83d\udc49\ud83d\udc48</p>"},{"location":"#features","title":"Features","text":"<p>TL;DR</p> <p>You are hurry and just wanna see/run the demo? See examples/tauri-app.</p> <ul> <li>Need Rust compiler, but almost don't need to write Rust code!</li> <li>Can be integrated with <code>tauri-cli</code> to build and package standalone executables!</li> <li>No IPC (inter-process communication) overhead, secure and fast, thanks to Pyo3!</li> <li> <p>Support Tauri official plugins(e.g., notification), and you can write your own plugins!</p> <p></p> </li> <li> <p>Natively support async python (<code>asyncio</code>, <code>trio</code> or <code>anyio</code>)</p> </li> <li>100% Type Completeness</li> <li> <p>Ergonomic API (and as close as possible to the Tauri Rust API)</p> <ul> <li> <p>Python</p> <pre><code>import sys\n\nfrom pydantic import BaseModel\nfrom pytauri import (\n    AppHandle,\n    Commands,\n)\nfrom pytauri_plugin_notification import NotificationExt\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person, app_handle: AppHandle) -&gt; Greeting:\n    notification_builder = NotificationExt.builder(app_handle)\n    notification_builder.show(title=\"Greeting\", body=f\"Hello, {body.name}!\")\n\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n</code></pre> </li> <li> <p>Frontend</p> <pre><code>import { pyInvoke } from \"tauri-plugin-pytauri-api\";\n// or: `const { pyInvoke } = window.__TAURI__.pytauri;`\n\nexport interface Person {\n    name: string;\n}\n\nexport interface Greeting {\n    message: string;\n}\n\nexport async function greet(body: Person): Promise&lt;Greeting&gt; {\n    return await pyInvoke(\"greet\", body);\n}\n</code></pre> </li> </ul> </li> <li> <p>Can be integrated with nicegui/gradio/FastAPI to achieve a full-stack Python development experience (i.g., without <code>Node.js</code>). See examples/nicegui-app.</p> </li> </ul>"},{"location":"#release","title":"Release","text":"<p>We follow Semantic Versioning 2.0.0.</p> <p>Rust and its Python bindings, PyTauri core and its plugins will keep the same <code>MAJOR.MINOR</code> version number.</p> name pypi crates.io npmjs \ud83d\udc49 core - - - pytauri pytauri-core tauri-plugin-pytauri \ud83d\udc49 plugins - - - pytauri-plugin-notification \ud83d\udc49 utils - - - pyo3-utils codelldb"},{"location":"#philosophy","title":"Philosophy","text":""},{"location":"#for-pythoneer","title":"For Pythoneer","text":"<p>I hope <code>PyTauri</code> can become an alternative to pywebview and Pystray, leveraging Tauri's comprehensive features to offer Python developers a GUI framework and a batteries-included development experience similar to electron and PySide.</p> <p>PyTauri is inspired by FastAPI and Pydantic, aiming to offer a similar development experience.</p>"},{"location":"#for-rustacean","title":"For Rustacean","text":"<p>Through Pyo3, I hope Rust developers can better utilize the Python ecosystem (e.g., building AI GUI applications with PyTorch).</p> <p>Although Rust's lifetime and ownership system makes Rust code safer, Python's garbage collection (GC) will make life easier. \ud83d\ude06</p>"},{"location":"#credits","title":"Credits","text":"<p>PyTauri is a project that aims to provide Python bindings for Tauri, a cross-platform webview GUI library. <code>Tauri</code> is a trademark of the Tauri Program within the Commons Conservancy and PyTauri is not officially endorsed or supported by them. PyTauri is an independent and community-driven effort that respects the original goals and values of Tauri. PyTauri does not claim any ownership or affiliation with the Tauri Program.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the Apache License 2.0.</p>"},{"location":"CHANGELOG/","title":"CHANGELOG","text":""},{"location":"CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <ul> <li><code>Highlights</code> for the most attractive new features.</li> <li><code>BREAKING</code> for breaking changes.</li> <li><code>Added</code> for new features.</li> <li><code>Changed</code> for changes in existing functionality.</li> <li><code>Deprecated</code> for soon-to-be removed features.</li> <li><code>Removed</code> for now removed features.</li> <li><code>Fixed</code> for any bug fixes.</li> <li><code>Security</code> in case of vulnerabilities.</li> <li><code>Docs</code> for documentation changes.</li> <li><code>YANKED</code> for deprecated releases.</li> <li><code>Internal</code> for internal changes. Only for maintainers.</li> </ul> <p>Tip</p> <p>This homepage is used to provide a blog-like changelog and <code>BREAKING CHANGE</code> migration guide.</p> <p>You can expand sub-projects to view detailed changelogs.</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/#highlights","title":"Highlights","text":"<ul> <li> <p>menu and tray python API bindings, see <code>pytauri</code> changelog for more details.</p> tray menu </li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>#79 - bump <code>rust-version = \"1.82\"</code></li> </ul>"},{"location":"CHANGELOG/#docs","title":"Docs","text":"<ul> <li>#88 - docs: add rust api reference section.</li> <li>#85 - docs: add concepts <code>IPC</code> and <code>using multiprocessing</code> sections.</li> <li>#80 - <code>example/nicegui-app</code>:<ul> <li>Use <code>BuilderArgs.setup</code> for initialization instead of listening to the <code>RunEvent.Ready</code> event.</li> <li>Rewrite the <code>FrontServer</code> <code>startup</code>/<code>shutdown</code> event hook logic.</li> <li>Modularize the code.</li> </ul> </li> <li>#79 - <code>example/nicegui-app</code>:<ul> <li>use <code>tray</code> and <code>menu</code> feature</li> <li>use <code>python3.10</code> <code>match</code> statement instead of <code>if-else</code> statement</li> <li>bump <code>requires-python = \"&gt;=3.10\"</code></li> </ul> </li> </ul>"},{"location":"CHANGELOG/#internal","title":"Internal","text":"<ul> <li>#81 - ci: add <code>clear-cache.yml</code> workflow.</li> </ul>"},{"location":"CHANGELOG/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/#breaking","title":"BREAKING","text":"<ul> <li>#70 - feat(notification): removed <code>NotificationBuilderArgs</code>.     See <code>CHANGELOG.md</code> of <code>py/pytauri-plugin-notification</code> for how to migrate.</li> <li>#57 - refactor(py/pytauri): remove <code>RunEventEnum</code>, use matched <code>RunEvent</code> directly.     See <code>CHANGELOG.md</code> of <code>py/pytauri</code> for how to migrate.</li> <li>#56 - perf(pytauri): all IPC methods that previously accepted <code>bytearray</code> as a parameter now only accept <code>bytes</code> as a parameter.</li> <li>#52 - refactor(standalone)!: new API for preparing python interpreter.     The <code>pytauri::standalone</code> module has been completely rewritten.     Previously, you used <code>prepare_freethreaded_python_with_executable</code> and <code>append_ext_mod</code>. Now, you need to use <code>PythonInterpreterBuilder</code>.     See the <code>pytauri</code> crate rust API docs and tutorial (examples/tauri-app) <code>main.rs</code> code for more information on how to migrate.</li> </ul>"},{"location":"CHANGELOG/#docs_1","title":"Docs","text":"<ul> <li>#60 - update <code>examples</code> <code>main.rs</code> to remove <code>resource_dir()</code> UNC path prefix <code>\\\\?\\</code> for <code>PythonInterpreterEnv::Standalone</code>. Fix pallets/jinja#1675 for <code>nicegui-app</code> standalone example.</li> <li>#55 - Add <code>integrate with nicegui</code> example <code>nicegui-app</code>. See <code>examples/nicegui-app</code>.</li> <li>#52 - update <code>examples/tauri-app</code> <code>main.rs</code> for new API to prepare python interpreter.</li> <li>#52 - add the usage of <code>multiprocessing.freeze_support</code> in <code>examples/tauri-app</code> <code>__main__.py</code>.</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>#46 - bump <code>tauri</code> to <code>v2.2</code></li> </ul>"},{"location":"CHANGELOG/#internal_1","title":"Internal","text":"<ul> <li>#83 - chore: bump <code>pyo3</code> to <code>v0.23.4</code> in <code>Cargo.lock</code> to fix PyO3/pyo3#4828.</li> <li>#64 - test: add integration tests for <code>command</code> and <code>channel</code> ipc</li> </ul>"},{"location":"CHANGELOG/#010-beta","title":"0.1.0-beta","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/","title":"tauri-plugin-pytauri-api","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#030","title":"0.3.0","text":"<p>bump workspace version</p>"},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#added","title":"Added","text":"<ul> <li>#50 - feat: add <code>class Channel extends TauriChannel&lt;ArrayBuffer&gt;</code> for pytauri channels ipc.</li> </ul>"},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#docs","title":"Docs","text":"<ul> <li>#50 - add tsdoc for all classes and functions.</li> </ul>"},{"location":"CHANGELOG/js/tauri-plugin-pytauri-api/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/py/codelldb/","title":"codelldb","text":""},{"location":"CHANGELOG/py/codelldb/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/py/codelldb/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/py/pyo3-utils/","title":"pyo3-utils","text":""},{"location":"CHANGELOG/py/pyo3-utils/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/py/pyo3-utils/#010-beta1","title":"0.1.0-beta.1","text":""},{"location":"CHANGELOG/py/pyo3-utils/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/py/pytauri-plugin-notification/","title":"pytauri-plugin-notification","text":""},{"location":"CHANGELOG/py/pytauri-plugin-notification/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/py/pytauri-plugin-notification/#030","title":"0.3.0","text":"<p>bump workspace version</p>"},{"location":"CHANGELOG/py/pytauri-plugin-notification/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/py/pytauri-plugin-notification/#breaking","title":"BREAKING","text":"<ul> <li> <p>#70 - Removed <code>NotificationBuilderArgs</code>.     Previously:</p> <pre><code>from pytauri_plugin_notification import NotificationBuilderArgs\n\nnotification_builder.show(\n    NotificationBuilderArgs(title=\"Greeting\", body=f\"Hello, {body.name}!\")\n)\n</code></pre> <p>Now:</p> <pre><code>notification_builder.show(title=\"Greeting\", body=f\"Hello, {body.name}!\")\n</code></pre> </li> </ul>"},{"location":"CHANGELOG/py/pytauri-plugin-notification/#added","title":"Added","text":"<ul> <li>#70 - feat: add more <code>NotificationBuilder</code> parameters<ul> <li><code>id</code></li> <li><code>channel_id</code></li> <li><code>large_body</code></li> <li><code>summary</code></li> <li><code>action_type_id</code></li> <li><code>group</code></li> <li><code>group_summary</code></li> <li><code>sound</code></li> <li><code>inbox_line</code></li> <li><code>icon</code></li> <li><code>large_icon</code></li> <li><code>icon_color</code></li> <li><code>ongoing</code></li> <li><code>auto_cancel</code></li> <li><code>silent</code></li> </ul> </li> </ul>"},{"location":"CHANGELOG/py/pytauri-plugin-notification/#changed","title":"Changed","text":"<ul> <li>#47 - refactor: use <code>pytauri::ImplManager</code> as <code>self::ImplNotificationExt</code></li> </ul>"},{"location":"CHANGELOG/py/pytauri-plugin-notification/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/py/pytauri/","title":"pytauri","text":""},{"location":"CHANGELOG/py/pytauri/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/py/pytauri/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/py/pytauri/#added","title":"Added","text":"<ul> <li>#83 - feat: add <code>def Context.set_assets</code> and <code>class Assets</code> to allow using custom assets (e.g, loading from memory/disk).</li> <li>#80 - feat: <code>BuilderArgs</code>:<ul> <li>add <code>BuilderArgs::setup</code> to support tauri app setup hook.</li> <li><code>BuilderArgs::context</code> now can be <code>Position and Keyword</code> arguments.</li> </ul> </li> <li>#79 - feat: implement tauri <code>tray</code> feature:     enable <code>tauri/tray-icon</code> feature<ul> <li><code>mod tauri::</code><ul> <li><code>Rect</code></li> <li><code>Size</code></li> <li><code>enum RunEvent::{MenuEvent, TrayIconEvent}</code></li> <li><code>AppHandle::{run_on_main_thread, exit, restart, on_tray_icon_event, tray_by_id, remove_tray_by_id, default_window_icon, invoke_key}</code></li> </ul> </li> <li><code>mod tauri::tray</code></li> <li><code>mod webview::</code><ul> <li><code>WebviewWindow::{run_on_main_thread, set_icon}</code></li> </ul> </li> </ul> </li> <li>#75 - feat: implement tauri <code>menu</code> feature:<ul> <li><code>mod tauri::</code><ul> <li><code>AppHandle::{on_menu_event, menu, set_menu, remove_menu, hide_menu, show_menu}</code></li> <li><code>Position</code></li> <li><code>PositionType</code></li> </ul> </li> <li><code>mod tauri::menu</code></li> <li><code>mod tauri::image</code></li> <li><code>mod tauri::window</code></li> <li><code>mod tauri::webview</code><ul> <li><code>WebviewWindow::{on_menu_event, menu, set_menu, remove_menu, hide_menu, show_menu, is_menu_visible, popup_menu, popup_menu_at}</code></li> <li><code>Webview::window</code></li> </ul> </li> </ul> </li> <li>#75 - feat: add <code>pillow &gt;= 11.1</code> as dependency.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#changed","title":"Changed","text":"<ul> <li>#76 - perf: use <code>pyo3::intern!</code> in <code>Invoke::bind_to</code> for commands <code>IPC</code> performance.</li> <li>#75 - perf: all methods of <code>WebviewWindow</code> will release the <code>GIL</code> now.</li> <li>#75 - perf: <code>App::{run, run_iteration}</code> will use a singleton <code>Py&lt;AppHandle&gt;</code> as an argument instead of fetching it from <code>tauri::State</code> each loop.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#internal","title":"Internal","text":"<ul> <li>#79 - <code>ffi.ipc.JavaScriptChannelId.from_str</code> becomes <code>staticmethod</code> from <code>classmethod</code>.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/py/pytauri/#breaking","title":"BREAKING","text":"<ul> <li> <p>#57 - refactor: remove <code>RunEventEnum</code>, use matched <code>RunEvent</code> directly.     Previously:</p> <pre><code>def callback(app_handle: AppHandle, run_event: RunEvent) -&gt; None:\n    run_event_enum: RunEventEnumType = run_event.match_ref()\n    match run_event_enum:\n        case RunEventEnum.Ready: ...\n\napp.run(callback)\n</code></pre> <p>Now:</p> <pre><code>def callback(app_handle: AppHandle, run_event: RunEventType) -&gt; None:\n    match run_event:\n        case RunEvent.Ready: ...\n\napp.run(callback)\n</code></pre> </li> <li> <p>#56 - perf: all IPC methods that previously accepted <code>bytearray</code> as a parameter now only accept <code>bytes</code> as a parameter.</p> </li> </ul>"},{"location":"CHANGELOG/py/pytauri/#added_1","title":"Added","text":"<ul> <li>#50 - feat: add <code>ipc::Channel</code>, <code>ipc::JavaScriptChannelId</code>, <code>webview::Webview</code>, <code>webview::WebviewWindow::as_ref::&lt;webview&gt;</code> for channels ipc.</li> <li>#46 - feat: add <code>webview::WebviewWindow</code>, <code>Manager</code>, <code>ImplManager</code>, <code>App::handle</code>.</li> <li>#48 - feat: accessing the <code>WebviewWindow</code> in <code>Commands</code>.</li> <li>#49 - feat: add <code>Event</code>, <code>EventId</code>, <code>Listener</code>, <code>ImplListener</code> for Event System.</li> </ul>"},{"location":"CHANGELOG/py/pytauri/#internal_1","title":"Internal","text":"<ul> <li>#54<ul> <li>feat: import the extension module from <code>sys.modules[\"__pytauri_ext_mod__\"]</code> if on standalone mode (<code>sys._pytauri_standalone</code>).</li> <li>feat: support specifying <code>entry_point</code> package name which be used to import the extension module via <code>os.environ[\"_PYTAURI_DIST\"]</code> (only for non-standalone mode).</li> </ul> </li> </ul>"},{"location":"CHANGELOG/py/pytauri/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/rs/pyo3-utils/","title":"pyo3-utils","text":""},{"location":"CHANGELOG/rs/pyo3-utils/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/rs/pyo3-utils/#010","title":"0.1.0","text":""},{"location":"CHANGELOG/rs/pyo3-utils/#docs","title":"Docs","text":"<ul> <li>#57 - add documentation to <code>mod py_match</code> indicating it should only be used for <code>state-machine-like</code> <code>enum</code>, not for <code>Union-like</code> <code>enum</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pyo3-utils/#internal","title":"Internal","text":"<ul> <li>#79 - refactor: use <code>rust v1.82</code> feature <code>Omitting empty types in pattern matching</code> in place of <code>Result&lt;T, Infallible&gt;::unwrap</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pyo3-utils/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/rs/pytauri-core/","title":"pytauri-core","text":""},{"location":"CHANGELOG/rs/pytauri-core/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/rs/pytauri-core/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/rs/pytauri-core/#breaking","title":"BREAKING","text":"<ul> <li>#80 - refactor: <code>trait PyAppHandleExt</code> is now sealed and no longer has generic parameters.</li> <li>#79 - pref: the fields of <code>enum RunEvent</code> <code>struct</code> variants become <code>Py&lt;T&gt;</code> types from rust types.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#added","title":"Added","text":"<ul> <li>#83 - feat: add <code>Context::set_assets</code> to allow using custom assets (e.g, loading from memory/disk).</li> <li>#80 - feat: add <code>PyAppHandleExt::get_or_init_py_app_handle</code>, and the methods return <code>&amp;Py&lt;AppHandle&gt;</code> instead of <code>impl Deref&lt;Target = Py&lt;AppHandle&gt;&gt;</code> now.</li> <li>#79 - feat: implement tauri <code>tray</code> feature:     enable <code>tauri/tray-icon</code> feature<ul> <li><code>mod tauri::</code><ul> <li><code>Rect</code></li> <li><code>Size</code></li> <li><code>enum RunEvent::{MenuEvent, TrayIconEvent}</code></li> <li><code>AppHandle::{run_on_main_thread, exit, restart, on_tray_icon_event, tray_by_id, remove_tray_by_id, default_window_icon, invoke_key}</code></li> </ul> </li> <li><code>mod tauri::tray</code></li> <li><code>mod webview::</code><ul> <li><code>WebviewWindow::{run_on_main_thread, set_icon}</code></li> </ul> </li> </ul> </li> <li>#75 - feat: implement tauri <code>menu</code> feature:<ul> <li><code>mod tauri::</code><ul> <li><code>AppHandle::{on_menu_event, menu, set_menu, remove_menu, hide_menu, show_menu}</code></li> <li><code>Position</code></li> <li><code>PositionType</code></li> </ul> </li> <li><code>mod tauri::menu</code></li> <li><code>mod tauri::image</code></li> <li><code>mod tauri::window</code></li> <li><code>mod tauri::webview</code><ul> <li><code>WebviewWindow::{on_menu_event, menu, set_menu, remove_menu, hide_menu, show_menu, is_menu_visible, popup_menu, popup_menu_at}</code></li> <li><code>Webview::window</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#changed","title":"Changed","text":"<ul> <li>#86 - pref: use <code>Cow&lt;'_, [u8]&gt;</code> instead of <code>Vec&lt;u8&gt;</code> as <code>pymehtods</code>/<code>pyfunction</code> and <code>extract</code> parameters to improve performance.     see PyO3/pyo3#3310 and PyO3/pyo3#2888 for more details.</li> <li>#79 - perf: almost all of pyo3 <code>pymethods</code> will release the <code>GIL</code> now.</li> <li>#76 - perf: use <code>pyo3::intern!</code> in <code>Invoke::bind_to</code> for commands <code>IPC</code> performance.</li> <li>#75 - perf: all methods of <code>WebviewWindow</code> will release the <code>GIL</code> now.</li> <li>#75 - perf: <code>App::{run, run_iteration}</code> will use a singleton <code>Py&lt;AppHandle&gt;</code> as an argument instead of fetching it from <code>tauri::State</code> each loop.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#internal","title":"Internal","text":"<ul> <li>#83 - refactor: add trait <code>utils::PyResultExt</code> to handle unraisable <code>PyErr</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/rs/pytauri-core/#breaking_1","title":"BREAKING","text":"<ul> <li>#57 - refactor: remove <code>RunEventEnum</code>, use matched <code>RunEvent</code> directly.</li> <li>#56 - perf: <code>Invoke::bind_to</code> now returns <code>[Self::BODY_KEY]</code>: <code>PyBytes</code> instead of <code>PyByteArray</code>.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#added_1","title":"Added","text":"<ul> <li>#50 - feat: add <code>ipc::Channel</code>, <code>ipc::JavaScriptChannelId</code>, <code>webview::Webview</code>, <code>webview::WebviewWindow::as_ref::&lt;webview&gt;</code> for channels ipc.</li> <li>#46 - feat: add <code>webview::WebviewWindow</code>, <code>Manager</code>, <code>ImplManager</code>, <code>App::handle</code>.</li> <li>#48 - feat: accessing the <code>WebviewWindow</code> in <code>Commands</code>.</li> <li>#49 - feat: add <code>Event</code>, <code>EventId</code>, <code>Listener</code>, <code>ImplListener</code> for Event System.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri-core/#010-beta1","title":"0.1.0-beta.1","text":""},{"location":"CHANGELOG/rs/pytauri-core/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/rs/pytauri-plugin-notification/","title":"pytauri-plugin-notification","text":""},{"location":"CHANGELOG/rs/pytauri-plugin-notification/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/rs/pytauri-plugin-notification/#030","title":"0.3.0","text":"<p>bump workspace version</p>"},{"location":"CHANGELOG/rs/pytauri-plugin-notification/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/rs/pytauri-plugin-notification/#breaking","title":"BREAKING","text":"<ul> <li>#70 - Removed <code>NotificationBuilderArgs</code></li> </ul>"},{"location":"CHANGELOG/rs/pytauri-plugin-notification/#added","title":"Added","text":"<ul> <li>#70 - feat: add more <code>NotificationBuilder</code> parameters<ul> <li><code>id</code></li> <li><code>channel_id</code></li> <li><code>large_body</code></li> <li><code>summary</code></li> <li><code>action_type_id</code></li> <li><code>group</code></li> <li><code>group_summary</code></li> <li><code>sound</code></li> <li><code>inbox_line</code></li> <li><code>icon</code></li> <li><code>large_icon</code></li> <li><code>icon_color</code></li> <li><code>ongoing</code></li> <li><code>auto_cancel</code></li> <li><code>silent</code></li> </ul> </li> </ul>"},{"location":"CHANGELOG/rs/pytauri-plugin-notification/#changed","title":"Changed","text":"<ul> <li>#47 - refactor: use <code>pytauri::ImplManager</code> as <code>self::ImplNotificationExt</code></li> </ul>"},{"location":"CHANGELOG/rs/pytauri-plugin-notification/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/rs/pytauri/","title":"pytauri","text":""},{"location":"CHANGELOG/rs/pytauri/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/rs/pytauri/#030","title":"0.3.0","text":""},{"location":"CHANGELOG/rs/pytauri/#added","title":"Added","text":"<ul> <li>#80 - feat: <code>BuilderArgs</code>:<ul> <li>add <code>BuilderArgs::setup</code> to support tauri app setup hook.</li> <li><code>BuilderArgs::context</code> now can be <code>Position and Keyword</code> arguments.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/rs/pytauri/#breaking","title":"BREAKING","text":"<ul> <li>#52 - refactor(standalone)!: new API for preparing python interpreter.     The <code>pytauri::standalone</code> module has been completely rewritten.     Previously, you used <code>prepare_freethreaded_python_with_executable</code> and <code>append_ext_mod</code>. Now, you need to use <code>PythonInterpreterBuilder</code>.     See the <code>pytauri</code> crate rust API docs and tutorial (examples/tauri-app) <code>main.rs</code> code for more information on how to migrate.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#added_1","title":"Added","text":"<ul> <li>#60 - feat: re-export <code>dunce::simplified</code> to remove <code>resource_dir()</code> UNC path prefix <code>\\\\?\\</code> for <code>PythonInterpreterEnv::Standalone</code>. Fix pallets/jinja#1675 for <code>nicegui-app</code> standalone example.</li> <li>#51 - feat: support <code>multiprocessing</code> for standalone app.<ul> <li>For standalone app:<ul> <li>set <code>sys.executable</code> to the actual python interpreter executable path.</li> <li>set <code>sys.argv</code> to <code>std::env::args_os()</code>.</li> <li>set <code>sys.frozen</code> to <code>True</code>.</li> <li>call <code>multiprocessing.set_start_method</code> with<ul> <li>windows: <code>spawn</code></li> <li>unix: <code>fork</code></li> </ul> </li> <li>call <code>multiprocessing.set_executable</code> with <code>std::env::current_exe()</code>.</li> </ul> </li> <li>Add <code>fn is_forking</code> for checking if the app is spawned by <code>multiprocessing</code>.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#internal","title":"Internal","text":"<ul> <li>#54 - feat: export the extension module to <code>sys.modules[\"__pytauri_ext_mod__\"]</code> if on standalone mode.</li> <li>#52 - feat: set <code>sys._pytauri_standalone=True</code> when run on standalone app (i.e., launch from rust).</li> <li>#51 - refactor: use <code>Python::run</code> with <code>locals</code> as arguments to execute <code>_append_ext_mod.py</code> for better performance.</li> </ul>"},{"location":"CHANGELOG/rs/pytauri/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/","title":"tauri-plugin-pytauri","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#030","title":"0.3.0","text":"<p>bump workspace version</p>"},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#020","title":"0.2.0","text":""},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#added","title":"Added","text":"<ul> <li>Update bound <code>tauri-plugin-pytauri-api</code> to <code>v0.2.0</code>. See it's <code>CHANGELOG.md</code> for more details.</li> </ul>"},{"location":"CHANGELOG/rs/tauri-plugin-pytauri/#010-beta0","title":"0.1.0-beta.0","text":""},{"location":"CONTRIBUTING/","title":"CONTRIBUTING","text":""},{"location":"CONTRIBUTING/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"CONTRIBUTING/#environment-setup","title":"Environment setup","text":"<p>Make sure you have installed <code>Rust</code>, <code>Python</code>, <code>uv</code>, <code>Node.js</code>, <code>pnpm</code>, <code>tauri-cli</code> and Tauri Prerequisites as documented.</p> <p>Also, you need <code>bash</code>. If you are on Windows, you can use Git for Windows.</p> <p>Fork the pytauri repository on GitHub.</p> <pre><code>#!/bin/bash\n\n# clone your fork locally\ngit clone git@github.com:your_name_here/pytauri.git\ncd pytauri\n# create a branch for local development\ngit checkout -b branch-name\n\n# install dev dependencies and build frontend assets\npnpm install\npnpm -r run build\n\n# activate virtual environment\nuv venv --python-preference=only-system\nsource .venv/bin/activate\n# or Windows: `source .venv/Scripts/activate`\n\n# install dev dependencies and tools\nuv sync\n\n# Init pre-commit (installed by `uv sync`)\n# https://pre-commit.com/#3-install-the-git-hook-scripts\npre-commit install\npre-commit run --all-files\n</code></pre> <p>That's all! Now, you can start to develop.</p>"},{"location":"CONTRIBUTING/#ide-setup","title":"IDE setup","text":"<p>We strongly recommend using <code>VSCode</code> with the extensions in <code>.vscode/extensions.json</code>.</p> <p>These extensions will help you to format, lint, type-check, and debug your code.</p>"},{"location":"CONTRIBUTING/#debug","title":"Debug","text":"<p>TODO</p> <ul> <li>check <code>.vscode/launch.json</code> and codelldb for debugging <code>py/rs</code> from python.</li> <li>check vscode/python-debugging for debugging <code>py/rs</code> from rust.</li> </ul>"},{"location":"CONTRIBUTING/#source-code","title":"Source code","text":"<ul> <li>python: members in <code>/pyproject.toml</code></li> <li>rust: menbers in <code>/Cargo.toml</code></li> <li>frontend: members in <code>/package.json</code></li> </ul>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>We use pytest and <code>cargo test</code> to test our code.</p>"},{"location":"CONTRIBUTING/#documentation","title":"Documentation","text":""},{"location":"CONTRIBUTING/#python-and-toturial","title":"Python and Toturial","text":"<p>We use mkdocs, mkdocs-material, mkdocstrings and mike to build our documentation.</p> <p>The documentation source code is in <code>docs/</code>, <code>docs_src/</code>, <code>mkdocs.yml</code>, and <code>utils/</code> (check <code>mkdocs.yml</code> to find others).</p> <p>Live-reloading main docs:</p> <pre><code>mkdocs serve\n</code></pre> <p>Live-reloading versioned docs:</p> <pre><code>mike serve\n</code></pre> <p>Docs references</p> <ul> <li>mkdocs/getting-started</li> <li>mkdocs-material/getting-started</li> <li>mkdocstrings/usage</li> </ul> <p>Tip</p> <p>We use <code>Google</code> style to write python docstrings, please refer to:</p> <ul> <li>mkdocstrings-python's documentation</li> <li>Napoleon's documentation</li> <li>Griffe's documentation</li> </ul>"},{"location":"CONTRIBUTING/#rust","title":"Rust","text":"<pre><code>cargo doc\n</code></pre>"},{"location":"CONTRIBUTING/#frontend","title":"Frontend","text":"<p>TODO</p>"},{"location":"CONTRIBUTING/#pr","title":"PR","text":"<ul> <li>PRs should target the <code>main</code> branch.</li> <li>Keep branches up to date by <code>rebase</code> before merging.</li> <li>Do not add multiple unrelated things in same PR.</li> <li>Do not submit PRs where you just take existing lines and reformat them without changing what they do.</li> <li>Do not change other parts of the code that are not yours for formatting reasons.</li> <li>Do not use your clone's main branch to make a PR - create a branch and PR that.</li> </ul>"},{"location":"CONTRIBUTING/#edit-changelogmd","title":"Edit <code>CHANGELOG.md</code>","text":"<p>If you have made the corresponding changes, please record them in <code>CHANGELOG.md</code>.</p>"},{"location":"CONTRIBUTING/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow Conventional Commits, or <code>pre-commit</code> will reject your commit.</p> <p>Info</p> <p>If you don't know how to finish these, it's okay, feel free to initiate a PR, we will help you continue.</p>"},{"location":"CONTRIBUTING/#ci-checks","title":"CI checks","text":"<p>We will check your commits on GitHub Actions, and your PR will only be merged if it passes the CI checks.</p> <p>You can run these checks locally by executing <code>pre-commit run --all-files</code> in bash.</p> <p>Usually, you don't need to do this manually, because <code>pre-commit</code> will automatically run these checks on each commit as long as you have installed the git hooks via <code>pre-commit install</code>.</p> <p>Tip</p> <p>Some slow checks are not run locally by default. If you really want to run them, pass <code>--hook-stage=manual</code>. You can also look at <code>.pre-commit-config.yaml</code> and run the individual checks yourself if you prefer.</p>"},{"location":"CONTRIBUTING/#_1","title":"\ud83d\ude22","text":"<p>Warning</p> <p>The following \ud83d\udc47 content is for the maintainers of this project, may be you don't need to read it.</p>"},{"location":"CONTRIBUTING/#deploy-docs","title":"Deploy Docs","text":"<p>please refer to <code>.github/workflows/docs.yml</code>.</p> <ul> <li>Every push to the <code>main</code> branch will trigger the <code>dev</code> version docs deployment.</li> <li> <p>Every <code>v*</code> semver tag will trigger the corresponding version docs deployment.</p> <p>Warning</p> <ul> <li>Remember update <code>CHANGELOG.md</code> before pushing the version docs tag!</li> <li>Remember make a Github Release (not package release) manually for the version docs deployment!</li> </ul> </li> </ul>"},{"location":"CONTRIBUTING/#pr-checks","title":"PR Checks","text":"<p>please refer to <code>.github/workflows/lint-test.yml</code>.</p> <ul> <li>Every PR push will trigger the CI checks.</li> </ul>"},{"location":"CONTRIBUTING/#publish-and-release","title":"Publish and Release \ud83d\ude80","text":"<p>Please refer to <code>.github/workflows/publish-*.yml</code>.</p> <ul> <li>Every <code>py|rs|js/package-name/v*</code> semver tag will trigger the corresponding package publish.</li> </ul> <p>First, check-out to a new branch, edit <code>CHANGELOG.md</code> to record the changes and bump the version.</p> <p>Warning</p> <p>Remember also update the dependencies version for workspace members.</p> <p>Then, push the new branch with the signed tag to GitHub, and create a PR to the <code>main</code> branch.</p> <p>Again, the tag must be signed!!!</p> <p>Warning</p> <p>The <code>bump version</code> PR must have only one commit with the corresponding tag; otherwise, it will be rejected.</p> <p>Review the PR, if it's ok, rebase it to <code>main</code> branch in local.</p> <p>DO NOT rebase with tag on GitHub.</p> <p>Refer to:</p> <p>https://docs.github.com/authentication/managing-commit-signature-verification/about-commit-signature-verification#signature-verification-for-rebase-and-merge</p> <p>When you use this option, GitHub creates modified commits using the original commit data and content.</p> <p>This will cause the commits merged into main to be inconsistent with the tagged commits.</p> <p>If you unfortunately do this, you must delete the tag and re-tag the merged commit.</p> <p>Check if everything is ok, for example:</p> <ul> <li>check if the tag is on the <code>main</code> branch.</li> <li>check if the version specified by the tag is correct.</li> <li>check if the dependencies version of workspace members are updated.</li> <li>check if the link in <code>CHANGELOG.md</code> is correct.</li> </ul> <p>If so, make a <code>approve</code> in environment <code>pypi</code>/<code>crates-io</code>/<code>npmjs</code> for the workflow.</p> <p>After that, the <code>publish-*.yml</code> workflow will build and publish the package.</p> <p>Finally, edit the <code>draft release</code> created by <code>publish-*.yml</code> workflow, and publish the release.</p>"},{"location":"reference/rs/","title":"Rust API Reference","text":"<p>It's available on <code>docs.rs</code>, click following badges.</p> name link \ud83d\udc49 core - pytauri pytauri-core tauri-plugin-pytauri \ud83d\udc49 plugins - pytauri-plugin-notification \ud83d\udc49 utils - pyo3-utils"},{"location":"reference/py/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pytauri_plugin_notification<ul> <li>ffi</li> </ul> </li> <li>codelldb</li> <li>pytauri<ul> <li>ffi<ul> <li>image</li> <li>ipc</li> <li>lib</li> <li>menu</li> <li>tray</li> <li>webview</li> <li>window</li> </ul> </li> <li>image</li> <li>ipc</li> <li>menu</li> <li>tray</li> <li>webview</li> <li>window</li> </ul> </li> <li>pyo3_utils</li> </ul>"},{"location":"reference/py/codelldb/","title":"codelldb","text":""},{"location":"reference/py/codelldb/#codelldb","title":"codelldb","text":"<p>Launch CodeLLDB in debugpy to debug rust code.</p>"},{"location":"reference/py/codelldb/#codelldb--usage","title":"Usage","text":"<p>Tip</p> <p>This package only depends on the Python standard library, so you can integrate it freely.</p>"},{"location":"reference/py/codelldb/#codelldb--configuring-codelldb-rpc-server","title":"Configuring CodeLLDB rpc server","text":"<p>Please refer to the CodeLLDB documentation to set up the rpc server, and add the following content to <code>.vscode/settings.json</code>:</p> <pre><code>{\n  \"lldb.rpcServer\": {\n    \"host\": \"127.0.0.1\",\n    \"port\": 9552,\n    \"token\": \"secret\",\n  }\n}\n</code></pre>"},{"location":"reference/py/codelldb/#codelldb--configuring-python-debugger","title":"Configuring Python Debugger","text":"<p>Please refer to the Python Debugger documentation, and add the following content to <code>.vscode/launch.json</code>:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"python.debug\",\n            \"type\": \"debugpy\",\n            \"purpose\": [\n                \"debug-in-terminal\"\n            ],\n            \"console\": \"integratedTerminal\",\n            \"request\": \"launch\",\n            // see: &lt;https://code.visualstudio.com/docs/python/debugging#_set-configuration-options&gt;\n            \"module\": \"pytauri_demo\", // your module name\n            \"args\": [], // whatever you want\n            // following env vars will be used by `codelldb` package\n            \"env\": {\n                \"VSCODE_RUST_DEBUG\": \"${input:rustDebug}\",\n                // keep the following env vars in sync with `.vscode/settings.json`\n                \"VSCODE_LLDB_RPC_SERVER_HOST\": \"127.0.0.1\",\n                \"VSCODE_LLDB_RPC_SERVER_PORT\": \"9552\",\n                \"VSCODE_LLDB_RPC_SERVER_TOKEN\": \"secret\",\n            },\n        }\n    ],\n    // see: &lt;https://code.visualstudio.com/docs/editor/variables-reference#_input-variables&gt;\n    \"inputs\": [\n        {\n            \"type\": \"pickString\",\n            \"id\": \"rustDebug\",\n            \"description\": \"Whether to enable Rust debugging\",\n            \"options\": [\n                {\n                    \"label\": \"Enabled\",\n                    \"value\": \"1\"\n                },\n                {\n                    \"label\": \"Disabled\",\n                    \"value\": \"0\"\n                }\n            ],\n            \"default\": \"0\"\n        },\n    ]\n}\n</code></pre>"},{"location":"reference/py/codelldb/#codelldb--multi-target-debugging","title":"Multi-target debugging","text":"<p>When starting Python Debugger via <code>F5</code>, you will see a selection box, choose <code>Enabled</code> to enable Rust debugging.</p> <p>Functions:</p> Name Description <code>debug</code> <p>Launch CodeLLDB to debug rust code.</p>"},{"location":"reference/py/codelldb/#codelldb.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['debug']\n</code></pre>"},{"location":"reference/py/codelldb/#codelldb.VSCODE_RUST_DEBUG_VARNAME","title":"VSCODE_RUST_DEBUG_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_RUST_DEBUG_VARNAME = 'VSCODE_RUST_DEBUG'\n</code></pre> <p>Whether to enable Rust debugging, set to <code>1</code> to enable, <code>0</code> to disable.</p>"},{"location":"reference/py/codelldb/#codelldb.VSCODE_LLDB_RPC_SERVER_HOST_VARNAME","title":"VSCODE_LLDB_RPC_SERVER_HOST_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_LLDB_RPC_SERVER_HOST_VARNAME = 'VSCODE_LLDB_RPC_SERVER_HOST'\n</code></pre> <p>The host of the CodeLLDB rpc server.</p>"},{"location":"reference/py/codelldb/#codelldb.VSCODE_LLDB_RPC_SERVER_PORT_VARNAME","title":"VSCODE_LLDB_RPC_SERVER_PORT_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_LLDB_RPC_SERVER_PORT_VARNAME = 'VSCODE_LLDB_RPC_SERVER_PORT'\n</code></pre> <p>The port of the CodeLLDB rpc server.</p>"},{"location":"reference/py/codelldb/#codelldb.VSCODE_LLDB_RPC_SERVER_TOKEN_VARNAME","title":"VSCODE_LLDB_RPC_SERVER_TOKEN_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_LLDB_RPC_SERVER_TOKEN_VARNAME = 'VSCODE_LLDB_RPC_SERVER_TOKEN'\n</code></pre> <p>The secret token of the CodeLLDB rpc server.</p>"},{"location":"reference/py/codelldb/#codelldb.DEFAULT_HOST","title":"DEFAULT_HOST  <code>module-attribute</code>","text":"<pre><code>DEFAULT_HOST = '127.0.0.1'\n</code></pre>"},{"location":"reference/py/codelldb/#codelldb.DebugError","title":"DebugError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"reference/py/codelldb/#codelldb.debug","title":"debug","text":"<pre><code>debug() -&gt; None\n</code></pre> <p>Launch CodeLLDB to debug rust code.</p> <p>If the value indicated by VSCODE_RUST_DEBUG_VARNAME is not <code>1</code>, this is a no-op.</p> <p>Raises:</p> Type Description <code>DebugError</code> <p>If the provided environment variables cannot be correctly parsed.</p> Note <p>If failed to connect to the lldb rpc server, a warning message will be logged instead of raising an exception.</p> Source code in <code>python/codelldb/src/codelldb/__init__.py</code> <pre><code>def debug() -&gt; None:\n    \"\"\"Launch CodeLLDB to debug rust code.\n\n    If the value indicated by [VSCODE_RUST_DEBUG_VARNAME][codelldb.VSCODE_RUST_DEBUG_VARNAME] is not `1`, this is a no-op.\n\n    Raises:\n        DebugError: If the provided environment variables cannot be correctly parsed.\n\n    Note:\n        If failed to connect to the lldb rpc server, a warning message will be logged instead of raising an exception.\n    \"\"\"\n    vscode_rust_debug = getenv(VSCODE_RUST_DEBUG_VARNAME)\n    if vscode_rust_debug != \"1\":\n        return\n\n    _logger.info(f\"'{VSCODE_RUST_DEBUG_VARNAME}' is set, enabling rust debug mode\")\n\n    lldb_rpc_server_cfg = _get_lldb_rpc_server_cfg()\n\n    host = lldb_rpc_server_cfg[\"host\"]\n    port = lldb_rpc_server_cfg[\"port\"]\n    token = lldb_rpc_server_cfg[\"token\"]\n\n    token_data = f\"token: {token}\" if token else \"\"\n    # See: &lt;https://github.com/vadimcn/codelldb/blob/v1.10.0/MANUAL.md#rpc-server&gt;\n    # Line-oriented YAML Syntax: &lt;https://github.com/vadimcn/codelldb/blob/v1.10.0/MANUAL.md#debugging-externally-launched-code&gt;\n    # Arg: &lt;https://github.com/vadimcn/codelldb/blob/v1.10.0/MANUAL.md#attaching-to-a-running-process&gt;\n    rpc_data = dedent(f\"\"\"\\\n        name: \"rust.debug\"\n        type: \"lldb\"\n        request: \"attach\"\n        pid: {getpid()}\n        sourceLanguages:\n            - rust\n            - c\n            - cpp\n        {token_data}\n    \"\"\")\n\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((host, port))\n\n        s.sendall(rpc_data.encode(\"utf-8\"))\n\n        s.shutdown(socket.SHUT_WR)\n\n        response = s.recv(1024)\n\n        if not response:\n            _logger.warning(\n                \"Failed to get response from lldb rpc server, \"\n                \"maybe the rpc `token` is not correct.\"\n            )\n            return\n\n        try:\n            response = json.loads(response)\n            assert isinstance(response, dict)\n        except Exception as e:\n            _logger.warning(\n                f\"Failed to parse response from lldb rpc server: {response}\", exc_info=e\n            )\n            return\n\n        if response.get(\"success\") is not True:  # pyright: ignore[reportUnknownMemberType]\n            _logger.warning(\n                f\"Seems like lldb rpc server failed to attach to the process: {response}\"\n            )\n            return\n</code></pre>"},{"location":"reference/py/pyo3_utils/","title":"pyo3_utils","text":""},{"location":"reference/py/pyo3_utils/#pyo3_utils","title":"pyo3_utils","text":"<p>Python integration for the <code>pyo3-utils</code> crate.</p> <p>Classes:</p> Name Description <code>PyMatchRefMixin</code> <p>Rust <code>match &amp;self</code> for Python.</p> <code>PyMatchMutMixin</code> <p>Rust <code>match &amp;mut self</code> for Python.</p> <code>PyMatchIntoMixin</code> <p>Rust <code>match self</code> for Python.</p>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['PyMatchIntoMixin', 'PyMatchMutMixin', 'PyMatchRefMixin']\n</code></pre>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchRefMixin","title":"PyMatchRefMixin","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Rust <code>match &amp;self</code> for Python.</p> <p>This class is only used to provide type annotations, the actual implementation of the methods is handled by the pyo3 extension module.</p> Note <p>This class can only be used when <code>TYPE_CHECKING</code>.</p> <p>Methods:</p> Name Description <code>match_ref</code> <p>Equivalent to <code>match &amp;self</code> in Rust.</p>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchRefMixin.match_ref","title":"match_ref","text":"<pre><code>match_ref() -&gt; _T\n</code></pre> <p>Equivalent to <code>match &amp;self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_ref(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match &amp;self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchMutMixin","title":"PyMatchMutMixin","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Rust <code>match &amp;mut self</code> for Python.</p> <p>This class is only used to provide type annotations, the actual implementation of the methods is handled by the pyo3 extension module.</p> Note <p>This class can only be used when <code>TYPE_CHECKING</code>.</p> <p>Methods:</p> Name Description <code>match_mut</code> <p>Equivalent to <code>match &amp;mut self</code> in Rust.</p>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchMutMixin.match_mut","title":"match_mut","text":"<pre><code>match_mut() -&gt; _T\n</code></pre> <p>Equivalent to <code>match &amp;mut self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_mut(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match &amp;mut self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchIntoMixin","title":"PyMatchIntoMixin","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Rust <code>match self</code> for Python.</p> <p>This class is only used to provide type annotations, the actual implementation of the methods is handled by the pyo3 extension module.</p> Note <p>This class can only be used when <code>TYPE_CHECKING</code>.</p> <p>Methods:</p> Name Description <code>match_into</code> <p>Equivalent to <code>match self</code> in Rust.</p>"},{"location":"reference/py/pyo3_utils/#pyo3_utils.PyMatchIntoMixin.match_into","title":"match_into","text":"<pre><code>match_into() -&gt; _T\n</code></pre> <p>Equivalent to <code>match self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_into(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/","title":"pytauri","text":""},{"location":"reference/py/pytauri/#pytauri","title":"pytauri","text":"<p>tauri::self</p> <p>Modules:</p> Name Description <code>ffi</code> <p>Original FFI interface module.</p> <code>image</code> <p>tauri::image</p> <code>ipc</code> <p>tauri::ipc</p> <code>menu</code> <p>tauri::menu</p> <code>tray</code> <p>tauri::tray</p> <code>webview</code> <p>tauri::webview</p> <code>window</code> <p>tauri::window</p> <p>Classes:</p> Name Description <code>App</code> <p>Tauri::app</p> <code>AppHandle</code> <p>tauri::AppHandle</p> <code>Assets</code> <p>tauri::Assets</p> <code>Builder</code> <p>Tauri::Builder</p> <code>BuilderArgs</code> <code>Context</code> <p>tauri::Context</p> <code>Event</code> <p>tauri::Event</p> <code>Listener</code> <p>tauri::Listener</p> <code>Manager</code> <p>tauri::Manager</p> <code>Position</code> <p>tauri::Position</p> <code>Rect</code> <p>tauri::Rect</p> <code>RunEvent</code> <p>tauri::RunEvent</p> <code>Size</code> <p>tauri::Size</p> <code>Commands</code> <p>This class provides features similar to tauri::generate_handler.</p> <p>Functions:</p> Name Description <code>builder_factory</code> <p>A factory function for creating a <code>Builder</code> instance.</p> <code>context_factory</code> <p>A factory function for creating a <code>Context</code> instance.</p> <p>Attributes:</p> Name Type Description <code>EXT_MOD</code> <code>ModuleType</code> <p>The extension module of <code>pytauri</code> app.</p> <code>EventId</code> <p>tauri::EventId</p> <code>ImplListener</code> <code>ImplManager</code> <code>PositionType</code> <p>See Position for details.</p> <code>RunEventType</code> <p>See RunEvent for details.</p> <code>SizeType</code> <p>See Size for details.</p>"},{"location":"reference/py/pytauri/#pytauri.EXT_MOD","title":"EXT_MOD  <code>module-attribute</code>","text":"<pre><code>EXT_MOD: ModuleType\n</code></pre> <p>The extension module of <code>pytauri</code> app.</p> <p>It will be loaded from <code>entry_points(group=\"pytauri\", name=\"ext_mod\")</code>.</p> <p>Usually you don't need to use it, unless you want to write plugins for <code>pytauri</code>.</p>"},{"location":"reference/py/pytauri/#pytauri.EventId","title":"EventId  <code>module-attribute</code>","text":"<pre><code>EventId = NewType('EventId', int)\n</code></pre> <p>tauri::EventId</p>"},{"location":"reference/py/pytauri/#pytauri.ImplListener","title":"ImplListener  <code>module-attribute</code>","text":"<pre><code>ImplListener = ImplManager\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.ImplManager","title":"ImplManager  <code>module-attribute</code>","text":"<pre><code>ImplManager = TypeAliasType('ImplManager', Union[App, AppHandle, 'webview.WebviewWindow'])\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.PositionType","title":"PositionType  <code>module-attribute</code>","text":"<pre><code>PositionType = TypeAliasType('PositionType', Union[Physical, Logical])\n</code></pre> <p>See Position for details.</p>"},{"location":"reference/py/pytauri/#pytauri.RunEventType","title":"RunEventType  <code>module-attribute</code>","text":"<pre><code>RunEventType = TypeAliasType('RunEventType', Union[Exit, ExitRequested, WindowEvent, WebviewEvent, Ready, Resumed, MainEventsCleared, MenuEvent, TrayIconEvent])\n</code></pre> <p>See RunEvent for details.</p>"},{"location":"reference/py/pytauri/#pytauri.SizeType","title":"SizeType  <code>module-attribute</code>","text":"<pre><code>SizeType = TypeAliasType('SizeType', Union[Physical, Logical])\n</code></pre> <p>See Size for details.</p>"},{"location":"reference/py/pytauri/#pytauri.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['EXT_MOD', 'App', 'AppHandle', 'Assets', 'Builder', 'BuilderArgs', 'Commands', 'Context', 'Event', 'EventId', 'ImplListener', 'ImplManager', 'Listener', 'Manager', 'Position', 'PositionType', 'Rect', 'RunEvent', 'RunEventType', 'Size', 'SizeType', 'builder_factory', 'context_factory']\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.App","title":"App","text":"<p>Tauri::app</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>run</code> <p>Consume and run this app, will block until the app is exited.</p> <code>run_iteration</code> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <code>cleanup_before_exit</code> <p>Runs necessary cleanup tasks before exiting the process.</p> <code>handle</code> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p>"},{"location":"reference/py/pytauri/#pytauri.App.run","title":"run","text":"<pre><code>run(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Consume and run this app, will block until the app is exited.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each event. It will be called on the same thread that the app was created on, so you should not block in this function.</p> <code>None</code> <p>Warning</p> <p>If <code>callback</code> is specified, it must not raise an exception, otherwise it is undefined behavior, and in most cases, the program will panic.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; None:\n    \"\"\"Consume and run this app, will block until the app is exited.\n\n    Args:\n        callback: a callback function that will be called on each event.\n            It will be called on the same thread that the app was created on,\n            so you should not block in this function.\n\n    !!! warning\n        If `callback` is specified, it must not raise an exception,\n        otherwise it is undefined behavior, and in most cases, the program will panic.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.App.run(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/#pytauri.App.run_iteration","title":"run_iteration","text":"<pre><code>run_iteration(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each iteration.</p> <code>None</code> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> <p>Tip</p> <p>Approximately 2ms per calling in debug mode.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_iteration(\n    self, callback: Optional[_AppRunCallbackType] = None, /\n) -&gt; None:\n    \"\"\"Run this app iteratively without consuming it, calling `callback` on each iteration.\n\n    Args:\n        callback: a callback function that will be called on each iteration.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n\n    !!! tip\n        Approximately 2ms per calling in debug mode.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.App.run_iteration(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/#pytauri.App.cleanup_before_exit","title":"cleanup_before_exit","text":"<pre><code>cleanup_before_exit() -&gt; None\n</code></pre> <p>Runs necessary cleanup tasks before exiting the process.</p> <p>You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def cleanup_before_exit(self, /) -&gt; None:\n    \"\"\"Runs necessary cleanup tasks before exiting the process.\n\n    **You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.**\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.App.handle","title":"handle","text":"<pre><code>handle() -&gt; AppHandle\n</code></pre> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def handle(self, /) -&gt; \"AppHandle\":\n    \"\"\"Get a handle to this app, which can be used to interact with the app from another thread.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle","title":"AppHandle","text":"<p>tauri::AppHandle</p> <p>Methods:</p> Name Description <code>run_on_main_thread</code> <p>Runs the given closure on the main thread.</p> <code>exit</code> <code>restart</code> <code>on_menu_event</code> <p>Registers a global menu event listener.</p> <code>on_tray_icon_event</code> <p>Registers a global tray icon menu event listener.</p> <code>tray_by_id</code> <code>remove_tray_by_id</code> <code>default_window_icon</code> <p>Returns the default window icon.</p> <code>menu</code> <code>set_menu</code> <code>remove_menu</code> <code>hide_menu</code> <code>show_menu</code> <code>invoke_key</code>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.run_on_main_thread","title":"run_on_main_thread","text":"<pre><code>run_on_main_thread(handler: Callable[[], object]) -&gt; None\n</code></pre> <p>Runs the given closure on the main thread.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_on_main_thread(self, handler: Callable[[], object], /) -&gt; None:\n    \"\"\"Runs the given closure on the main thread.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.exit","title":"exit","text":"<pre><code>exit(exit_code: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def exit(self, exit_code: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.restart","title":"restart","text":"<pre><code>restart() -&gt; Never\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def restart(self, /) -&gt; Never: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[Self, MenuEvent], None]) -&gt; None\n</code></pre> <p>Registers a global menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[\"Self\", \"MenuEvent\"], None], /\n) -&gt; None:\n    \"\"\"Registers a global menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.on_tray_icon_event","title":"on_tray_icon_event","text":"<pre><code>on_tray_icon_event(handler: Callable[[Self, TrayIconEventType], None]) -&gt; None\n</code></pre> <p>Registers a global tray icon menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_tray_icon_event(\n    self, handler: Callable[[Self, TrayIconEventType], None], /\n) -&gt; None:\n    \"\"\"Registers a global tray icon menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.tray_by_id","title":"tray_by_id","text":"<pre><code>tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.remove_tray_by_id","title":"remove_tray_by_id","text":"<pre><code>remove_tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.default_window_icon","title":"default_window_icon","text":"<pre><code>default_window_icon() -&gt; Optional[Image]\n</code></pre> <p>Returns the default window icon.</p> <p>Warning</p> <p>Each time you call this function, a new image instance will be created. So you should cache the result if you need to use it multiple times.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def default_window_icon(self, /) -&gt; Optional[Image]:\n    \"\"\"Returns the default window icon.\n\n    !!! warning\n        Each time you call this function, a new image instance will be created.\n        So you should cache the result if you need to use it multiple times.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.menu","title":"menu","text":"<pre><code>menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Menu) -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_menu(self, menu: Menu, /) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.remove_menu","title":"remove_menu","text":"<pre><code>remove_menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.hide_menu","title":"hide_menu","text":"<pre><code>hide_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def hide_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.show_menu","title":"show_menu","text":"<pre><code>show_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def show_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.AppHandle.invoke_key","title":"invoke_key","text":"<pre><code>invoke_key() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def invoke_key(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Assets","title":"Assets","text":"<p>               Bases: <code>ABC</code></p> <p>tauri::Assets</p> <p>This is an abstract class that you can subclass to implement a custom asset loader.</p> <p>See <code>tauri::Assets</code> rust docs for more details.</p> <p>Warning</p> <p>The implement has the same restrictions as App.run.</p> <p>Methods:</p> Name Description <code>get</code> <code>iter</code> <code>setup</code>"},{"location":"reference/py/pytauri/#pytauri.Assets.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key: _AssetKey) -&gt; Optional[bytes]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef get(self, key: _AssetKey, /) -&gt; Optional[bytes]: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Assets.iter","title":"iter  <code>abstractmethod</code>","text":"<pre><code>iter() -&gt; Iterator[tuple[str, bytes]]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef iter(self, /) -&gt; Iterator[tuple[str, bytes]]: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Assets.setup","title":"setup","text":"<pre><code>setup(_app: AppHandle) -&gt; object\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def setup(self, _app: AppHandle, /) -&gt; object:\n    return None\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Builder","title":"Builder","text":"<p>Tauri::Builder</p> <p>use builder_factory to instantiate this class.</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>build</code> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p>"},{"location":"reference/py/pytauri/#pytauri.Builder.build","title":"build","text":"<pre><code>build(args: BuilderArgs) -&gt; App\n</code></pre> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def build(self, args: BuilderArgs, /) -&gt; App:\n    \"\"\"Consume this builder and build an app with the given `BuilderArgs`.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.BuilderArgs","title":"BuilderArgs","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>tauri::Builder</p>"},{"location":"reference/py/pytauri/#pytauri.BuilderArgs.__new__","title":"__new__","text":"<pre><code>__new__(context: Context, *, invoke_handler: Optional[_InvokeHandlerProto] = None, setup: Optional[Callable[[AppHandle], object]] = None) -&gt; Self\n</code></pre> <p>tauri::Builder</p> <p>Warning</p> <p>The implementer of <code>invoke_handler</code> must never raise an exception, otherwise it is considered undefined behavior. Additionally, <code>invoke_handler</code> must not block.</p> <p>Parameters:</p> Name Type Description Default <code>Context</code> <p>use context_factory to get it.</p> required <code>Optional[_InvokeHandlerProto]</code> <p>use Commands to get it.</p> <code>None</code> <code>Optional[Callable[[AppHandle], object]]</code> <p>see rust <code>tauri::Builder::setup</code>.</p> <code>None</code> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    context: \"Context\",\n    *,\n    invoke_handler: Optional[_InvokeHandlerProto] = None,\n    setup: Optional[Callable[[AppHandle], object]] = None,\n) -&gt; Self:\n    \"\"\"[tauri::Builder](https://docs.rs/tauri/latest/tauri/struct.Builder.html)\n\n    !!! warning\n        The implementer of `invoke_handler` must never raise an exception,\n        otherwise it is considered undefined behavior.\n        Additionally, `invoke_handler` must not block.\n\n    Args:\n        context: use [context_factory][pytauri.context_factory] to get it.\n        invoke_handler: use [Commands][pytauri.ipc.Commands] to get it.\n        setup: see rust `tauri::Builder::setup`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.BuilderArgs.__new__(context)","title":"<code>context</code>","text":""},{"location":"reference/py/pytauri/#pytauri.BuilderArgs.__new__(invoke_handler)","title":"<code>invoke_handler</code>","text":""},{"location":"reference/py/pytauri/#pytauri.BuilderArgs.__new__(setup)","title":"<code>setup</code>","text":""},{"location":"reference/py/pytauri/#pytauri.Context","title":"Context","text":"<p>tauri::Context</p> <p>Methods:</p> Name Description <code>set_assets</code> <p>Use custom assets instead of the assets bundled by Tauri.</p>"},{"location":"reference/py/pytauri/#pytauri.Context.set_assets","title":"set_assets","text":"<pre><code>set_assets(assets: Assets) -&gt; None\n</code></pre> <p>Use custom assets instead of the assets bundled by Tauri.</p> <p>To make this work:</p> <ul> <li>You need to enable the <code>tauri/custom-protocol</code> feature.<ul> <li>Or build using <code>tauri build</code>.</li> </ul> </li> <li>Set <code>frontendDist</code> in <code>tauri.conf.json</code> to an empty directory (do not set it to a URL).<ul> <li> <p>Or generate <code>Context</code> via:</p> <pre><code>use tauri::{generate_context, test::noop_assets};\n\nlet context = generate_context!(assets=noop_assets());\n</code></pre> <p>then we will use this method to set the assets.</p> <p>see: https://github.com/tauri-apps/tauri/pull/9141</p> </li> </ul> </li> </ul> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_assets(self, assets: \"Assets\", /) -&gt; None:\n    \"\"\"Use custom assets instead of the assets bundled by Tauri.\n\n    To make this work:\n\n    - You need to enable the `tauri/custom-protocol` feature.\n        - Or build using `tauri build`.\n    - Set `frontendDist` in `tauri.conf.json` to an empty directory (do not set it to a URL).\n        - Or generate `Context` via:\n\n            ```rust\n            use tauri::{generate_context, test::noop_assets};\n\n            let context = generate_context!(assets=noop_assets());\n            ```\n\n            then we will use this method to set the assets.\n\n            see: &lt;https://github.com/tauri-apps/tauri/pull/9141&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Event","title":"Event","text":"<p>tauri::Event</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>EventId</code> <p>The <code>EventId</code> of the handler that was triggered.</p> <code>payload</code> <code>str</code> <p>The event payload.</p>"},{"location":"reference/py/pytauri/#pytauri.Event.id","title":"id  <code>property</code>","text":"<pre><code>id: EventId\n</code></pre> <p>The <code>EventId</code> of the handler that was triggered.</p>"},{"location":"reference/py/pytauri/#pytauri.Event.payload","title":"payload  <code>property</code>","text":"<pre><code>payload: str\n</code></pre> <p>The event payload.</p>"},{"location":"reference/py/pytauri/#pytauri.Listener","title":"Listener","text":"<p>tauri::Listener</p> <p>See also: https://tauri.app/develop/calling-rust/#event-system</p>"},{"location":"reference/py/pytauri/#pytauri.Listener--example","title":"Example","text":"<pre><code>from pytauri import AppHandle, Event, Listener\n\n\ndef listen(app_handle: AppHandle) -&gt; None:\n    def handler(event: Event):\n        print(event.id, event.payload)\n\n    Listener.listen(app_handle, \"event_name\", handler)\n</code></pre> <p>Methods:</p> Name Description <code>listen</code> <p>Listen to an emitted event on this manager.</p> <code>once</code> <p>Listen to an event on this manager only once.</p> <code>unlisten</code> <p>Remove an event listener.</p> <code>listen_any</code> <p>Listen to an emitted event to any target.</p> <code>once_any</code> <p>Listens once to an emitted event to any target .</p>"},{"location":"reference/py/pytauri/#pytauri.Listener.listen","title":"listen  <code>staticmethod</code>","text":"<pre><code>listen(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event on this manager.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event on this manager.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Listener.once","title":"once  <code>staticmethod</code>","text":"<pre><code>once(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an event on this manager only once.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an event on this manager only once.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Listener.unlisten","title":"unlisten  <code>staticmethod</code>","text":"<pre><code>unlisten(slf: ImplListener, id: EventId) -&gt; None\n</code></pre> <p>Remove an event listener.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef unlisten(\n    slf: \"ImplListener\",\n    id: \"EventId\",  # noqa: A002\n    /,\n) -&gt; None:\n    \"\"\"Remove an event listener.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Listener.listen_any","title":"listen_any  <code>staticmethod</code>","text":"<pre><code>listen_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event to any target.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event to any target.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Listener.once_any","title":"once_any  <code>staticmethod</code>","text":"<pre><code>once_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listens once to an emitted event to any target .</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listens once to an emitted event to any target .\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Manager","title":"Manager","text":"<p>tauri::Manager</p> <p>Methods:</p> Name Description <code>app_handle</code> <p>The application handle associated with this manager.</p> <code>get_webview_window</code> <p>Fetch a single webview window from the manager.</p> <code>webview_windows</code> <p>Fetch all managed webview windows.</p>"},{"location":"reference/py/pytauri/#pytauri.Manager.app_handle","title":"app_handle  <code>staticmethod</code>","text":"<pre><code>app_handle(slf: ImplManager) -&gt; AppHandle\n</code></pre> <p>The application handle associated with this manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef app_handle(slf: \"ImplManager\", /) -&gt; AppHandle:\n    \"\"\"The application handle associated with this manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Manager.get_webview_window","title":"get_webview_window  <code>staticmethod</code>","text":"<pre><code>get_webview_window(slf: ImplManager, label: str) -&gt; Optional[WebviewWindow]\n</code></pre> <p>Fetch a single webview window from the manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef get_webview_window(\n    slf: \"ImplManager\", label: str, /\n) -&gt; Optional[webview.WebviewWindow]:\n    \"\"\"Fetch a single webview window from the manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Manager.webview_windows","title":"webview_windows  <code>staticmethod</code>","text":"<pre><code>webview_windows(slf: ImplManager) -&gt; dict[str, WebviewWindow]\n</code></pre> <p>Fetch all managed webview windows.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef webview_windows(slf: \"ImplManager\", /) -&gt; dict[str, webview.WebviewWindow]:\n    \"\"\"Fetch all managed webview windows.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Position","title":"Position","text":"<p>tauri::Position</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Position::Physical</p> <code>Logical</code> <p>tauri::Position::Logical</p>"},{"location":"reference/py/pytauri/#pytauri.Position.Physical","title":"Physical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Position::Physical</p> <p><code>[x, y]</code></p> <p>Warning</p> <p>This is actually a <code>Class</code> disguised as an <code>NamedTuple</code>. See also: https://pyo3.rs/v0.23.4/class.html#pyclass-enums.</p>"},{"location":"reference/py/pytauri/#pytauri.Position.Logical","title":"Logical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Position::Logical</p> <p><code>[x, y]</code></p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/#pytauri.Rect","title":"Rect","text":"<p>tauri::Rect</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>position</code> <code>PositionType</code> <code>size</code> <code>SizeType</code>"},{"location":"reference/py/pytauri/#pytauri.Rect.position","title":"position  <code>property</code>","text":"<pre><code>position: PositionType\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Rect.size","title":"size  <code>property</code>","text":"<pre><code>size: SizeType\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Rect.__new__","title":"__new__","text":"<pre><code>__new__(*, position: PositionType, size: SizeType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    position: \"PositionType\",\n    size: \"SizeType\",\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent","title":"RunEvent","text":"<p>tauri::RunEvent</p> <p>Classes:</p> Name Description <code>Exit</code> <p>tauri::RunEvent::Exit</p> <code>ExitRequested</code> <p>tauri::RunEvent::ExitRequested</p> <code>WindowEvent</code> <p>tauri::RunEvent::WindowEvent</p> <code>WebviewEvent</code> <p>tauri::RunEvent::WebviewEvent</p> <code>Ready</code> <p>tauri::RunEvent::Ready</p> <code>Resumed</code> <p>tauri::RunEvent::Resumed</p> <code>MainEventsCleared</code> <p>tauri::RunEvent::MainEventsCleared</p> <code>MenuEvent</code> <p>tauri::RunEvent::MenuEvent</p> <code>TrayIconEvent</code> <p>tauri::RunEvent::TrayIconEvent</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.Exit","title":"Exit","text":"<p>tauri::RunEvent::Exit</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.ExitRequested","title":"ExitRequested","text":"<p>tauri::RunEvent::ExitRequested</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>Optional[int]</code>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.ExitRequested.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Optional[int]\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.WindowEvent","title":"WindowEvent","text":"<p>tauri::RunEvent::WindowEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.WindowEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::RunEvent::WebviewEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.WebviewEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.Ready","title":"Ready","text":"<p>tauri::RunEvent::Ready</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.Resumed","title":"Resumed","text":"<p>tauri::RunEvent::Resumed</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.MainEventsCleared","title":"MainEventsCleared","text":"<p>tauri::RunEvent::MainEventsCleared</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.MenuEvent","title":"MenuEvent","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::RunEvent::MenuEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/#pytauri.RunEvent.TrayIconEvent","title":"TrayIconEvent","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::RunEvent::TrayIconEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/#pytauri.Size","title":"Size","text":"<p>tauri::Size</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Size::Physical</p> <code>Logical</code> <p>tauri::Size::Logical</p>"},{"location":"reference/py/pytauri/#pytauri.Size.Physical","title":"Physical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Size::Physical</p> <p><code>[width, height]</code></p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/#pytauri.Size.Logical","title":"Logical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Size::Logical</p> <p><code>[width, height]</code></p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/#pytauri.Commands","title":"Commands","text":"<pre><code>Commands()\n</code></pre> <p>               Bases: <code>UserDict[str, _PyInvokHandleData]</code></p> <p>This class provides features similar to tauri::generate_handler.</p> <p>Typically, you would use Commands.command to register a command handler function. Then, use Commands.generate_handler to get an <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Methods:</p> Name Description <code>generate_handler</code> <p>This method is similar to tauri::generate_handler.</p> <code>wrap_pyfunc</code> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <code>parse_parameters</code> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <code>set_command</code> <p>Set a command handler.</p> <code>command</code> <p>A decorator to register a command handler.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self) -&gt; None:  # noqa: D107\n    super().__init__()\n\n    data = self.data\n\n    async def _async_invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - the implementer of this function must not raise exceptions\n        # - and must ensure to fulfill `invoke/resolver`\n        resolver = None\n        try:\n            command = invoke.command\n            handler_data = data.get(command)\n            if handler_data is None:\n                invoke.reject(f\"no python handler `{command}` found\")\n                return\n\n            parameters = handler_data.parameters\n            handler = handler_data.handler\n\n            resolver = invoke.bind_to(parameters)\n            if resolver is None:\n                # `invoke` has already been rejected\n                return\n\n            try:\n                resp = await handler(**resolver.arguments)\n                # TODO, PERF: idk if this will block?\n            except InvokeException as e:\n                resolver.reject(e.value)\n            except Exception as e:\n                # # TODO: Should we return the traceback to the frontend?\n                # # It might leak information.\n                # from traceback import format_exc\n                # resolver.reject(format_exc())\n                _logger.exception(\n                    f\"invoke_handler {handler}: `{handler.__name__}` raised an exception\",\n                    exc_info=e,\n                )\n                resolver.reject(repr(e))\n            else:\n                resolver.resolve(resp)\n\n        except Exception as e:\n            msg = f\"{_async_invoke_handler} implementation raised an exception, please report this as a pytauri bug\"\n\n            _logger.critical(msg, exc_info=e)\n            if resolver is not None:\n                resolver.reject(msg)\n            else:\n                invoke.reject(msg)\n            raise\n\n    self._async_invoke_handler = _async_invoke_handler\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.generate_handler","title":"generate_handler","text":"<pre><code>generate_handler(portal: BlockingPortal) -&gt; _InvokeHandlerProto\n</code></pre> <p>This method is similar to tauri::generate_handler.</p> <p>You can use this method to get <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Examples:</p> <pre><code>from anyio.from_thread import start_blocking_portal\n\ncommands = Commands()\n\nwith start_blocking_portal(backend) as portal:\n    invoke_handler = commands.generate_handler(portal)\n    ...\n</code></pre> <p>Warning</p> <p>The <code>portal</code> must remain valid while the returned <code>invoke_handler</code> is being used.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def generate_handler(self, portal: BlockingPortal, /) -&gt; _InvokeHandlerProto:\n    \"\"\"This method is similar to [tauri::generate_handler](https://docs.rs/tauri/latest/tauri/macro.generate_handler.html).\n\n    You can use this method to get `invoke_handler` for use with [BuilderArgs][pytauri.BuilderArgs].\n\n    Examples:\n        ```py\n        from anyio.from_thread import start_blocking_portal\n\n        commands = Commands()\n\n        with start_blocking_portal(backend) as portal:\n            invoke_handler = commands.generate_handler(portal)\n            ...\n        ```\n\n    !!! warning\n        The `portal` must remain valid while the returned `invoke_handler` is being used.\n    \"\"\"\n    async_invoke_handler = self._async_invoke_handler\n\n    def invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - `invoke_handler` must not raise exception\n        # - must not block\n\n        # this func will be call in extern thread, so it's ok to use `start_task_soon`\n        portal.start_task_soon(async_invoke_handler, invoke)\n\n    return invoke_handler\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.wrap_pyfunc","title":"wrap_pyfunc  <code>staticmethod</code>","text":"<pre><code>wrap_pyfunc(pyfunc: _WrappablePyHandlerType) -&gt; _PyHandlerType\n</code></pre> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <p>Specifically:</p> <ul> <li>If <code>pyfunc</code> has a <code>KEYWORD_ONLY</code> parameter named <code>body</code>, will check if <code>issubclass(body, BaseModel)</code> is true,   and if so, wrap it as a new function with <code>body: bytes</code> parameter.</li> <li>If <code>pyfunc</code> conforms to <code>issubclass(return_annotation, BaseModel)</code>,   wrap it as a new function with <code>return_annotation: bytes</code> return type.</li> <li>If not, will return the original <code>pyfunc</code>.</li> </ul> <p>The <code>pyfunc</code> will be decorated using functools.wraps, and its <code>__signature__</code> will also be updated.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@staticmethod\ndef wrap_pyfunc(  # noqa: C901  # TODO: simplify the method\n    pyfunc: _WrappablePyHandlerType,\n) -&gt; _PyHandlerType:\n    \"\"\"Wrap a `Callable` to conform to the definition of PyHandlerType.\n\n    Specifically:\n\n    - If `pyfunc` has a `KEYWORD_ONLY` parameter named `body`, will check if `issubclass(body, BaseModel)` is true,\n      and if so, wrap it as a new function with `body: bytes` parameter.\n    - If `pyfunc` conforms to `issubclass(return_annotation, BaseModel)`,\n      wrap it as a new function with `return_annotation: bytes` return type.\n    - If not, will return the original `pyfunc`.\n\n    The `pyfunc` will be decorated using [functools.wraps][], and its `__signature__` will also be updated.\n    \"\"\"\n    serializer = None\n    deserializer = None\n\n    body_key = \"body\"\n\n    sig = signature(pyfunc)\n    parameters = sig.parameters\n    return_annotation = sig.return_annotation\n\n    body_param = parameters.get(body_key)\n    if body_param is not None:\n        if body_param.kind not in {\n            body_param.KEYWORD_ONLY,\n            body_param.POSITIONAL_OR_KEYWORD,\n        }:\n            raise ValueError(f\"Expected `{body_key}` to be KEYWORD_ONLY\")\n        body_type = body_param.annotation\n        if issubclass(body_type, BaseModel):\n            serializer = body_type.model_validate_json\n        else:\n            if not issubclass(body_type, bytes):\n                raise ValueError(\n                    f\"Expected `{body_key}` to be subclass of {BaseModel} or {bytes}, \"\n                    f\"got {body_type}\"\n                )\n\n    if issubclass(return_annotation, BaseModel):\n        deserializer = return_annotation.__pydantic_serializer__.to_json\n    else:\n        if not issubclass(return_annotation, bytes):\n            raise ValueError(\n                f\"Expected `return_annotation` to be subclass of {BaseModel} or {bytes}, \"\n                f\"got {return_annotation}\"\n            )\n\n    if not serializer and not deserializer:\n        return cast(_PyHandlerType, pyfunc)  # `cast` make typing happy\n\n    @wraps(pyfunc)\n    async def wrapper(*args: Any, **kwargs: Any) -&gt; bytes:\n        nonlocal serializer, deserializer\n\n        if serializer is not None:\n            body_bytes = kwargs[body_key]\n            assert isinstance(body_bytes, bytes)  # PERF\n            try:\n                body_model = serializer(body_bytes)\n            except ValidationError as e:\n                raise InvokeException(repr(e)) from e\n            kwargs[body_key] = body_model\n\n        resp = await pyfunc(*args, **kwargs)\n\n        if deserializer is not None:\n            assert isinstance(resp, BaseModel)  # PERF\n            return deserializer(resp)\n        else:\n            assert isinstance(resp, bytes)  # PERF\n            return resp\n\n    new_parameters = None\n    if serializer is not None:\n        new_parameters = parameters.copy()\n        new_parameters[body_key] = parameters[body_key].replace(annotation=bytes)\n\n    # see: &lt;https://docs.python.org/3.13/library/inspect.html#inspect.signature&gt;\n    wrapper.__signature__ = (  # pyright: ignore[reportAttributeAccessIssue]\n        sig.replace(\n            parameters=list(new_parameters.values()),\n            return_annotation=bytes,\n        )\n        if new_parameters\n        else sig.replace(return_annotation=bytes)\n    )\n    return wrapper\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.parse_parameters","title":"parse_parameters  <code>staticmethod</code>","text":"<pre><code>parse_parameters(pyfunc: _PyHandlerType, /, check_signature: bool = True) -&gt; ParametersType\n</code></pre> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <p>Check if the Signature of <code>pyfunc</code> conforms to ArgumentsType, and if the return value is a subclass of bytes.</p> <p>Parameters:</p> Name Type Description Default <code>_PyHandlerType</code> <p>The <code>Callable</code> to check.</p> required <code>bool</code> <p>Whether to check the signature of <code>pyfunc</code>. Set it to <code>False</code> only if you are sure that the signature conforms to the expected pattern.</p> <code>True</code> <p>Returns:</p> Type Description <code>ParametersType</code> <p>The parameters of the <code>pyfunc</code>. You can use it with Invoke.bind_to.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature does not conform to the expected pattern.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@staticmethod\ndef parse_parameters(\n    pyfunc: _PyHandlerType, /, check_signature: bool = True\n) -&gt; ParametersType:\n    \"\"\"Check the signature of a `Callable` and return the parameters.\n\n    Check if the [Signature][inspect.Signature] of `pyfunc` conforms to [ArgumentsType][pytauri.ipc.ArgumentsType],\n    and if the return value is a subclass of [bytes][].\n\n    Args:\n        pyfunc: The `Callable` to check.\n        check_signature: Whether to check the signature of `pyfunc`.\n            Set it to `False` only if you are sure that the signature conforms to the expected pattern.\n\n    Returns:\n        The parameters of the `pyfunc`. You can use it with [Invoke.bind_to][pytauri.ipc.Invoke.bind_to].\n\n    Raises:\n        ValueError: If the signature does not conform to the expected pattern.\n    \"\"\"\n    sig = signature(pyfunc)\n    # NOTE: it seems that `parameters.keys()` is already `sys._is_interned` in cpython\n    parameters = sig.parameters\n    if not check_signature:\n        # `cast` make typing happy\n        return cast(ParametersType, parameters)\n\n    return_annotation = sig.return_annotation\n\n    arguments_type = {\n        \"body\": bytes,\n        \"app_handle\": AppHandle,\n        \"webview_window\": WebviewWindow,\n    }\n\n    for name, param in parameters.items():\n        # check if the `parameters` type hint conforms to [pytauri.ipc.ArgumentsType][]\n\n        correct_anna = arguments_type.get(name)\n        if correct_anna is None:\n            raise ValueError(\n                f\"Unexpected parameter `{name}`, expected one of {list(arguments_type.keys())}\"\n            )\n        if not issubclass(param.annotation, correct_anna):\n            raise ValueError(\n                f\"Expected `{name}` to be subclass of `{correct_anna}`, got `{param.annotation}`\"\n            )\n    else:\n        # after checking, we are sure that the `parameters` are valid\n        parameters = cast(ParametersType, parameters)\n\n    if not issubclass(return_annotation, bytes):\n        raise ValueError(\n            f\"Expected return_annotation to be subclass of {bytes}, got `{return_annotation}`\"\n        )\n\n    return parameters\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.parse_parameters(pyfunc)","title":"<code>pyfunc</code>","text":""},{"location":"reference/py/pytauri/#pytauri.Commands.parse_parameters(check_signature)","title":"<code>check_signature</code>","text":""},{"location":"reference/py/pytauri/#pytauri.Commands.set_command","title":"set_command","text":"<pre><code>set_command(command: str, handler: _WrappablePyHandlerType, /, check_signature: bool = True) -&gt; None\n</code></pre> <p>Set a command handler.</p> <p>This method internally calls parse_parameters and wrap_pyfunc, <code>parse_parameters(wrap_pyfunc(handler))</code>.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def set_command(\n    self,\n    command: str,\n    handler: _WrappablePyHandlerType,\n    /,\n    check_signature: bool = True,\n) -&gt; None:\n    \"\"\"Set a command handler.\n\n    This method internally calls [parse_parameters][pytauri.Commands.parse_parameters]\n    and [wrap_pyfunc][pytauri.Commands.wrap_pyfunc], `parse_parameters(wrap_pyfunc(handler))`.\n    \"\"\"\n    new_handler = self.wrap_pyfunc(handler)\n    parameters = self.parse_parameters(new_handler, check_signature=check_signature)\n    self.data[command] = _PyInvokHandleData(parameters, new_handler)\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.command","title":"command","text":"<pre><code>command(command: Optional[str] = None) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]\n</code></pre> <p>A decorator to register a command handler.</p> <p>Examples:</p> <pre><code>commands = Commands()\n\n\n@commands.command()\nasync def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n@commands.command(\"foo_command\")\nasync def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n</code></pre> <p>This method internally calls set_command, which means the function signature must conform to ArgumentsType.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[str]</code> <p>The name of the command. If not provided, the <code>__name__</code> of <code>callable</code> will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a command with the same name already exists. If it's expected, use set_command instead.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def command(\n    self, command: Optional[str] = None, /\n) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]:\n    \"\"\"A [decorator](https://docs.python.org/3/glossary.html#term-decorator) to register a command handler.\n\n    Examples:\n        ```py\n        commands = Commands()\n\n\n        @commands.command()\n        async def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n        @commands.command(\"foo_command\")\n        async def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n        ```\n\n    This method internally calls [set_command][pytauri.Commands.set_command],\n    which means the function signature must conform to [ArgumentsType][pytauri.ipc.ArgumentsType].\n\n    Args:\n        command: The name of the command. If not provided, the `__name__` of `callable` will be used.\n\n    Raises:\n        ValueError: If a command with the same name already exists.\n            If it's expected, use [set_command][pytauri.Commands.set_command] instead.\n    \"\"\"\n    if command is None:\n        return self._register\n    else:\n        return partial(self._register, command=command)\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.Commands.command(command)","title":"<code>command</code>","text":""},{"location":"reference/py/pytauri/#pytauri.builder_factory","title":"builder_factory","text":"<pre><code>builder_factory(*args: Any, **kwargs: Any) -&gt; Builder\n</code></pre> <p>A factory function for creating a <code>Builder</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def builder_factory(*args: Any, **kwargs: Any) -&gt; Builder:\n    \"\"\"A factory function for creating a `Builder` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/#pytauri.context_factory","title":"context_factory","text":"<pre><code>context_factory(*args: Any, **kwargs: Any) -&gt; Context\n</code></pre> <p>A factory function for creating a <code>Context</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def context_factory(*args: Any, **kwargs: Any) -&gt; Context:\n    \"\"\"A factory function for creating a `Context` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/image/","title":"image","text":""},{"location":"reference/py/pytauri/image/#pytauri.image","title":"pytauri.image","text":"<p>tauri::image</p> <p>Classes:</p> Name Description <code>Image</code> <p>tauri::image::Image</p>"},{"location":"reference/py/pytauri/image/#pytauri.image.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Image']\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image","title":"Image","text":"<p>               Bases: <code>Image</code></p> <p>tauri::image::Image</p> <p>Methods:</p> Name Description <code>__new__</code> <code>from_pil</code> <p>Creates a new image using the provided <code>PIL</code> image.</p> <code>from_bytes</code> <p>Create an image from bytes.</p> <code>from_path</code> <p>Create an image from a file path.</p> <p>Attributes:</p> Name Type Description <code>rgba</code> <code>bytes</code> <code>width</code> <code>int</code> <code>height</code> <code>int</code>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.rgba","title":"rgba  <code>property</code>","text":"<pre><code>rgba: bytes\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.__new__","title":"__new__","text":"<pre><code>__new__(rgba: bytes, width: int, height: int) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/image.py</code> <pre><code>def __new__(cls, rgba: bytes, width: int, height: int, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.from_pil","title":"from_pil  <code>classmethod</code>","text":"<pre><code>from_pil(image: Image) -&gt; Self\n</code></pre> <p>Creates a new image using the provided <code>PIL</code> image.</p> <p>The original <code>tauri::image::Image::from_bytes</code> only supports <code>.ico</code> and <code>.png</code> formats. But this method supports all formats supported by <code>PIL</code>.</p> <p>Note</p> <p><code>Tauri</code> requires images to be in <code>RGBA</code> mode. If the provided image is not in <code>RGBA</code> mode, it will be converted to <code>RGBA</code> mode as a copy.</p> Source code in <code>python/pytauri/src/pytauri/image.py</code> <pre><code>@classmethod\ndef from_pil(cls, image: PILImage.Image) -&gt; Self:\n    \"\"\"Creates a new image using the provided `PIL` image.\n\n    The original `tauri::image::Image::from_bytes` only supports `.ico` and `.png` formats.\n    But this method supports **all formats supported by `PIL`**.\n\n    !!! note\n        `Tauri` requires images to be in `RGBA` mode.\n        If the provided image is not in `RGBA` mode, it will be converted to `RGBA` mode as a copy.\n    \"\"\"\n    if image.mode != cls._MODE:\n        image = image.convert(cls._MODE)\n    return cls(image.tobytes(), *image.size)\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(bytes_: Union[bytes, bytearray, memoryview]) -&gt; Self\n</code></pre> <p>Create an image from bytes.</p> <p>This method calls pytauri.image.Image.from_pil internally.</p> Source code in <code>python/pytauri/src/pytauri/image.py</code> <pre><code>@classmethod\ndef from_bytes(cls, bytes_: Union[bytes, bytearray, memoryview], /) -&gt; Self:\n    \"\"\"Create an image from bytes.\n\n    This method calls [pytauri.image.Image.from_pil][] internally.\n    \"\"\"\n    return cls.from_pil(PILImage.open(BytesIO(bytes_)))\n</code></pre>"},{"location":"reference/py/pytauri/image/#pytauri.image.Image.from_path","title":"from_path  <code>classmethod</code>","text":"<pre><code>from_path(path: Union[str, bytes, PathLike[str], PathLike[bytes]]) -&gt; Self\n</code></pre> <p>Create an image from a file path.</p> <p>This method calls pytauri.image.Image.from_pil internally.</p> Source code in <code>python/pytauri/src/pytauri/image.py</code> <pre><code>@classmethod\ndef from_path(\n    cls, path: Union[str, bytes, PathLike[str], PathLike[bytes]], /\n) -&gt; Self:\n    \"\"\"Create an image from a file path.\n\n    This method calls [pytauri.image.Image.from_pil][] internally.\n    \"\"\"\n    return cls.from_pil(PILImage.open(path))\n</code></pre>"},{"location":"reference/py/pytauri/ipc/","title":"ipc","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc","title":"pytauri.ipc","text":"<p>tauri::ipc</p> <p>Classes:</p> Name Description <code>ArgumentsType</code> <p>The bound arguments of a command.</p> <code>Invoke</code> <p>tauri::ipc::Invoke</p> <code>InvokeResolver</code> <p>tauri::ipc::InvokeResolver</p> <code>ParametersType</code> <p>The parameters of a command.</p> <code>InvokeException</code> <p>Indicates that an exception occurred in a <code>command</code>. Similar to Rust's <code>Result::Err</code>.</p> <code>Commands</code> <p>This class provides features similar to tauri::generate_handler.</p> <code>JavaScriptChannelId</code> <p>This class is a wrapper around pytauri.ffi.ipc.JavaScriptChannelId.</p> <code>Channel</code> <p>This class is a wrapper around pytauri.ffi.ipc.Channel.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ArgumentsType', 'Channel', 'Commands', 'Invoke', 'InvokeException', 'InvokeResolver', 'JavaScriptChannelId', 'ParametersType']\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ArgumentsType","title":"ArgumentsType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The bound arguments of a command.</p> <p>Each key is optional, depending on the keys of the bound ParametersType.</p> <p>You can use it like <code>**kwargs</code>, for example <code>command(**arguments)</code>.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>bytes</code> <p>The body of ipc message.</p> <code>app_handle</code> <code>AppHandle</code> <p>The handle of the app.</p> <code>webview_window</code> <code>WebviewWindow</code> <p>The <code>WebviewWindow</code> of this <code>Invoke</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ArgumentsType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: bytes\n</code></pre> <p>The body of ipc message.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ArgumentsType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: AppHandle\n</code></pre> <p>The handle of the app.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ArgumentsType.webview_window","title":"webview_window  <code>instance-attribute</code>","text":"<pre><code>webview_window: WebviewWindow\n</code></pre> <p>The <code>WebviewWindow</code> of this <code>Invoke</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke","title":"Invoke","text":"<p>tauri::ipc::Invoke</p> <p>Methods:</p> Name Description <code>bind_to</code> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <code>resolve</code> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>The name of the current command.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke.command","title":"command  <code>property</code>","text":"<pre><code>command: str\n</code></pre> <p>The name of the current command.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke.bind_to","title":"bind_to","text":"<pre><code>bind_to(parameters: ParametersType) -&gt; Optional[InvokeResolver[_ArgumentsTypeVar]]\n</code></pre> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <p>If the frontend illegally calls the IPC, this method will automatically reject this <code>Invoke</code> and return <code>None</code>.</p> <p>The return value InvokeResolver.arguments is not the same object as the input <code>parameters</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def bind_to(\n    self, parameters: ParametersType\n) -&gt; Optional[\"InvokeResolver[_ArgumentsTypeVar]\"]:\n    \"\"\"Consumes this `Invoke` and binds parameters.\n\n    If the frontend illegally calls the IPC,\n    this method will automatically reject this `Invoke` and return `None`.\n\n    The return value [InvokeResolver.arguments][pytauri.ffi.ipc.InvokeResolver.arguments]\n    is not the same object as the input `parameters`.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke.resolve","title":"resolve","text":"<pre><code>resolve(value: bytes) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: bytes) -&gt; None:\n    \"\"\"Consumes this `Invoke` and resolves the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Invoke.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `Invoke` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeResolver","title":"InvokeResolver","text":"<p>               Bases: <code>Generic[_ArgumentsTypeVar]</code></p> <p>tauri::ipc::InvokeResolver</p> <p>Methods:</p> Name Description <code>resolve</code> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>arguments</code> <code>_ArgumentsTypeVar</code> <p>The bound arguments of the current command.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeResolver.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: _ArgumentsTypeVar\n</code></pre> <p>The bound arguments of the current command.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeResolver.resolve","title":"resolve","text":"<pre><code>resolve(value: bytes) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: bytes) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and resolves the command with the given value.\"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeResolver.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ParametersType","title":"ParametersType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The parameters of a command.</p> <p>All keys are optional, and values can be of any type. If a key exists, it will be assigned a value corresponding to ArgumentsType.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p> <code>app_handle</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p> <code>webview_window</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ParametersType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ParametersType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.ParametersType.webview_window","title":"webview_window  <code>instance-attribute</code>","text":"<pre><code>webview_window: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeException","title":"InvokeException","text":"<pre><code>InvokeException(value: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Indicates that an exception occurred in a <code>command</code>. Similar to Rust's <code>Result::Err</code>.</p> <p>When this exception is raised in a <code>command</code>, pytauri will return it to the frontend through <code>Invoke.reject(value)</code> and will not log the exception on the python side.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>The error message that will be returned to the frontend.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self, value: str) -&gt; None:  # noqa: D107\n    self.value = value\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.InvokeException.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: str = value\n</code></pre> <p>The error message that will be returned to the frontend.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands","title":"Commands","text":"<pre><code>Commands()\n</code></pre> <p>               Bases: <code>UserDict[str, _PyInvokHandleData]</code></p> <p>This class provides features similar to tauri::generate_handler.</p> <p>Typically, you would use Commands.command to register a command handler function. Then, use Commands.generate_handler to get an <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Methods:</p> Name Description <code>generate_handler</code> <p>This method is similar to tauri::generate_handler.</p> <code>wrap_pyfunc</code> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <code>parse_parameters</code> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <code>set_command</code> <p>Set a command handler.</p> <code>command</code> <p>A decorator to register a command handler.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self) -&gt; None:  # noqa: D107\n    super().__init__()\n\n    data = self.data\n\n    async def _async_invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - the implementer of this function must not raise exceptions\n        # - and must ensure to fulfill `invoke/resolver`\n        resolver = None\n        try:\n            command = invoke.command\n            handler_data = data.get(command)\n            if handler_data is None:\n                invoke.reject(f\"no python handler `{command}` found\")\n                return\n\n            parameters = handler_data.parameters\n            handler = handler_data.handler\n\n            resolver = invoke.bind_to(parameters)\n            if resolver is None:\n                # `invoke` has already been rejected\n                return\n\n            try:\n                resp = await handler(**resolver.arguments)\n                # TODO, PERF: idk if this will block?\n            except InvokeException as e:\n                resolver.reject(e.value)\n            except Exception as e:\n                # # TODO: Should we return the traceback to the frontend?\n                # # It might leak information.\n                # from traceback import format_exc\n                # resolver.reject(format_exc())\n                _logger.exception(\n                    f\"invoke_handler {handler}: `{handler.__name__}` raised an exception\",\n                    exc_info=e,\n                )\n                resolver.reject(repr(e))\n            else:\n                resolver.resolve(resp)\n\n        except Exception as e:\n            msg = f\"{_async_invoke_handler} implementation raised an exception, please report this as a pytauri bug\"\n\n            _logger.critical(msg, exc_info=e)\n            if resolver is not None:\n                resolver.reject(msg)\n            else:\n                invoke.reject(msg)\n            raise\n\n    self._async_invoke_handler = _async_invoke_handler\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.generate_handler","title":"generate_handler","text":"<pre><code>generate_handler(portal: BlockingPortal) -&gt; _InvokeHandlerProto\n</code></pre> <p>This method is similar to tauri::generate_handler.</p> <p>You can use this method to get <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Examples:</p> <pre><code>from anyio.from_thread import start_blocking_portal\n\ncommands = Commands()\n\nwith start_blocking_portal(backend) as portal:\n    invoke_handler = commands.generate_handler(portal)\n    ...\n</code></pre> <p>Warning</p> <p>The <code>portal</code> must remain valid while the returned <code>invoke_handler</code> is being used.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def generate_handler(self, portal: BlockingPortal, /) -&gt; _InvokeHandlerProto:\n    \"\"\"This method is similar to [tauri::generate_handler](https://docs.rs/tauri/latest/tauri/macro.generate_handler.html).\n\n    You can use this method to get `invoke_handler` for use with [BuilderArgs][pytauri.BuilderArgs].\n\n    Examples:\n        ```py\n        from anyio.from_thread import start_blocking_portal\n\n        commands = Commands()\n\n        with start_blocking_portal(backend) as portal:\n            invoke_handler = commands.generate_handler(portal)\n            ...\n        ```\n\n    !!! warning\n        The `portal` must remain valid while the returned `invoke_handler` is being used.\n    \"\"\"\n    async_invoke_handler = self._async_invoke_handler\n\n    def invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - `invoke_handler` must not raise exception\n        # - must not block\n\n        # this func will be call in extern thread, so it's ok to use `start_task_soon`\n        portal.start_task_soon(async_invoke_handler, invoke)\n\n    return invoke_handler\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.wrap_pyfunc","title":"wrap_pyfunc  <code>staticmethod</code>","text":"<pre><code>wrap_pyfunc(pyfunc: _WrappablePyHandlerType) -&gt; _PyHandlerType\n</code></pre> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <p>Specifically:</p> <ul> <li>If <code>pyfunc</code> has a <code>KEYWORD_ONLY</code> parameter named <code>body</code>, will check if <code>issubclass(body, BaseModel)</code> is true,   and if so, wrap it as a new function with <code>body: bytes</code> parameter.</li> <li>If <code>pyfunc</code> conforms to <code>issubclass(return_annotation, BaseModel)</code>,   wrap it as a new function with <code>return_annotation: bytes</code> return type.</li> <li>If not, will return the original <code>pyfunc</code>.</li> </ul> <p>The <code>pyfunc</code> will be decorated using functools.wraps, and its <code>__signature__</code> will also be updated.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@staticmethod\ndef wrap_pyfunc(  # noqa: C901  # TODO: simplify the method\n    pyfunc: _WrappablePyHandlerType,\n) -&gt; _PyHandlerType:\n    \"\"\"Wrap a `Callable` to conform to the definition of PyHandlerType.\n\n    Specifically:\n\n    - If `pyfunc` has a `KEYWORD_ONLY` parameter named `body`, will check if `issubclass(body, BaseModel)` is true,\n      and if so, wrap it as a new function with `body: bytes` parameter.\n    - If `pyfunc` conforms to `issubclass(return_annotation, BaseModel)`,\n      wrap it as a new function with `return_annotation: bytes` return type.\n    - If not, will return the original `pyfunc`.\n\n    The `pyfunc` will be decorated using [functools.wraps][], and its `__signature__` will also be updated.\n    \"\"\"\n    serializer = None\n    deserializer = None\n\n    body_key = \"body\"\n\n    sig = signature(pyfunc)\n    parameters = sig.parameters\n    return_annotation = sig.return_annotation\n\n    body_param = parameters.get(body_key)\n    if body_param is not None:\n        if body_param.kind not in {\n            body_param.KEYWORD_ONLY,\n            body_param.POSITIONAL_OR_KEYWORD,\n        }:\n            raise ValueError(f\"Expected `{body_key}` to be KEYWORD_ONLY\")\n        body_type = body_param.annotation\n        if issubclass(body_type, BaseModel):\n            serializer = body_type.model_validate_json\n        else:\n            if not issubclass(body_type, bytes):\n                raise ValueError(\n                    f\"Expected `{body_key}` to be subclass of {BaseModel} or {bytes}, \"\n                    f\"got {body_type}\"\n                )\n\n    if issubclass(return_annotation, BaseModel):\n        deserializer = return_annotation.__pydantic_serializer__.to_json\n    else:\n        if not issubclass(return_annotation, bytes):\n            raise ValueError(\n                f\"Expected `return_annotation` to be subclass of {BaseModel} or {bytes}, \"\n                f\"got {return_annotation}\"\n            )\n\n    if not serializer and not deserializer:\n        return cast(_PyHandlerType, pyfunc)  # `cast` make typing happy\n\n    @wraps(pyfunc)\n    async def wrapper(*args: Any, **kwargs: Any) -&gt; bytes:\n        nonlocal serializer, deserializer\n\n        if serializer is not None:\n            body_bytes = kwargs[body_key]\n            assert isinstance(body_bytes, bytes)  # PERF\n            try:\n                body_model = serializer(body_bytes)\n            except ValidationError as e:\n                raise InvokeException(repr(e)) from e\n            kwargs[body_key] = body_model\n\n        resp = await pyfunc(*args, **kwargs)\n\n        if deserializer is not None:\n            assert isinstance(resp, BaseModel)  # PERF\n            return deserializer(resp)\n        else:\n            assert isinstance(resp, bytes)  # PERF\n            return resp\n\n    new_parameters = None\n    if serializer is not None:\n        new_parameters = parameters.copy()\n        new_parameters[body_key] = parameters[body_key].replace(annotation=bytes)\n\n    # see: &lt;https://docs.python.org/3.13/library/inspect.html#inspect.signature&gt;\n    wrapper.__signature__ = (  # pyright: ignore[reportAttributeAccessIssue]\n        sig.replace(\n            parameters=list(new_parameters.values()),\n            return_annotation=bytes,\n        )\n        if new_parameters\n        else sig.replace(return_annotation=bytes)\n    )\n    return wrapper\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.parse_parameters","title":"parse_parameters  <code>staticmethod</code>","text":"<pre><code>parse_parameters(pyfunc: _PyHandlerType, /, check_signature: bool = True) -&gt; ParametersType\n</code></pre> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <p>Check if the Signature of <code>pyfunc</code> conforms to ArgumentsType, and if the return value is a subclass of bytes.</p> <p>Parameters:</p> Name Type Description Default <code>_PyHandlerType</code> <p>The <code>Callable</code> to check.</p> required <code>bool</code> <p>Whether to check the signature of <code>pyfunc</code>. Set it to <code>False</code> only if you are sure that the signature conforms to the expected pattern.</p> <code>True</code> <p>Returns:</p> Type Description <code>ParametersType</code> <p>The parameters of the <code>pyfunc</code>. You can use it with Invoke.bind_to.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature does not conform to the expected pattern.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@staticmethod\ndef parse_parameters(\n    pyfunc: _PyHandlerType, /, check_signature: bool = True\n) -&gt; ParametersType:\n    \"\"\"Check the signature of a `Callable` and return the parameters.\n\n    Check if the [Signature][inspect.Signature] of `pyfunc` conforms to [ArgumentsType][pytauri.ipc.ArgumentsType],\n    and if the return value is a subclass of [bytes][].\n\n    Args:\n        pyfunc: The `Callable` to check.\n        check_signature: Whether to check the signature of `pyfunc`.\n            Set it to `False` only if you are sure that the signature conforms to the expected pattern.\n\n    Returns:\n        The parameters of the `pyfunc`. You can use it with [Invoke.bind_to][pytauri.ipc.Invoke.bind_to].\n\n    Raises:\n        ValueError: If the signature does not conform to the expected pattern.\n    \"\"\"\n    sig = signature(pyfunc)\n    # NOTE: it seems that `parameters.keys()` is already `sys._is_interned` in cpython\n    parameters = sig.parameters\n    if not check_signature:\n        # `cast` make typing happy\n        return cast(ParametersType, parameters)\n\n    return_annotation = sig.return_annotation\n\n    arguments_type = {\n        \"body\": bytes,\n        \"app_handle\": AppHandle,\n        \"webview_window\": WebviewWindow,\n    }\n\n    for name, param in parameters.items():\n        # check if the `parameters` type hint conforms to [pytauri.ipc.ArgumentsType][]\n\n        correct_anna = arguments_type.get(name)\n        if correct_anna is None:\n            raise ValueError(\n                f\"Unexpected parameter `{name}`, expected one of {list(arguments_type.keys())}\"\n            )\n        if not issubclass(param.annotation, correct_anna):\n            raise ValueError(\n                f\"Expected `{name}` to be subclass of `{correct_anna}`, got `{param.annotation}`\"\n            )\n    else:\n        # after checking, we are sure that the `parameters` are valid\n        parameters = cast(ParametersType, parameters)\n\n    if not issubclass(return_annotation, bytes):\n        raise ValueError(\n            f\"Expected return_annotation to be subclass of {bytes}, got `{return_annotation}`\"\n        )\n\n    return parameters\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.parse_parameters(pyfunc)","title":"<code>pyfunc</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.parse_parameters(check_signature)","title":"<code>check_signature</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.set_command","title":"set_command","text":"<pre><code>set_command(command: str, handler: _WrappablePyHandlerType, /, check_signature: bool = True) -&gt; None\n</code></pre> <p>Set a command handler.</p> <p>This method internally calls parse_parameters and wrap_pyfunc, <code>parse_parameters(wrap_pyfunc(handler))</code>.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def set_command(\n    self,\n    command: str,\n    handler: _WrappablePyHandlerType,\n    /,\n    check_signature: bool = True,\n) -&gt; None:\n    \"\"\"Set a command handler.\n\n    This method internally calls [parse_parameters][pytauri.Commands.parse_parameters]\n    and [wrap_pyfunc][pytauri.Commands.wrap_pyfunc], `parse_parameters(wrap_pyfunc(handler))`.\n    \"\"\"\n    new_handler = self.wrap_pyfunc(handler)\n    parameters = self.parse_parameters(new_handler, check_signature=check_signature)\n    self.data[command] = _PyInvokHandleData(parameters, new_handler)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.command","title":"command","text":"<pre><code>command(command: Optional[str] = None) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]\n</code></pre> <p>A decorator to register a command handler.</p> <p>Examples:</p> <pre><code>commands = Commands()\n\n\n@commands.command()\nasync def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n@commands.command(\"foo_command\")\nasync def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n</code></pre> <p>This method internally calls set_command, which means the function signature must conform to ArgumentsType.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[str]</code> <p>The name of the command. If not provided, the <code>__name__</code> of <code>callable</code> will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a command with the same name already exists. If it's expected, use set_command instead.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def command(\n    self, command: Optional[str] = None, /\n) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]:\n    \"\"\"A [decorator](https://docs.python.org/3/glossary.html#term-decorator) to register a command handler.\n\n    Examples:\n        ```py\n        commands = Commands()\n\n\n        @commands.command()\n        async def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n        @commands.command(\"foo_command\")\n        async def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n        ```\n\n    This method internally calls [set_command][pytauri.Commands.set_command],\n    which means the function signature must conform to [ArgumentsType][pytauri.ipc.ArgumentsType].\n\n    Args:\n        command: The name of the command. If not provided, the `__name__` of `callable` will be used.\n\n    Raises:\n        ValueError: If a command with the same name already exists.\n            If it's expected, use [set_command][pytauri.Commands.set_command] instead.\n    \"\"\"\n    if command is None:\n        return self._register\n    else:\n        return partial(self._register, command=command)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Commands.command(command)","title":"<code>command</code>","text":""},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.JavaScriptChannelId","title":"JavaScriptChannelId","text":"<p>               Bases: <code>RootModel[_FFIJavaScriptChannelIdAnno]</code>, <code>Generic[_ModelTypeVar]</code></p> <p>This class is a wrapper around pytauri.ffi.ipc.JavaScriptChannelId.</p> <p>You can use this class as model field in pydantic model directly, or use it as model directly.</p> <p>pytauri.ffi.ipc.JavaScriptChannelId can't be used directly in pydantic model.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.JavaScriptChannelId--examples","title":"Examples","text":"<pre><code>from asyncio import Task, create_task, sleep\nfrom typing import Any\n\nfrom pydantic import BaseModel, RootModel\nfrom pydantic.networks import HttpUrl\nfrom pytauri import Commands\nfrom pytauri.ipc import JavaScriptChannelId, WebviewWindow\n\ncommands = Commands()\n\nProgress = RootModel[int]\n\n\nclass Download(BaseModel):\n    url: HttpUrl\n    channel: JavaScriptChannelId[Progress]\n\n\nbackground_tasks: set[Task[Any]] = set()\n\n\n@commands.command()\nasync def download(body: Download, webview_window: WebviewWindow) -&gt; bytes:\n    channel = body.channel.channel_on(webview_window.as_ref_webview())\n\n    async def task():\n        progress = Progress(0)\n        while progress.root &lt;= 100:\n            channel.send_model(progress)\n            await sleep(0.1)\n            progress.root += 1\n\n    t = create_task(task())\n    background_tasks.add(t)\n    t.add_done_callback(background_tasks.discard)\n\n    return b\"null\"\n\n\n# Or you can use it as `body` model directly\n@commands.command()\nasync def my_command(body: JavaScriptChannelId) -&gt; bytes: ...\n</code></pre> <p>Methods:</p> Name Description <code>from_str</code> <p>See pytauri.ffi.ipc.JavaScriptChannelId.from_str.</p> <code>channel_on</code> <p>See pytauri.ffi.ipc.JavaScriptChannelId.channel_on.</p>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.JavaScriptChannelId.from_str","title":"from_str  <code>classmethod</code>","text":"<pre><code>from_str(value: str) -&gt; Self\n</code></pre> <p>See pytauri.ffi.ipc.JavaScriptChannelId.from_str.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@classmethod\ndef from_str(cls, value: str, /) -&gt; Self:\n    \"\"\"See [pytauri.ffi.ipc.JavaScriptChannelId.from_str][].\"\"\"\n    ffi_js_channel_id = _FFIJavaScriptChannelId.from_str(value)\n    return cls(ffi_js_channel_id)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.JavaScriptChannelId.channel_on","title":"channel_on","text":"<pre><code>channel_on(webview: Webview) -&gt; Channel[_ModelTypeVar]\n</code></pre> <p>See pytauri.ffi.ipc.JavaScriptChannelId.channel_on.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def channel_on(self, webview: Webview, /) -&gt; \"Channel[_ModelTypeVar]\":\n    \"\"\"See [pytauri.ffi.ipc.JavaScriptChannelId.channel_on][].\"\"\"\n    ffi_channel = self.root.channel_on(webview)\n    return Channel(ffi_channel)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Channel","title":"Channel","text":"<pre><code>Channel(ffi_channel: Channel)\n</code></pre> <p>               Bases: <code>Generic[_ModelTypeVar]</code></p> <p>This class is a wrapper around pytauri.ffi.ipc.Channel.</p> <p>It adds the following methods:</p> <ul> <li>send_model</li> </ul>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Channel--examples","title":"Examples","text":"<p>See JavaScriptChannelId</p> <p>Methods:</p> Name Description <code>id</code> <p>See pytauri.ffi.ipc.Channel.id.</p> <code>send</code> <p>See pytauri.ffi.ipc.Channel.send.</p> <code>send_model</code> <p>Equivalent to <code>self.send(model.__pydantic_serializer__.to_json(model))</code>.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self, ffi_channel: _FFIChannel, /):  # noqa: D107\n    self._ffi_channel = ffi_channel\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Channel.id","title":"id","text":"<pre><code>id() -&gt; int\n</code></pre> <p>See pytauri.ffi.ipc.Channel.id.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def id(self, /) -&gt; int:\n    \"\"\"See [pytauri.ffi.ipc.Channel.id][].\"\"\"\n    return self._ffi_channel.id()\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Channel.send","title":"send","text":"<pre><code>send(data: bytes) -&gt; None\n</code></pre> <p>See pytauri.ffi.ipc.Channel.send.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def send(self, data: bytes, /) -&gt; None:\n    \"\"\"See [pytauri.ffi.ipc.Channel.send][].\"\"\"\n    self._ffi_channel.send(data)\n</code></pre>"},{"location":"reference/py/pytauri/ipc/#pytauri.ipc.Channel.send_model","title":"send_model","text":"<pre><code>send_model(model: _ModelTypeVar) -&gt; None\n</code></pre> <p>Equivalent to <code>self.send(model.__pydantic_serializer__.to_json(model))</code>.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def send_model(self, model: _ModelTypeVar, /) -&gt; None:\n    \"\"\"Equivalent to `self.send(model.__pydantic_serializer__.to_json(model))`.\"\"\"\n    self.send(model.__pydantic_serializer__.to_json(model))\n</code></pre>"},{"location":"reference/py/pytauri/menu/","title":"menu","text":""},{"location":"reference/py/pytauri/menu/#pytauri.menu","title":"pytauri.menu","text":"<p>tauri::menu</p> <p>Classes:</p> Name Description <code>AboutMetadata</code> <p>tauri::menu::AboutMetadata</p> <code>CheckMenuItem</code> <p>tauri::menu::CheckMenuItem</p> <code>ContextMenu</code> <p>tauri::menu::ContextMenu</p> <code>IconMenuItem</code> <p>tauri::menu::IconMenuItem</p> <code>Menu</code> <p>tauri::menu::Menu</p> <code>MenuItem</code> <p>tauri::menu::MenuItem</p> <code>NativeIcon</code> <p>tauri::menu::NativeIcon</p> <code>PredefinedMenuItem</code> <p>tauri::menu::PredefinedMenuItem</p> <code>Submenu</code> <p>tauri::menu::Submenu</p> <p>Attributes:</p> Name Type Description <code>HELP_SUBMENU_ID</code> <code>LiteralString</code> <p>tauri::menu::HELP_SUBMENU_ID</p> <code>WINDOW_SUBMENU_ID</code> <code>LiteralString</code> <p>tauri::menu::WINDOW_SUBMENU_ID</p> <code>ImplContextMenu</code> <code>MenuEvent</code> <p>tauri::menu::MenuEvent</p> <code>MenuID</code> <p>tauri::menu::MenuID</p> <code>MenuItemKind</code> <p>tauri::menu::MenuItemKind</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.HELP_SUBMENU_ID","title":"HELP_SUBMENU_ID  <code>module-attribute</code>","text":"<pre><code>HELP_SUBMENU_ID: LiteralString\n</code></pre> <p>tauri::menu::HELP_SUBMENU_ID</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.WINDOW_SUBMENU_ID","title":"WINDOW_SUBMENU_ID  <code>module-attribute</code>","text":"<pre><code>WINDOW_SUBMENU_ID: LiteralString\n</code></pre> <p>tauri::menu::WINDOW_SUBMENU_ID</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.ImplContextMenu","title":"ImplContextMenu  <code>module-attribute</code>","text":"<pre><code>ImplContextMenu = TypeAliasType('ImplContextMenu', Union[Menu, Submenu])\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuEvent","title":"MenuEvent  <code>module-attribute</code>","text":"<pre><code>MenuEvent = TypeAliasType('MenuEvent', MenuID)\n</code></pre> <p>tauri::menu::MenuEvent</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuID","title":"MenuID  <code>module-attribute</code>","text":"<pre><code>MenuID = TypeAliasType('MenuID', str)\n</code></pre> <p>tauri::menu::MenuID</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItemKind","title":"MenuItemKind  <code>module-attribute</code>","text":"<pre><code>MenuItemKind = TypeAliasType('MenuItemKind', Union[MenuItem, Submenu, PredefinedMenuItem, CheckMenuItem, IconMenuItem])\n</code></pre> <p>tauri::menu::MenuItemKind</p>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['HELP_SUBMENU_ID', 'WINDOW_SUBMENU_ID', 'AboutMetadata', 'CheckMenuItem', 'ContextMenu', 'IconMenuItem', 'ImplContextMenu', 'Menu', 'MenuEvent', 'MenuID', 'MenuItem', 'MenuItemKind', 'NativeIcon', 'PredefinedMenuItem', 'Submenu']\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.AboutMetadata","title":"AboutMetadata","text":"<p>tauri::menu::AboutMetadata</p> <p>Methods:</p> Name Description <code>__new__</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.AboutMetadata.__new__","title":"__new__","text":"<pre><code>__new__(*, name: Optional[str] = None, version: Optional[str] = None, short_version: Optional[str] = None, authors: Optional[Sequence[str]] = None, comments: Optional[str] = None, copyright: Optional[str] = None, license: Optional[str] = None, website: Optional[str] = None, website_label: Optional[str] = None, credits: Optional[str] = None, icon: Optional[Image] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    name: Optional[str] = None,\n    version: Optional[str] = None,\n    short_version: Optional[str] = None,\n    authors: Optional[Sequence[str]] = None,\n    comments: Optional[str] = None,\n    copyright: Optional[str] = None,  # noqa: A002\n    license: Optional[str] = None,  # noqa: A002\n    website: Optional[str] = None,\n    website_label: Optional[str] = None,\n    credits: Optional[str] = None,  # noqa: A002\n    icon: Optional[\"Image\"] = None,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem","title":"CheckMenuItem","text":"<p>tauri::menu::CheckMenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code> <code>is_checked</code> <code>set_checked</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, checked: bool, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    checked: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, checked: bool, accelerator: Optional[str] = None) -&gt; CheckMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    checked: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"CheckMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.is_checked","title":"is_checked","text":"<pre><code>is_checked() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_checked(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.CheckMenuItem.set_checked","title":"set_checked","text":"<pre><code>set_checked(checked: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_checked(self, checked: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.ContextMenu","title":"ContextMenu","text":"<p>tauri::menu::ContextMenu</p> <p>Methods:</p> Name Description <code>popup</code> <code>popup_at</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.ContextMenu.popup","title":"popup  <code>staticmethod</code>","text":"<pre><code>popup(slf: ImplContextMenu, window: Window) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef popup(slf: \"ImplContextMenu\", window: Window, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.ContextMenu.popup_at","title":"popup_at  <code>staticmethod</code>","text":"<pre><code>popup_at(slf: ImplContextMenu, window: Window, position: PositionType) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef popup_at(\n    slf: \"ImplContextMenu\", window: Window, position: PositionType, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem","title":"IconMenuItem","text":"<p>tauri::menu::IconMenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_native_icon</code> <code>with_id_and_native_icon</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code> <code>set_icon</code> <code>set_native_icon</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, icon: Optional[Image] = None, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    icon: Optional[\"Image\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, icon: Optional[Image] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    icon: Optional[\"Image\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.with_native_icon","title":"with_native_icon  <code>staticmethod</code>","text":"<pre><code>with_native_icon(manager: ImplManager, text: str, enabled: bool, native_icon: Optional[NativeIcon] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_native_icon(\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    native_icon: Optional[\"NativeIcon\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.with_id_and_native_icon","title":"with_id_and_native_icon  <code>staticmethod</code>","text":"<pre><code>with_id_and_native_icon(manager: ImplManager, id: MenuID, text: str, enabled: bool, native_icon: Optional[NativeIcon] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_native_icon(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    native_icon: Optional[\"NativeIcon\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Optional[Image]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_icon(self, icon: Optional[\"Image\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.IconMenuItem.set_native_icon","title":"set_native_icon","text":"<pre><code>set_native_icon(native_icon: Optional[NativeIcon]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_native_icon(self, native_icon: Optional[\"NativeIcon\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu","title":"Menu","text":"<p>tauri::menu::Menu</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_items</code> <code>with_id_and_items</code> <code>default</code> <code>app_handle</code> <code>id</code> <code>append</code> <code>append_items</code> <code>prepend</code> <code>prepend_items</code> <code>insert</code> <code>insert_items</code> <code>remove</code> <code>remove_at</code> <code>get</code> <code>items</code> <code>set_as_app_menu</code> <code>set_as_window_menu</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(cls, manager: ImplManager, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(manager: ImplManager, id: MenuID, /) -&gt; \"Menu\": ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.with_items","title":"with_items  <code>staticmethod</code>","text":"<pre><code>with_items(manager: ImplManager, items: Sequence[MenuItemKind]) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_items(\n    manager: ImplManager, items: Sequence[\"MenuItemKind\"], /\n) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.with_id_and_items","title":"with_id_and_items  <code>staticmethod</code>","text":"<pre><code>with_id_and_items(manager: ImplManager, id: MenuID, items: Sequence[MenuItemKind]) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_items(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.default","title":"default  <code>staticmethod</code>","text":"<pre><code>default(app_handle: AppHandle) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef default(app_handle: AppHandle, /) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.append","title":"append","text":"<pre><code>append(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.append_items","title":"append_items","text":"<pre><code>append_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.prepend","title":"prepend","text":"<pre><code>prepend(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.prepend_items","title":"prepend_items","text":"<pre><code>prepend_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.insert","title":"insert","text":"<pre><code>insert(item: MenuItemKind, position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert(self, item: \"MenuItemKind\", position: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.insert_items","title":"insert_items","text":"<pre><code>insert_items(items: Sequence[MenuItemKind], position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert_items(\n    self, items: Sequence[\"MenuItemKind\"], position: int, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.remove","title":"remove","text":"<pre><code>remove(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.remove_at","title":"remove_at","text":"<pre><code>remove_at(position: int) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove_at(self, position: int, /) -&gt; Optional[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.get","title":"get","text":"<pre><code>get(id: MenuID) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def get(self, id: MenuID, /) -&gt; Optional[\"MenuItemKind\"]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.items","title":"items","text":"<pre><code>items() -&gt; list[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def items(self, /) -&gt; list[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.set_as_app_menu","title":"set_as_app_menu","text":"<pre><code>set_as_app_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_as_app_menu(self, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Menu.set_as_window_menu","title":"set_as_window_menu","text":"<pre><code>set_as_window_menu(window: Window) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_as_window_menu(self, window: Window, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem","title":"MenuItem","text":"<p>tauri::menu::MenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, accelerator: Optional[str] = None) -&gt; MenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"MenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.MenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon","title":"NativeIcon","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::menu::NativeIcon</p> <p>Warning</p> <p>This is actually a <code>Class</code> disguised as an <code>Enum</code>. The order of fields is not guaranteed. See also: https://pyo3.rs/v0.23.4/class.html#pyclass-enums.</p> <p>Attributes:</p> Name Type Description <code>Add</code> <code>Advanced</code> <code>Bluetooth</code> <code>Bookmarks</code> <code>Caution</code> <code>ColorPanel</code> <code>ColumnView</code> <code>Computer</code> <code>EnterFullScreen</code> <code>Everyone</code> <code>ExitFullScreen</code> <code>FlowView</code> <code>Folder</code> <code>FolderBurnable</code> <code>FolderSmart</code> <code>FollowLinkFreestanding</code> <code>FontPanel</code> <code>GoLeft</code> <code>GoRight</code> <code>Home</code> <code>IChatTheater</code> <code>IconView</code> <code>Info</code> <code>InvalidDataFreestanding</code> <code>LeftFacingTriangle</code> <code>ListView</code> <code>LockLocked</code> <code>LockUnlocked</code> <code>MenuMixedState</code> <code>MenuOnState</code> <code>MobileMe</code> <code>MultipleDocuments</code> <code>Network</code> <code>Path</code> <code>PreferencesGeneral</code> <code>QuickLook</code> <code>RefreshFreestanding</code> <code>Refresh</code> <code>Remove</code> <code>RevealFreestanding</code> <code>RightFacingTriangle</code> <code>Share</code> <code>Slideshow</code> <code>SmartBadge</code> <code>StatusAvailable</code> <code>StatusNone</code> <code>StatusPartiallyAvailable</code> <code>StatusUnavailable</code> <code>StopProgressFreestanding</code> <code>StopProgress</code> <code>TrashEmpty</code> <code>TrashFull</code> <code>User</code> <code>UserAccounts</code> <code>UserGroup</code> <code>UserGuest</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Add","title":"Add  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Add = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Advanced","title":"Advanced  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Advanced = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Bluetooth","title":"Bluetooth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Bluetooth = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Bookmarks","title":"Bookmarks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Bookmarks = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Caution","title":"Caution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Caution = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.ColorPanel","title":"ColorPanel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ColorPanel = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.ColumnView","title":"ColumnView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ColumnView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Computer","title":"Computer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Computer = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.EnterFullScreen","title":"EnterFullScreen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EnterFullScreen = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Everyone","title":"Everyone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Everyone = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.ExitFullScreen","title":"ExitFullScreen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ExitFullScreen = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.FlowView","title":"FlowView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FlowView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Folder","title":"Folder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Folder = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.FolderBurnable","title":"FolderBurnable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FolderBurnable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.FolderSmart","title":"FolderSmart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FolderSmart = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.FollowLinkFreestanding","title":"FollowLinkFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FollowLinkFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.FontPanel","title":"FontPanel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FontPanel = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.GoLeft","title":"GoLeft  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GoLeft = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.GoRight","title":"GoRight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GoRight = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Home","title":"Home  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Home = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.IChatTheater","title":"IChatTheater  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IChatTheater = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.IconView","title":"IconView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IconView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Info","title":"Info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Info = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.InvalidDataFreestanding","title":"InvalidDataFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>InvalidDataFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.LeftFacingTriangle","title":"LeftFacingTriangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LeftFacingTriangle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.ListView","title":"ListView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ListView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.LockLocked","title":"LockLocked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LockLocked = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.LockUnlocked","title":"LockUnlocked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LockUnlocked = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.MenuMixedState","title":"MenuMixedState  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MenuMixedState = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.MenuOnState","title":"MenuOnState  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MenuOnState = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.MobileMe","title":"MobileMe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MobileMe = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.MultipleDocuments","title":"MultipleDocuments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MultipleDocuments = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Network","title":"Network  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Network = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Path","title":"Path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Path = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.PreferencesGeneral","title":"PreferencesGeneral  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PreferencesGeneral = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.QuickLook","title":"QuickLook  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QuickLook = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.RefreshFreestanding","title":"RefreshFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RefreshFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Refresh","title":"Refresh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Refresh = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Remove","title":"Remove  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Remove = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.RevealFreestanding","title":"RevealFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RevealFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.RightFacingTriangle","title":"RightFacingTriangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RightFacingTriangle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Share","title":"Share  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Share = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.Slideshow","title":"Slideshow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Slideshow = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.SmartBadge","title":"SmartBadge  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SmartBadge = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StatusAvailable","title":"StatusAvailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusAvailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StatusNone","title":"StatusNone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusNone = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StatusPartiallyAvailable","title":"StatusPartiallyAvailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusPartiallyAvailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StatusUnavailable","title":"StatusUnavailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusUnavailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StopProgressFreestanding","title":"StopProgressFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StopProgressFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.StopProgress","title":"StopProgress  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StopProgress = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.TrashEmpty","title":"TrashEmpty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TrashEmpty = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.TrashFull","title":"TrashFull  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TrashFull = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.User","title":"User  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>User = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.UserAccounts","title":"UserAccounts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserAccounts = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.UserGroup","title":"UserGroup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserGroup = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.NativeIcon.UserGuest","title":"UserGuest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserGuest = auto()\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem","title":"PredefinedMenuItem","text":"<p>tauri::menu::PredefinedMenuItem</p> <p>Methods:</p> Name Description <code>separator</code> <code>copy</code> <code>cut</code> <code>paste</code> <code>select_all</code> <code>undo</code> <code>redo</code> <code>minimize</code> <code>maximize</code> <code>fullscreen</code> <code>hide</code> <code>hide_others</code> <code>show_all</code> <code>close_window</code> <code>quit</code> <code>about</code> <code>services</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.separator","title":"separator  <code>staticmethod</code>","text":"<pre><code>separator(manager: ImplManager) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef separator(manager: ImplManager, /) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.copy","title":"copy  <code>staticmethod</code>","text":"<pre><code>copy(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef copy(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.cut","title":"cut  <code>staticmethod</code>","text":"<pre><code>cut(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef cut(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.paste","title":"paste  <code>staticmethod</code>","text":"<pre><code>paste(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef paste(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.select_all","title":"select_all  <code>staticmethod</code>","text":"<pre><code>select_all(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef select_all(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.undo","title":"undo  <code>staticmethod</code>","text":"<pre><code>undo(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef undo(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.redo","title":"redo  <code>staticmethod</code>","text":"<pre><code>redo(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef redo(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.minimize","title":"minimize  <code>staticmethod</code>","text":"<pre><code>minimize(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef minimize(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.maximize","title":"maximize  <code>staticmethod</code>","text":"<pre><code>maximize(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef maximize(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.fullscreen","title":"fullscreen  <code>staticmethod</code>","text":"<pre><code>fullscreen(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef fullscreen(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.hide","title":"hide  <code>staticmethod</code>","text":"<pre><code>hide(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef hide(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.hide_others","title":"hide_others  <code>staticmethod</code>","text":"<pre><code>hide_others(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef hide_others(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.show_all","title":"show_all  <code>staticmethod</code>","text":"<pre><code>show_all(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef show_all(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.close_window","title":"close_window  <code>staticmethod</code>","text":"<pre><code>close_window(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef close_window(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.quit","title":"quit  <code>staticmethod</code>","text":"<pre><code>quit(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef quit(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.about","title":"about  <code>staticmethod</code>","text":"<pre><code>about(manager: ImplManager, text: Optional[str] = None, metadata: Optional[AboutMetadata] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef about(\n    manager: ImplManager,\n    text: Optional[str] = None,\n    metadata: Optional[\"AboutMetadata\"] = None,\n    /,\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.services","title":"services  <code>staticmethod</code>","text":"<pre><code>services(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef services(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.PredefinedMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu","title":"Submenu","text":"<p>tauri::menu::Submenu</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_items</code> <code>with_id_and_items</code> <code>app_handle</code> <code>id</code> <code>append</code> <code>append_items</code> <code>prepend</code> <code>prepend_items</code> <code>insert</code> <code>insert_items</code> <code>remove</code> <code>remove_at</code> <code>get</code> <code>items</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(cls, manager: ImplManager, text: str, enabled: bool, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.with_items","title":"with_items  <code>staticmethod</code>","text":"<pre><code>with_items(manager: ImplManager, text: str, enabled: bool, items: Sequence[MenuItemKind]) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_items(\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.with_id_and_items","title":"with_id_and_items  <code>staticmethod</code>","text":"<pre><code>with_id_and_items(manager: ImplManager, id: MenuID, text: str, enabled: bool, items: Sequence[MenuItemKind]) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_items(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.append","title":"append","text":"<pre><code>append(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.append_items","title":"append_items","text":"<pre><code>append_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.prepend","title":"prepend","text":"<pre><code>prepend(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.prepend_items","title":"prepend_items","text":"<pre><code>prepend_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.insert","title":"insert","text":"<pre><code>insert(item: MenuItemKind, position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert(self, item: \"MenuItemKind\", position: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.insert_items","title":"insert_items","text":"<pre><code>insert_items(items: Sequence[MenuItemKind], position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert_items(\n    self, items: Sequence[\"MenuItemKind\"], position: int, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.remove","title":"remove","text":"<pre><code>remove(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.remove_at","title":"remove_at","text":"<pre><code>remove_at(position: int) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove_at(self, position: int, /) -&gt; Optional[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.get","title":"get","text":"<pre><code>get(id: MenuID) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def get(self, id: MenuID, /) -&gt; Optional[\"MenuItemKind\"]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.items","title":"items","text":"<pre><code>items() -&gt; list[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def items(self, /) -&gt; list[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/menu/#pytauri.menu.Submenu.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/","title":"tray","text":""},{"location":"reference/py/pytauri/tray/#pytauri.tray","title":"pytauri.tray","text":"<p>tauri::tray</p> <p>Classes:</p> Name Description <code>MouseButton</code> <p>tauri::tray::MouseButton</p> <code>MouseButtonState</code> <p>tauri::tray::MouseButtonState</p> <code>TrayIcon</code> <p>tauri::tray::TrayIcon</p> <code>TrayIconEvent</code> <p>tauri::tray::TrayIconEvent</p> <p>Attributes:</p> Name Type Description <code>TrayIconEventType</code> <p>See TrayIconEvent for details.</p> <code>TrayIconId</code> <p>tauri::tray::TrayIconId</p>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEventType","title":"TrayIconEventType  <code>module-attribute</code>","text":"<pre><code>TrayIconEventType = TypeAliasType('TrayIconEventType', Union[Click, DoubleClick, Enter, Move, Leave])\n</code></pre> <p>See TrayIconEvent for details.</p>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconId","title":"TrayIconId  <code>module-attribute</code>","text":"<pre><code>TrayIconId = TypeAliasType('TrayIconId', str)\n</code></pre> <p>tauri::tray::TrayIconId</p>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['MouseButton', 'MouseButtonState', 'TrayIcon', 'TrayIconEvent', 'TrayIconEventType', 'TrayIconId']\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButton","title":"MouseButton","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::tray::MouseButton</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Left</code> <code>Right</code> <code>Middle</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButton.Left","title":"Left  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Left = auto()\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButton.Right","title":"Right  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Right = auto()\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButton.Middle","title":"Middle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Middle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButtonState","title":"MouseButtonState","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::tray::MouseButtonState</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Up</code> <code>Down</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButtonState.Up","title":"Up  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Up = auto()\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.MouseButtonState.Down","title":"Down  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Down = auto()\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon","title":"TrayIcon","text":"<p>tauri::tray::TrayIcon</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>on_menu_event</code> <p>This is an alias for pytauri.ffi.AppHandle.on_menu_event.</p> <code>on_tray_icon_event</code> <p>Set a handler for this tray icon events.</p> <code>id</code> <code>set_icon</code> <code>set_menu</code> <code>set_tooltip</code> <code>set_title</code> <code>set_visible</code> <code>set_temp_dir_path</code> <code>set_icon_as_template</code> <code>set_show_menu_on_left_click</code> <code>rect</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def __new__(cls, manager: ImplManager, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: TrayIconId) -&gt; TrayIcon\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>@staticmethod\ndef with_id(manager: ImplManager, id: TrayIconId, /) -&gt; \"TrayIcon\": ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[AppHandle, MenuEvent], None]) -&gt; None\n</code></pre> <p>This is an alias for pytauri.ffi.AppHandle.on_menu_event.</p> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[AppHandle, MenuEvent], None], /\n) -&gt; None:\n    \"\"\"This is an alias for [pytauri.ffi.AppHandle.on_menu_event][].\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.on_tray_icon_event","title":"on_tray_icon_event","text":"<pre><code>on_tray_icon_event(handler: Callable[[Self, TrayIconEventType], None]) -&gt; None\n</code></pre> <p>Set a handler for this tray icon events.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def on_tray_icon_event(\n    self, handler: Callable[[Self, \"TrayIconEventType\"], None], /\n) -&gt; None:\n    \"\"\"Set a handler for this tray icon events.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.id","title":"id","text":"<pre><code>id() -&gt; TrayIconId\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def id(self, /) -&gt; TrayIconId: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Optional[Image]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_icon(self, icon: Optional[Image], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Optional[ImplContextMenu]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_menu(self, menu: Optional[ImplContextMenu], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_tooltip","title":"set_tooltip","text":"<pre><code>set_tooltip(tooltip: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_tooltip(self, tooltip: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_title","title":"set_title","text":"<pre><code>set_title(title: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_title(self, title: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_visible","title":"set_visible","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_visible(self, visible: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_temp_dir_path","title":"set_temp_dir_path","text":"<pre><code>set_temp_dir_path(path: Optional[_ToPyo3Path]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_temp_dir_path(self, path: Optional[_ToPyo3Path], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_icon_as_template","title":"set_icon_as_template","text":"<pre><code>set_icon_as_template(is_template: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_icon_as_template(self, is_template: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.set_show_menu_on_left_click","title":"set_show_menu_on_left_click","text":"<pre><code>set_show_menu_on_left_click(enable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_show_menu_on_left_click(self, enable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIcon.rect","title":"rect","text":"<pre><code>rect() -&gt; Optional[Rect]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def rect(self, /) -&gt; Optional[Rect]: ...\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent","title":"TrayIconEvent","text":"<p>tauri::tray::TrayIconEvent</p> <p>Classes:</p> Name Description <code>Click</code> <p>tauri::tray::TrayIconEvent::Click</p> <code>DoubleClick</code> <p>tauri::tray::TrayIconEvent::DoubleClick</p> <code>Enter</code> <p>tauri::tray::TrayIconEvent::Enter</p> <code>Move</code> <p>tauri::tray::TrayIconEvent::Move</p> <code>Leave</code> <p>tauri::tray::TrayIconEvent::Leave</p>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click","title":"Click","text":"<p>tauri::tray::TrayIconEvent::Click</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PyPhysicalPositionF64</code> <code>rect</code> <code>Rect</code> <code>button</code> <code>MouseButton</code> <code>button_state</code> <code>MouseButtonState</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click.position","title":"position  <code>property</code>","text":"<pre><code>position: _PyPhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click.button","title":"button  <code>property</code>","text":"<pre><code>button: MouseButton\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Click.button_state","title":"button_state  <code>property</code>","text":"<pre><code>button_state: MouseButtonState\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.DoubleClick","title":"DoubleClick","text":"<p>tauri::tray::TrayIconEvent::DoubleClick</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PyPhysicalPositionF64</code> <code>rect</code> <code>Rect</code> <code>button</code> <code>MouseButton</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.DoubleClick.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.DoubleClick.position","title":"position  <code>property</code>","text":"<pre><code>position: _PyPhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.DoubleClick.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.DoubleClick.button","title":"button  <code>property</code>","text":"<pre><code>button: MouseButton\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Enter","title":"Enter","text":"<p>tauri::tray::TrayIconEvent::Enter</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PyPhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Enter.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Enter.position","title":"position  <code>property</code>","text":"<pre><code>position: _PyPhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Enter.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Move","title":"Move","text":"<p>tauri::tray::TrayIconEvent::Move</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PyPhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Move.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Move.position","title":"position  <code>property</code>","text":"<pre><code>position: _PyPhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Move.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Leave","title":"Leave","text":"<p>tauri::tray::TrayIconEvent::Leave</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PyPhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Leave.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Leave.position","title":"position  <code>property</code>","text":"<pre><code>position: _PyPhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/tray/#pytauri.tray.TrayIconEvent.Leave.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/webview/","title":"webview","text":""},{"location":"reference/py/pytauri/webview/#pytauri.webview","title":"pytauri.webview","text":"<p>tauri::webview</p> <p>Classes:</p> Name Description <code>Webview</code> <p>tauri::webview::Webview</p> <code>WebviewWindow</code> <p>tauri::webview::WebviewWindow</p>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Webview', 'WebviewWindow']\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.Webview","title":"Webview","text":"<p>tauri::webview::Webview</p> <p>Methods:</p> Name Description <code>window</code>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.Webview.window","title":"window","text":"<pre><code>window() -&gt; Window\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def window(self) -&gt; \"Window\": ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow","title":"WebviewWindow","text":"<p>tauri::webview::WebviewWindow</p> <p>Methods:</p> Name Description <code>run_on_main_thread</code> <p>Runs the given closure on the main thread.</p> <code>label</code> <code>on_menu_event</code> <p>Registers a global menu event listener.</p> <code>menu</code> <code>set_menu</code> <code>remove_menu</code> <code>hide_menu</code> <code>show_menu</code> <code>is_menu_visible</code> <code>popup_menu</code> <code>popup_menu_at</code> <code>is_fullscreen</code> <code>is_minimized</code> <code>is_maximized</code> <code>is_focused</code> <code>is_decorated</code> <code>is_resizable</code> <code>is_enabled</code> <code>is_maximizable</code> <code>is_minimizable</code> <code>is_closable</code> <code>is_visible</code> <code>title</code> <code>center</code> <code>set_resizable</code> <code>set_enabled</code> <code>set_maximizable</code> <code>set_minimizable</code> <code>set_closable</code> <code>set_title</code> <code>maximize</code> <code>unmaximize</code> <code>minimize</code> <code>unminimize</code> <code>show</code> <code>hide</code> <code>close</code> <code>destroy</code> <code>set_decorations</code> <code>set_shadow</code> <code>set_always_on_bottom</code> <code>set_always_on_top</code> <code>set_visible_on_all_workspaces</code> <code>set_content_protected</code> <code>set_fullscreen</code> <code>set_focus</code> <code>set_icon</code> <code>set_skip_taskbar</code> <code>set_cursor_grab</code> <code>set_cursor_visible</code> <code>set_ignore_cursor_events</code> <code>start_dragging</code> <code>set_badge_count</code> <code>print</code> <code>url</code> <code>eval</code> <code>set_zoom</code> <code>clear_all_browsing_data</code> <code>as_ref_webview</code>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.run_on_main_thread","title":"run_on_main_thread","text":"<pre><code>run_on_main_thread(handler: Callable[[], object]) -&gt; None\n</code></pre> <p>Runs the given closure on the main thread.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def run_on_main_thread(self, handler: Callable[[], object], /) -&gt; None:\n    \"\"\"Runs the given closure on the main thread.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.label","title":"label","text":"<pre><code>label() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def label(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[Self, MenuEvent], None]) -&gt; None\n</code></pre> <p>Registers a global menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[\"Self\", \"MenuEvent\"], None], /\n) -&gt; None:\n    \"\"\"Registers a global menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.menu","title":"menu","text":"<pre><code>menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Menu) -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_menu(self, menu: Menu, /) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.remove_menu","title":"remove_menu","text":"<pre><code>remove_menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def remove_menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.hide_menu","title":"hide_menu","text":"<pre><code>hide_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def hide_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.show_menu","title":"show_menu","text":"<pre><code>show_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def show_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_menu_visible","title":"is_menu_visible","text":"<pre><code>is_menu_visible() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_menu_visible(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.popup_menu","title":"popup_menu","text":"<pre><code>popup_menu(menu: ImplContextMenu) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def popup_menu(self, menu: ImplContextMenu, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.popup_menu_at","title":"popup_menu_at","text":"<pre><code>popup_menu_at(menu: ImplContextMenu, position: PositionType) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def popup_menu_at(\n    self, menu: ImplContextMenu, position: PositionType, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_fullscreen","title":"is_fullscreen","text":"<pre><code>is_fullscreen() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_fullscreen(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_minimized","title":"is_minimized","text":"<pre><code>is_minimized() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_minimized(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_maximized","title":"is_maximized","text":"<pre><code>is_maximized() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_maximized(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_focused","title":"is_focused","text":"<pre><code>is_focused() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_focused(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_decorated","title":"is_decorated","text":"<pre><code>is_decorated() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_decorated(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_resizable","title":"is_resizable","text":"<pre><code>is_resizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_resizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_enabled(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_maximizable","title":"is_maximizable","text":"<pre><code>is_maximizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_maximizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_minimizable","title":"is_minimizable","text":"<pre><code>is_minimizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_minimizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_closable","title":"is_closable","text":"<pre><code>is_closable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_closable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.is_visible","title":"is_visible","text":"<pre><code>is_visible() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_visible(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.title","title":"title","text":"<pre><code>title() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def title(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.center","title":"center","text":"<pre><code>center() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def center(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_resizable","title":"set_resizable","text":"<pre><code>set_resizable(resizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_resizable(self, resizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_maximizable","title":"set_maximizable","text":"<pre><code>set_maximizable(maximizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_maximizable(self, maximizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_minimizable","title":"set_minimizable","text":"<pre><code>set_minimizable(minimizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_minimizable(self, minimizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_closable","title":"set_closable","text":"<pre><code>set_closable(closable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_closable(self, closable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_title","title":"set_title","text":"<pre><code>set_title(title: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_title(self, title: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.maximize","title":"maximize","text":"<pre><code>maximize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def maximize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.unmaximize","title":"unmaximize","text":"<pre><code>unmaximize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def unmaximize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.minimize","title":"minimize","text":"<pre><code>minimize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def minimize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.unminimize","title":"unminimize","text":"<pre><code>unminimize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def unminimize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def show(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def hide(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def close(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.destroy","title":"destroy","text":"<pre><code>destroy() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def destroy(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_decorations","title":"set_decorations","text":"<pre><code>set_decorations(decorations: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_decorations(self, decorations: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_shadow","title":"set_shadow","text":"<pre><code>set_shadow(shadow: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_shadow(self, shadow: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_always_on_bottom","title":"set_always_on_bottom","text":"<pre><code>set_always_on_bottom(always_on_bottom: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_always_on_bottom(self, always_on_bottom: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_always_on_top","title":"set_always_on_top","text":"<pre><code>set_always_on_top(always_on_top: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_always_on_top(self, always_on_top: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_visible_on_all_workspaces","title":"set_visible_on_all_workspaces","text":"<pre><code>set_visible_on_all_workspaces(visible_on_all_workspaces: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_visible_on_all_workspaces(\n    self, visible_on_all_workspaces: bool, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_content_protected","title":"set_content_protected","text":"<pre><code>set_content_protected(protected: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_content_protected(self, protected: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_fullscreen","title":"set_fullscreen","text":"<pre><code>set_fullscreen(fullscreen: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_fullscreen(self, fullscreen: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_focus","title":"set_focus","text":"<pre><code>set_focus() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_focus(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Image) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_icon(self, icon: Image, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_skip_taskbar","title":"set_skip_taskbar","text":"<pre><code>set_skip_taskbar(skip: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_skip_taskbar(self, skip: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_cursor_grab","title":"set_cursor_grab","text":"<pre><code>set_cursor_grab(grab: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_cursor_grab(self, grab: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_cursor_visible","title":"set_cursor_visible","text":"<pre><code>set_cursor_visible(visible: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_cursor_visible(self, visible: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_ignore_cursor_events","title":"set_ignore_cursor_events","text":"<pre><code>set_ignore_cursor_events(ignore: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_ignore_cursor_events(self, ignore: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.start_dragging","title":"start_dragging","text":"<pre><code>start_dragging() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def start_dragging(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_badge_count","title":"set_badge_count","text":"<pre><code>set_badge_count(count: Optional[int]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_badge_count(self, count: Optional[int], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.print","title":"print","text":"<pre><code>print() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def print(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.url","title":"url","text":"<pre><code>url() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def url(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.eval","title":"eval","text":"<pre><code>eval(js: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def eval(self, js: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.set_zoom","title":"set_zoom","text":"<pre><code>set_zoom(scale_factor: float) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_zoom(self, scale_factor: float, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.clear_all_browsing_data","title":"clear_all_browsing_data","text":"<pre><code>clear_all_browsing_data() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def clear_all_browsing_data(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/webview/#pytauri.webview.WebviewWindow.as_ref_webview","title":"as_ref_webview","text":"<pre><code>as_ref_webview() -&gt; Webview\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def as_ref_webview(self) -&gt; \"Webview\": ...\n</code></pre>"},{"location":"reference/py/pytauri/window/","title":"window","text":""},{"location":"reference/py/pytauri/window/#pytauri.window","title":"pytauri.window","text":"<p>tauri::window</p> <p>Classes:</p> Name Description <code>Window</code> <p>tauri::Window</p>"},{"location":"reference/py/pytauri/window/#pytauri.window.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Window']\n</code></pre>"},{"location":"reference/py/pytauri/window/#pytauri.window.Window","title":"Window","text":"<p>tauri::Window</p>"},{"location":"reference/py/pytauri/ffi/","title":"ffi","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi","title":"pytauri.ffi","text":"<p>Original FFI interface module.</p> <p>Warning</p> <p>All APIs under this module should not be considered stable. You should use the re-exported APIs under the top-level module.</p> <p>Modules:</p> Name Description <code>image</code> <p>tauri::image</p> <code>ipc</code> <p>tauri::ipc</p> <code>lib</code> <p>tauri::self</p> <code>menu</code> <p>tauri::menu</p> <code>tray</code> <p>tauri::tray</p> <code>webview</code> <p>tauri::webview</p> <code>window</code> <p>tauri::window</p> <p>Classes:</p> Name Description <code>App</code> <p>Tauri::app</p> <code>AppHandle</code> <p>tauri::AppHandle</p> <code>Assets</code> <p>tauri::Assets</p> <code>Builder</code> <p>Tauri::Builder</p> <code>BuilderArgs</code> <code>Context</code> <p>tauri::Context</p> <code>Event</code> <p>tauri::Event</p> <code>Listener</code> <p>tauri::Listener</p> <code>Manager</code> <p>tauri::Manager</p> <code>Position</code> <p>tauri::Position</p> <code>Rect</code> <p>tauri::Rect</p> <code>RunEvent</code> <p>tauri::RunEvent</p> <code>Size</code> <p>tauri::Size</p> <p>Functions:</p> Name Description <code>builder_factory</code> <p>A factory function for creating a <code>Builder</code> instance.</p> <code>context_factory</code> <p>A factory function for creating a <code>Context</code> instance.</p> <p>Attributes:</p> Name Type Description <code>EXT_MOD</code> <code>ModuleType</code> <p>The extension module of <code>pytauri</code> app.</p> <code>EventId</code> <p>tauri::EventId</p> <code>ImplListener</code> <code>ImplManager</code> <code>PositionType</code> <p>See Position for details.</p> <code>RunEventType</code> <p>See RunEvent for details.</p> <code>SizeType</code> <p>See Size for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EXT_MOD","title":"EXT_MOD  <code>module-attribute</code>","text":"<pre><code>EXT_MOD: ModuleType\n</code></pre> <p>The extension module of <code>pytauri</code> app.</p> <p>It will be loaded from <code>entry_points(group=\"pytauri\", name=\"ext_mod\")</code>.</p> <p>Usually you don't need to use it, unless you want to write plugins for <code>pytauri</code>.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.EventId","title":"EventId  <code>module-attribute</code>","text":"<pre><code>EventId = NewType('EventId', int)\n</code></pre> <p>tauri::EventId</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.ImplListener","title":"ImplListener  <code>module-attribute</code>","text":"<pre><code>ImplListener = ImplManager\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.ImplManager","title":"ImplManager  <code>module-attribute</code>","text":"<pre><code>ImplManager = TypeAliasType('ImplManager', Union[App, AppHandle, 'webview.WebviewWindow'])\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.PositionType","title":"PositionType  <code>module-attribute</code>","text":"<pre><code>PositionType = TypeAliasType('PositionType', Union[Physical, Logical])\n</code></pre> <p>See Position for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEventType","title":"RunEventType  <code>module-attribute</code>","text":"<pre><code>RunEventType = TypeAliasType('RunEventType', Union[Exit, ExitRequested, WindowEvent, WebviewEvent, Ready, Resumed, MainEventsCleared, MenuEvent, TrayIconEvent])\n</code></pre> <p>See RunEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.SizeType","title":"SizeType  <code>module-attribute</code>","text":"<pre><code>SizeType = TypeAliasType('SizeType', Union[Physical, Logical])\n</code></pre> <p>See Size for details.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ('EXT_MOD', 'App', 'AppHandle', 'Assets', 'Builder', 'BuilderArgs', 'Context', 'Event', 'EventId', 'ImplListener', 'ImplManager', 'Listener', 'Manager', 'Position', 'PositionType', 'Rect', 'RunEvent', 'RunEventType', 'Size', 'SizeType', 'builder_factory', 'context_factory')\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App","title":"App","text":"<p>Tauri::app</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>run</code> <p>Consume and run this app, will block until the app is exited.</p> <code>run_iteration</code> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <code>cleanup_before_exit</code> <p>Runs necessary cleanup tasks before exiting the process.</p> <code>handle</code> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.run","title":"run","text":"<pre><code>run(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Consume and run this app, will block until the app is exited.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each event. It will be called on the same thread that the app was created on, so you should not block in this function.</p> <code>None</code> <p>Warning</p> <p>If <code>callback</code> is specified, it must not raise an exception, otherwise it is undefined behavior, and in most cases, the program will panic.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; None:\n    \"\"\"Consume and run this app, will block until the app is exited.\n\n    Args:\n        callback: a callback function that will be called on each event.\n            It will be called on the same thread that the app was created on,\n            so you should not block in this function.\n\n    !!! warning\n        If `callback` is specified, it must not raise an exception,\n        otherwise it is undefined behavior, and in most cases, the program will panic.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.run(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.run_iteration","title":"run_iteration","text":"<pre><code>run_iteration(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each iteration.</p> <code>None</code> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> <p>Tip</p> <p>Approximately 2ms per calling in debug mode.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_iteration(\n    self, callback: Optional[_AppRunCallbackType] = None, /\n) -&gt; None:\n    \"\"\"Run this app iteratively without consuming it, calling `callback` on each iteration.\n\n    Args:\n        callback: a callback function that will be called on each iteration.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n\n    !!! tip\n        Approximately 2ms per calling in debug mode.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.run_iteration(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.cleanup_before_exit","title":"cleanup_before_exit","text":"<pre><code>cleanup_before_exit() -&gt; None\n</code></pre> <p>Runs necessary cleanup tasks before exiting the process.</p> <p>You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def cleanup_before_exit(self, /) -&gt; None:\n    \"\"\"Runs necessary cleanup tasks before exiting the process.\n\n    **You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.**\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.App.handle","title":"handle","text":"<pre><code>handle() -&gt; AppHandle\n</code></pre> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def handle(self, /) -&gt; \"AppHandle\":\n    \"\"\"Get a handle to this app, which can be used to interact with the app from another thread.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle","title":"AppHandle","text":"<p>tauri::AppHandle</p> <p>Methods:</p> Name Description <code>run_on_main_thread</code> <p>Runs the given closure on the main thread.</p> <code>exit</code> <code>restart</code> <code>on_menu_event</code> <p>Registers a global menu event listener.</p> <code>on_tray_icon_event</code> <p>Registers a global tray icon menu event listener.</p> <code>tray_by_id</code> <code>remove_tray_by_id</code> <code>default_window_icon</code> <p>Returns the default window icon.</p> <code>menu</code> <code>set_menu</code> <code>remove_menu</code> <code>hide_menu</code> <code>show_menu</code> <code>invoke_key</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.run_on_main_thread","title":"run_on_main_thread","text":"<pre><code>run_on_main_thread(handler: Callable[[], object]) -&gt; None\n</code></pre> <p>Runs the given closure on the main thread.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_on_main_thread(self, handler: Callable[[], object], /) -&gt; None:\n    \"\"\"Runs the given closure on the main thread.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.exit","title":"exit","text":"<pre><code>exit(exit_code: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def exit(self, exit_code: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.restart","title":"restart","text":"<pre><code>restart() -&gt; Never\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def restart(self, /) -&gt; Never: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[Self, MenuEvent], None]) -&gt; None\n</code></pre> <p>Registers a global menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[\"Self\", \"MenuEvent\"], None], /\n) -&gt; None:\n    \"\"\"Registers a global menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.on_tray_icon_event","title":"on_tray_icon_event","text":"<pre><code>on_tray_icon_event(handler: Callable[[Self, TrayIconEventType], None]) -&gt; None\n</code></pre> <p>Registers a global tray icon menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_tray_icon_event(\n    self, handler: Callable[[Self, TrayIconEventType], None], /\n) -&gt; None:\n    \"\"\"Registers a global tray icon menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.tray_by_id","title":"tray_by_id","text":"<pre><code>tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.remove_tray_by_id","title":"remove_tray_by_id","text":"<pre><code>remove_tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.default_window_icon","title":"default_window_icon","text":"<pre><code>default_window_icon() -&gt; Optional[Image]\n</code></pre> <p>Returns the default window icon.</p> <p>Warning</p> <p>Each time you call this function, a new image instance will be created. So you should cache the result if you need to use it multiple times.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def default_window_icon(self, /) -&gt; Optional[Image]:\n    \"\"\"Returns the default window icon.\n\n    !!! warning\n        Each time you call this function, a new image instance will be created.\n        So you should cache the result if you need to use it multiple times.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.menu","title":"menu","text":"<pre><code>menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Menu) -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_menu(self, menu: Menu, /) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.remove_menu","title":"remove_menu","text":"<pre><code>remove_menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.hide_menu","title":"hide_menu","text":"<pre><code>hide_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def hide_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.show_menu","title":"show_menu","text":"<pre><code>show_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def show_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.AppHandle.invoke_key","title":"invoke_key","text":"<pre><code>invoke_key() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def invoke_key(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Assets","title":"Assets","text":"<p>               Bases: <code>ABC</code></p> <p>tauri::Assets</p> <p>This is an abstract class that you can subclass to implement a custom asset loader.</p> <p>See <code>tauri::Assets</code> rust docs for more details.</p> <p>Warning</p> <p>The implement has the same restrictions as App.run.</p> <p>Methods:</p> Name Description <code>get</code> <code>iter</code> <code>setup</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Assets.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key: _AssetKey) -&gt; Optional[bytes]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef get(self, key: _AssetKey, /) -&gt; Optional[bytes]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Assets.iter","title":"iter  <code>abstractmethod</code>","text":"<pre><code>iter() -&gt; Iterator[tuple[str, bytes]]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef iter(self, /) -&gt; Iterator[tuple[str, bytes]]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Assets.setup","title":"setup","text":"<pre><code>setup(_app: AppHandle) -&gt; object\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def setup(self, _app: AppHandle, /) -&gt; object:\n    return None\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Builder","title":"Builder","text":"<p>Tauri::Builder</p> <p>use builder_factory to instantiate this class.</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>build</code> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Builder.build","title":"build","text":"<pre><code>build(args: BuilderArgs) -&gt; App\n</code></pre> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def build(self, args: BuilderArgs, /) -&gt; App:\n    \"\"\"Consume this builder and build an app with the given `BuilderArgs`.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.BuilderArgs","title":"BuilderArgs","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>tauri::Builder</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.BuilderArgs.__new__","title":"__new__","text":"<pre><code>__new__(context: Context, *, invoke_handler: Optional[_InvokeHandlerProto] = None, setup: Optional[Callable[[AppHandle], object]] = None) -&gt; Self\n</code></pre> <p>tauri::Builder</p> <p>Warning</p> <p>The implementer of <code>invoke_handler</code> must never raise an exception, otherwise it is considered undefined behavior. Additionally, <code>invoke_handler</code> must not block.</p> <p>Parameters:</p> Name Type Description Default <code>Context</code> <p>use context_factory to get it.</p> required <code>Optional[_InvokeHandlerProto]</code> <p>use Commands to get it.</p> <code>None</code> <code>Optional[Callable[[AppHandle], object]]</code> <p>see rust <code>tauri::Builder::setup</code>.</p> <code>None</code> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    context: \"Context\",\n    *,\n    invoke_handler: Optional[_InvokeHandlerProto] = None,\n    setup: Optional[Callable[[AppHandle], object]] = None,\n) -&gt; Self:\n    \"\"\"[tauri::Builder](https://docs.rs/tauri/latest/tauri/struct.Builder.html)\n\n    !!! warning\n        The implementer of `invoke_handler` must never raise an exception,\n        otherwise it is considered undefined behavior.\n        Additionally, `invoke_handler` must not block.\n\n    Args:\n        context: use [context_factory][pytauri.context_factory] to get it.\n        invoke_handler: use [Commands][pytauri.ipc.Commands] to get it.\n        setup: see rust `tauri::Builder::setup`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.BuilderArgs.__new__(context)","title":"<code>context</code>","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.BuilderArgs.__new__(invoke_handler)","title":"<code>invoke_handler</code>","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.BuilderArgs.__new__(setup)","title":"<code>setup</code>","text":""},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Context","title":"Context","text":"<p>tauri::Context</p> <p>Methods:</p> Name Description <code>set_assets</code> <p>Use custom assets instead of the assets bundled by Tauri.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Context.set_assets","title":"set_assets","text":"<pre><code>set_assets(assets: Assets) -&gt; None\n</code></pre> <p>Use custom assets instead of the assets bundled by Tauri.</p> <p>To make this work:</p> <ul> <li>You need to enable the <code>tauri/custom-protocol</code> feature.<ul> <li>Or build using <code>tauri build</code>.</li> </ul> </li> <li>Set <code>frontendDist</code> in <code>tauri.conf.json</code> to an empty directory (do not set it to a URL).<ul> <li> <p>Or generate <code>Context</code> via:</p> <pre><code>use tauri::{generate_context, test::noop_assets};\n\nlet context = generate_context!(assets=noop_assets());\n</code></pre> <p>then we will use this method to set the assets.</p> <p>see: https://github.com/tauri-apps/tauri/pull/9141</p> </li> </ul> </li> </ul> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_assets(self, assets: \"Assets\", /) -&gt; None:\n    \"\"\"Use custom assets instead of the assets bundled by Tauri.\n\n    To make this work:\n\n    - You need to enable the `tauri/custom-protocol` feature.\n        - Or build using `tauri build`.\n    - Set `frontendDist` in `tauri.conf.json` to an empty directory (do not set it to a URL).\n        - Or generate `Context` via:\n\n            ```rust\n            use tauri::{generate_context, test::noop_assets};\n\n            let context = generate_context!(assets=noop_assets());\n            ```\n\n            then we will use this method to set the assets.\n\n            see: &lt;https://github.com/tauri-apps/tauri/pull/9141&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Event","title":"Event","text":"<p>tauri::Event</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>EventId</code> <p>The <code>EventId</code> of the handler that was triggered.</p> <code>payload</code> <code>str</code> <p>The event payload.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Event.id","title":"id  <code>property</code>","text":"<pre><code>id: EventId\n</code></pre> <p>The <code>EventId</code> of the handler that was triggered.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Event.payload","title":"payload  <code>property</code>","text":"<pre><code>payload: str\n</code></pre> <p>The event payload.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener","title":"Listener","text":"<p>tauri::Listener</p> <p>See also: https://tauri.app/develop/calling-rust/#event-system</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener--example","title":"Example","text":"<pre><code>from pytauri import AppHandle, Event, Listener\n\n\ndef listen(app_handle: AppHandle) -&gt; None:\n    def handler(event: Event):\n        print(event.id, event.payload)\n\n    Listener.listen(app_handle, \"event_name\", handler)\n</code></pre> <p>Methods:</p> Name Description <code>listen</code> <p>Listen to an emitted event on this manager.</p> <code>once</code> <p>Listen to an event on this manager only once.</p> <code>unlisten</code> <p>Remove an event listener.</p> <code>listen_any</code> <p>Listen to an emitted event to any target.</p> <code>once_any</code> <p>Listens once to an emitted event to any target .</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener.listen","title":"listen  <code>staticmethod</code>","text":"<pre><code>listen(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event on this manager.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event on this manager.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener.once","title":"once  <code>staticmethod</code>","text":"<pre><code>once(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an event on this manager only once.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an event on this manager only once.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener.unlisten","title":"unlisten  <code>staticmethod</code>","text":"<pre><code>unlisten(slf: ImplListener, id: EventId) -&gt; None\n</code></pre> <p>Remove an event listener.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef unlisten(\n    slf: \"ImplListener\",\n    id: \"EventId\",  # noqa: A002\n    /,\n) -&gt; None:\n    \"\"\"Remove an event listener.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener.listen_any","title":"listen_any  <code>staticmethod</code>","text":"<pre><code>listen_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event to any target.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event to any target.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Listener.once_any","title":"once_any  <code>staticmethod</code>","text":"<pre><code>once_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listens once to an emitted event to any target .</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listens once to an emitted event to any target .\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Manager","title":"Manager","text":"<p>tauri::Manager</p> <p>Methods:</p> Name Description <code>app_handle</code> <p>The application handle associated with this manager.</p> <code>get_webview_window</code> <p>Fetch a single webview window from the manager.</p> <code>webview_windows</code> <p>Fetch all managed webview windows.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Manager.app_handle","title":"app_handle  <code>staticmethod</code>","text":"<pre><code>app_handle(slf: ImplManager) -&gt; AppHandle\n</code></pre> <p>The application handle associated with this manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef app_handle(slf: \"ImplManager\", /) -&gt; AppHandle:\n    \"\"\"The application handle associated with this manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Manager.get_webview_window","title":"get_webview_window  <code>staticmethod</code>","text":"<pre><code>get_webview_window(slf: ImplManager, label: str) -&gt; Optional[WebviewWindow]\n</code></pre> <p>Fetch a single webview window from the manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef get_webview_window(\n    slf: \"ImplManager\", label: str, /\n) -&gt; Optional[webview.WebviewWindow]:\n    \"\"\"Fetch a single webview window from the manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Manager.webview_windows","title":"webview_windows  <code>staticmethod</code>","text":"<pre><code>webview_windows(slf: ImplManager) -&gt; dict[str, WebviewWindow]\n</code></pre> <p>Fetch all managed webview windows.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef webview_windows(slf: \"ImplManager\", /) -&gt; dict[str, webview.WebviewWindow]:\n    \"\"\"Fetch all managed webview windows.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Position","title":"Position","text":"<p>tauri::Position</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Position::Physical</p> <code>Logical</code> <p>tauri::Position::Logical</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Position.Physical","title":"Physical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Position::Physical</p> <p><code>[x, y]</code></p> <p>Warning</p> <p>This is actually a <code>Class</code> disguised as an <code>NamedTuple</code>. See also: https://pyo3.rs/v0.23.4/class.html#pyclass-enums.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Position.Logical","title":"Logical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Position::Logical</p> <p><code>[x, y]</code></p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Rect","title":"Rect","text":"<p>tauri::Rect</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>position</code> <code>PositionType</code> <code>size</code> <code>SizeType</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Rect.position","title":"position  <code>property</code>","text":"<pre><code>position: PositionType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Rect.size","title":"size  <code>property</code>","text":"<pre><code>size: SizeType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Rect.__new__","title":"__new__","text":"<pre><code>__new__(*, position: PositionType, size: SizeType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    position: \"PositionType\",\n    size: \"SizeType\",\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent","title":"RunEvent","text":"<p>tauri::RunEvent</p> <p>Classes:</p> Name Description <code>Exit</code> <p>tauri::RunEvent::Exit</p> <code>ExitRequested</code> <p>tauri::RunEvent::ExitRequested</p> <code>WindowEvent</code> <p>tauri::RunEvent::WindowEvent</p> <code>WebviewEvent</code> <p>tauri::RunEvent::WebviewEvent</p> <code>Ready</code> <p>tauri::RunEvent::Ready</p> <code>Resumed</code> <p>tauri::RunEvent::Resumed</p> <code>MainEventsCleared</code> <p>tauri::RunEvent::MainEventsCleared</p> <code>MenuEvent</code> <p>tauri::RunEvent::MenuEvent</p> <code>TrayIconEvent</code> <p>tauri::RunEvent::TrayIconEvent</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.Exit","title":"Exit","text":"<p>tauri::RunEvent::Exit</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.ExitRequested","title":"ExitRequested","text":"<p>tauri::RunEvent::ExitRequested</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>Optional[int]</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.ExitRequested.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Optional[int]\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.WindowEvent","title":"WindowEvent","text":"<p>tauri::RunEvent::WindowEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.WindowEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::RunEvent::WebviewEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.WebviewEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.Ready","title":"Ready","text":"<p>tauri::RunEvent::Ready</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.Resumed","title":"Resumed","text":"<p>tauri::RunEvent::Resumed</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.MainEventsCleared","title":"MainEventsCleared","text":"<p>tauri::RunEvent::MainEventsCleared</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.MenuEvent","title":"MenuEvent","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::RunEvent::MenuEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.RunEvent.TrayIconEvent","title":"TrayIconEvent","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::RunEvent::TrayIconEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Size","title":"Size","text":"<p>tauri::Size</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Size::Physical</p> <code>Logical</code> <p>tauri::Size::Logical</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Size.Physical","title":"Physical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Size::Physical</p> <p><code>[width, height]</code></p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.Size.Logical","title":"Logical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Size::Logical</p> <p><code>[width, height]</code></p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.builder_factory","title":"builder_factory","text":"<pre><code>builder_factory(*args: Any, **kwargs: Any) -&gt; Builder\n</code></pre> <p>A factory function for creating a <code>Builder</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def builder_factory(*args: Any, **kwargs: Any) -&gt; Builder:\n    \"\"\"A factory function for creating a `Builder` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/#pytauri.ffi.context_factory","title":"context_factory","text":"<pre><code>context_factory(*args: Any, **kwargs: Any) -&gt; Context\n</code></pre> <p>A factory function for creating a <code>Context</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def context_factory(*args: Any, **kwargs: Any) -&gt; Context:\n    \"\"\"A factory function for creating a `Context` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/image/","title":"image","text":""},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image","title":"pytauri.ffi.image","text":"<p>tauri::image</p> <p>Classes:</p> Name Description <code>Image</code> <p>tauri::image::Image</p>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Image']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.Image","title":"Image","text":"<p>tauri::image::Image</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>rgba</code> <code>bytes</code> <code>width</code> <code>int</code> <code>height</code> <code>int</code>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.Image.rgba","title":"rgba  <code>property</code>","text":"<pre><code>rgba: bytes\n</code></pre>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.Image.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.Image.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre>"},{"location":"reference/py/pytauri/ffi/image/#pytauri.ffi.image.Image.__new__","title":"__new__","text":"<pre><code>__new__(rgba: bytes, width: int, height: int) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/image.py</code> <pre><code>def __new__(cls, rgba: bytes, width: int, height: int, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/","title":"ipc","text":""},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc","title":"pytauri.ffi.ipc","text":"<p>tauri::ipc</p> <p>Classes:</p> Name Description <code>ParametersType</code> <p>The parameters of a command.</p> <code>ArgumentsType</code> <p>The bound arguments of a command.</p> <code>Invoke</code> <p>tauri::ipc::Invoke</p> <code>InvokeResolver</code> <p>tauri::ipc::InvokeResolver</p> <code>JavaScriptChannelId</code> <p>tauri::ipc::JavaScriptChannelId</p> <code>Channel</code> <p>tauri::ipc::Channel</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ArgumentsType', 'Channel', 'Invoke', 'InvokeResolver', 'JavaScriptChannelId', 'ParametersType']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType","title":"ParametersType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The parameters of a command.</p> <p>All keys are optional, and values can be of any type. If a key exists, it will be assigned a value corresponding to ArgumentsType.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p> <code>app_handle</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p> <code>webview_window</code> <code>ReadOnly[Any]</code> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType.webview_window","title":"webview_window  <code>instance-attribute</code>","text":"<pre><code>webview_window: ReadOnly[Any]\n</code></pre> <p>Whatever. We just use the <code>key</code>, not the <code>value</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType","title":"ArgumentsType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The bound arguments of a command.</p> <p>Each key is optional, depending on the keys of the bound ParametersType.</p> <p>You can use it like <code>**kwargs</code>, for example <code>command(**arguments)</code>.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>bytes</code> <p>The body of ipc message.</p> <code>app_handle</code> <code>AppHandle</code> <p>The handle of the app.</p> <code>webview_window</code> <code>WebviewWindow</code> <p>The <code>WebviewWindow</code> of this <code>Invoke</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: bytes\n</code></pre> <p>The body of ipc message.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: AppHandle\n</code></pre> <p>The handle of the app.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType.webview_window","title":"webview_window  <code>instance-attribute</code>","text":"<pre><code>webview_window: WebviewWindow\n</code></pre> <p>The <code>WebviewWindow</code> of this <code>Invoke</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke","title":"Invoke","text":"<p>tauri::ipc::Invoke</p> <p>Methods:</p> Name Description <code>bind_to</code> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <code>resolve</code> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>The name of the current command.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.command","title":"command  <code>property</code>","text":"<pre><code>command: str\n</code></pre> <p>The name of the current command.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.bind_to","title":"bind_to","text":"<pre><code>bind_to(parameters: ParametersType) -&gt; Optional[InvokeResolver[_ArgumentsTypeVar]]\n</code></pre> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <p>If the frontend illegally calls the IPC, this method will automatically reject this <code>Invoke</code> and return <code>None</code>.</p> <p>The return value InvokeResolver.arguments is not the same object as the input <code>parameters</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def bind_to(\n    self, parameters: ParametersType\n) -&gt; Optional[\"InvokeResolver[_ArgumentsTypeVar]\"]:\n    \"\"\"Consumes this `Invoke` and binds parameters.\n\n    If the frontend illegally calls the IPC,\n    this method will automatically reject this `Invoke` and return `None`.\n\n    The return value [InvokeResolver.arguments][pytauri.ffi.ipc.InvokeResolver.arguments]\n    is not the same object as the input `parameters`.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.resolve","title":"resolve","text":"<pre><code>resolve(value: bytes) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: bytes) -&gt; None:\n    \"\"\"Consumes this `Invoke` and resolves the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `Invoke` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver","title":"InvokeResolver","text":"<p>               Bases: <code>Generic[_ArgumentsTypeVar]</code></p> <p>tauri::ipc::InvokeResolver</p> <p>Methods:</p> Name Description <code>resolve</code> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>arguments</code> <code>_ArgumentsTypeVar</code> <p>The bound arguments of the current command.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: _ArgumentsTypeVar\n</code></pre> <p>The bound arguments of the current command.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver.resolve","title":"resolve","text":"<pre><code>resolve(value: bytes) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: bytes) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and resolves the command with the given value.\"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.JavaScriptChannelId","title":"JavaScriptChannelId","text":"<p>tauri::ipc::JavaScriptChannelId</p> <p>Methods:</p> Name Description <code>from_str</code> <p>Parse a string to a <code>JavaScriptChannelId</code>.</p> <code>channel_on</code> <p>Gets a <code>Channel</code> for this channel ID on the given <code>Webview</code>.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.JavaScriptChannelId.from_str","title":"from_str  <code>staticmethod</code>","text":"<pre><code>from_str(value: str) -&gt; JavaScriptChannelId\n</code></pre> <p>Parse a string to a <code>JavaScriptChannelId</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is ivnalid.</p> <code>TypeError</code> <p>If the <code>value</code> is not a string.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>@staticmethod\ndef from_str(value: str, /) -&gt; \"JavaScriptChannelId\":\n    \"\"\"Parse a string to a `JavaScriptChannelId`.\n\n    Raises:\n        ValueError: If the string is ivnalid.\n        TypeError: If the `value` is not a string.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.JavaScriptChannelId.channel_on","title":"channel_on","text":"<pre><code>channel_on(webview: Webview) -&gt; Channel\n</code></pre> <p>Gets a <code>Channel</code> for this channel ID on the given <code>Webview</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def channel_on(self, webview: Webview, /) -&gt; \"Channel\":\n    \"\"\"Gets a `Channel` for this channel ID on the given `Webview`.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Channel","title":"Channel","text":"<p>tauri::ipc::Channel</p> <p>Methods:</p> Name Description <code>id</code> <p>The channel identifier.</p> <code>send</code> <p>Sends the given data through the channel.</p>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Channel.id","title":"id","text":"<pre><code>id() -&gt; int\n</code></pre> <p>The channel identifier.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def id(self, /) -&gt; int:\n    \"\"\"The channel identifier.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/ipc/#pytauri.ffi.ipc.Channel.send","title":"send","text":"<pre><code>send(data: bytes) -&gt; None\n</code></pre> <p>Sends the given data through the channel.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def send(self, data: bytes, /) -&gt; None:\n    \"\"\"Sends the given data through the channel.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/","title":"lib","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib","title":"pytauri.ffi.lib","text":"<p>tauri::self</p> <p>Modules:</p> Name Description <code>webview</code> <p>tauri::webview</p> <p>Classes:</p> Name Description <code>App</code> <p>Tauri::app</p> <code>AppHandle</code> <p>tauri::AppHandle</p> <code>BuilderArgs</code> <code>Builder</code> <p>Tauri::Builder</p> <code>Context</code> <p>tauri::Context</p> <code>RunEvent</code> <p>tauri::RunEvent</p> <code>Manager</code> <p>tauri::Manager</p> <code>Event</code> <p>tauri::Event</p> <code>Listener</code> <p>tauri::Listener</p> <code>Position</code> <p>tauri::Position</p> <code>Size</code> <p>tauri::Size</p> <code>Rect</code> <p>tauri::Rect</p> <code>Assets</code> <p>tauri::Assets</p> <p>Functions:</p> Name Description <code>builder_factory</code> <p>A factory function for creating a <code>Builder</code> instance.</p> <code>context_factory</code> <p>A factory function for creating a <code>Context</code> instance.</p> <p>Attributes:</p> Name Type Description <code>RunEventType</code> <p>See RunEvent for details.</p> <code>ImplManager</code> <code>EventId</code> <p>tauri::EventId</p> <code>ImplListener</code> <code>PositionType</code> <p>See Position for details.</p> <code>SizeType</code> <p>See Size for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['App', 'AppHandle', 'Assets', 'Builder', 'BuilderArgs', 'Context', 'Event', 'EventId', 'ImplListener', 'ImplManager', 'Listener', 'Manager', 'Position', 'PositionType', 'Rect', 'RunEvent', 'RunEventType', 'Size', 'SizeType', 'builder_factory', 'context_factory']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventType","title":"RunEventType  <code>module-attribute</code>","text":"<pre><code>RunEventType = TypeAliasType('RunEventType', Union[Exit, ExitRequested, WindowEvent, WebviewEvent, Ready, Resumed, MainEventsCleared, MenuEvent, TrayIconEvent])\n</code></pre> <p>See RunEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.ImplManager","title":"ImplManager  <code>module-attribute</code>","text":"<pre><code>ImplManager = TypeAliasType('ImplManager', Union[App, AppHandle, 'webview.WebviewWindow'])\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.EventId","title":"EventId  <code>module-attribute</code>","text":"<pre><code>EventId = NewType('EventId', int)\n</code></pre> <p>tauri::EventId</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.ImplListener","title":"ImplListener  <code>module-attribute</code>","text":"<pre><code>ImplListener = ImplManager\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.PositionType","title":"PositionType  <code>module-attribute</code>","text":"<pre><code>PositionType = TypeAliasType('PositionType', Union[Physical, Logical])\n</code></pre> <p>See Position for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.SizeType","title":"SizeType  <code>module-attribute</code>","text":"<pre><code>SizeType = TypeAliasType('SizeType', Union[Physical, Logical])\n</code></pre> <p>See Size for details.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App","title":"App","text":"<p>Tauri::app</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>run</code> <p>Consume and run this app, will block until the app is exited.</p> <code>run_iteration</code> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <code>cleanup_before_exit</code> <p>Runs necessary cleanup tasks before exiting the process.</p> <code>handle</code> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.run","title":"run","text":"<pre><code>run(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Consume and run this app, will block until the app is exited.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each event. It will be called on the same thread that the app was created on, so you should not block in this function.</p> <code>None</code> <p>Warning</p> <p>If <code>callback</code> is specified, it must not raise an exception, otherwise it is undefined behavior, and in most cases, the program will panic.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; None:\n    \"\"\"Consume and run this app, will block until the app is exited.\n\n    Args:\n        callback: a callback function that will be called on each event.\n            It will be called on the same thread that the app was created on,\n            so you should not block in this function.\n\n    !!! warning\n        If `callback` is specified, it must not raise an exception,\n        otherwise it is undefined behavior, and in most cases, the program will panic.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.run(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.run_iteration","title":"run_iteration","text":"<pre><code>run_iteration(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each iteration.</p> <code>None</code> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> <p>Tip</p> <p>Approximately 2ms per calling in debug mode.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_iteration(\n    self, callback: Optional[_AppRunCallbackType] = None, /\n) -&gt; None:\n    \"\"\"Run this app iteratively without consuming it, calling `callback` on each iteration.\n\n    Args:\n        callback: a callback function that will be called on each iteration.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n\n    !!! tip\n        Approximately 2ms per calling in debug mode.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.run_iteration(callback)","title":"<code>callback</code>","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.cleanup_before_exit","title":"cleanup_before_exit","text":"<pre><code>cleanup_before_exit() -&gt; None\n</code></pre> <p>Runs necessary cleanup tasks before exiting the process.</p> <p>You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def cleanup_before_exit(self, /) -&gt; None:\n    \"\"\"Runs necessary cleanup tasks before exiting the process.\n\n    **You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.**\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.App.handle","title":"handle","text":"<pre><code>handle() -&gt; AppHandle\n</code></pre> <p>Get a handle to this app, which can be used to interact with the app from another thread.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def handle(self, /) -&gt; \"AppHandle\":\n    \"\"\"Get a handle to this app, which can be used to interact with the app from another thread.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle","title":"AppHandle","text":"<p>tauri::AppHandle</p> <p>Methods:</p> Name Description <code>run_on_main_thread</code> <p>Runs the given closure on the main thread.</p> <code>exit</code> <code>restart</code> <code>on_menu_event</code> <p>Registers a global menu event listener.</p> <code>on_tray_icon_event</code> <p>Registers a global tray icon menu event listener.</p> <code>tray_by_id</code> <code>remove_tray_by_id</code> <code>default_window_icon</code> <p>Returns the default window icon.</p> <code>menu</code> <code>set_menu</code> <code>remove_menu</code> <code>hide_menu</code> <code>show_menu</code> <code>invoke_key</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.run_on_main_thread","title":"run_on_main_thread","text":"<pre><code>run_on_main_thread(handler: Callable[[], object]) -&gt; None\n</code></pre> <p>Runs the given closure on the main thread.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_on_main_thread(self, handler: Callable[[], object], /) -&gt; None:\n    \"\"\"Runs the given closure on the main thread.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.exit","title":"exit","text":"<pre><code>exit(exit_code: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def exit(self, exit_code: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.restart","title":"restart","text":"<pre><code>restart() -&gt; Never\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def restart(self, /) -&gt; Never: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[Self, MenuEvent], None]) -&gt; None\n</code></pre> <p>Registers a global menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[\"Self\", \"MenuEvent\"], None], /\n) -&gt; None:\n    \"\"\"Registers a global menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.on_tray_icon_event","title":"on_tray_icon_event","text":"<pre><code>on_tray_icon_event(handler: Callable[[Self, TrayIconEventType], None]) -&gt; None\n</code></pre> <p>Registers a global tray icon menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def on_tray_icon_event(\n    self, handler: Callable[[Self, TrayIconEventType], None], /\n) -&gt; None:\n    \"\"\"Registers a global tray icon menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.tray_by_id","title":"tray_by_id","text":"<pre><code>tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.remove_tray_by_id","title":"remove_tray_by_id","text":"<pre><code>remove_tray_by_id(id: str) -&gt; Optional[TrayIcon]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_tray_by_id(self, id: str, /) -&gt; Optional[TrayIcon]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.default_window_icon","title":"default_window_icon","text":"<pre><code>default_window_icon() -&gt; Optional[Image]\n</code></pre> <p>Returns the default window icon.</p> <p>Warning</p> <p>Each time you call this function, a new image instance will be created. So you should cache the result if you need to use it multiple times.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def default_window_icon(self, /) -&gt; Optional[Image]:\n    \"\"\"Returns the default window icon.\n\n    !!! warning\n        Each time you call this function, a new image instance will be created.\n        So you should cache the result if you need to use it multiple times.\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.menu","title":"menu","text":"<pre><code>menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Menu) -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_menu(self, menu: Menu, /) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.remove_menu","title":"remove_menu","text":"<pre><code>remove_menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def remove_menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.hide_menu","title":"hide_menu","text":"<pre><code>hide_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def hide_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.show_menu","title":"show_menu","text":"<pre><code>show_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def show_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle.invoke_key","title":"invoke_key","text":"<pre><code>invoke_key() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def invoke_key(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs","title":"BuilderArgs","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>tauri::Builder</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs.__new__","title":"__new__","text":"<pre><code>__new__(context: Context, *, invoke_handler: Optional[_InvokeHandlerProto] = None, setup: Optional[Callable[[AppHandle], object]] = None) -&gt; Self\n</code></pre> <p>tauri::Builder</p> <p>Warning</p> <p>The implementer of <code>invoke_handler</code> must never raise an exception, otherwise it is considered undefined behavior. Additionally, <code>invoke_handler</code> must not block.</p> <p>Parameters:</p> Name Type Description Default <code>Context</code> <p>use context_factory to get it.</p> required <code>Optional[_InvokeHandlerProto]</code> <p>use Commands to get it.</p> <code>None</code> <code>Optional[Callable[[AppHandle], object]]</code> <p>see rust <code>tauri::Builder::setup</code>.</p> <code>None</code> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    context: \"Context\",\n    *,\n    invoke_handler: Optional[_InvokeHandlerProto] = None,\n    setup: Optional[Callable[[AppHandle], object]] = None,\n) -&gt; Self:\n    \"\"\"[tauri::Builder](https://docs.rs/tauri/latest/tauri/struct.Builder.html)\n\n    !!! warning\n        The implementer of `invoke_handler` must never raise an exception,\n        otherwise it is considered undefined behavior.\n        Additionally, `invoke_handler` must not block.\n\n    Args:\n        context: use [context_factory][pytauri.context_factory] to get it.\n        invoke_handler: use [Commands][pytauri.ipc.Commands] to get it.\n        setup: see rust `tauri::Builder::setup`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs.__new__(context)","title":"<code>context</code>","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs.__new__(invoke_handler)","title":"<code>invoke_handler</code>","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs.__new__(setup)","title":"<code>setup</code>","text":""},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Builder","title":"Builder","text":"<p>Tauri::Builder</p> <p>use builder_factory to instantiate this class.</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>build</code> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Builder.build","title":"build","text":"<pre><code>build(args: BuilderArgs) -&gt; App\n</code></pre> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def build(self, args: BuilderArgs, /) -&gt; App:\n    \"\"\"Consume this builder and build an app with the given `BuilderArgs`.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Context","title":"Context","text":"<p>tauri::Context</p> <p>Methods:</p> Name Description <code>set_assets</code> <p>Use custom assets instead of the assets bundled by Tauri.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Context.set_assets","title":"set_assets","text":"<pre><code>set_assets(assets: Assets) -&gt; None\n</code></pre> <p>Use custom assets instead of the assets bundled by Tauri.</p> <p>To make this work:</p> <ul> <li>You need to enable the <code>tauri/custom-protocol</code> feature.<ul> <li>Or build using <code>tauri build</code>.</li> </ul> </li> <li>Set <code>frontendDist</code> in <code>tauri.conf.json</code> to an empty directory (do not set it to a URL).<ul> <li> <p>Or generate <code>Context</code> via:</p> <pre><code>use tauri::{generate_context, test::noop_assets};\n\nlet context = generate_context!(assets=noop_assets());\n</code></pre> <p>then we will use this method to set the assets.</p> <p>see: https://github.com/tauri-apps/tauri/pull/9141</p> </li> </ul> </li> </ul> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def set_assets(self, assets: \"Assets\", /) -&gt; None:\n    \"\"\"Use custom assets instead of the assets bundled by Tauri.\n\n    To make this work:\n\n    - You need to enable the `tauri/custom-protocol` feature.\n        - Or build using `tauri build`.\n    - Set `frontendDist` in `tauri.conf.json` to an empty directory (do not set it to a URL).\n        - Or generate `Context` via:\n\n            ```rust\n            use tauri::{generate_context, test::noop_assets};\n\n            let context = generate_context!(assets=noop_assets());\n            ```\n\n            then we will use this method to set the assets.\n\n            see: &lt;https://github.com/tauri-apps/tauri/pull/9141&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent","title":"RunEvent","text":"<p>tauri::RunEvent</p> <p>Classes:</p> Name Description <code>Exit</code> <p>tauri::RunEvent::Exit</p> <code>ExitRequested</code> <p>tauri::RunEvent::ExitRequested</p> <code>WindowEvent</code> <p>tauri::RunEvent::WindowEvent</p> <code>WebviewEvent</code> <p>tauri::RunEvent::WebviewEvent</p> <code>Ready</code> <p>tauri::RunEvent::Ready</p> <code>Resumed</code> <p>tauri::RunEvent::Resumed</p> <code>MainEventsCleared</code> <p>tauri::RunEvent::MainEventsCleared</p> <code>MenuEvent</code> <p>tauri::RunEvent::MenuEvent</p> <code>TrayIconEvent</code> <p>tauri::RunEvent::TrayIconEvent</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.Exit","title":"Exit","text":"<p>tauri::RunEvent::Exit</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.ExitRequested","title":"ExitRequested","text":"<p>tauri::RunEvent::ExitRequested</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>Optional[int]</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.ExitRequested.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Optional[int]\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.WindowEvent","title":"WindowEvent","text":"<p>tauri::RunEvent::WindowEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.WindowEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::RunEvent::WebviewEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.WebviewEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.Ready","title":"Ready","text":"<p>tauri::RunEvent::Ready</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.Resumed","title":"Resumed","text":"<p>tauri::RunEvent::Resumed</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.MainEventsCleared","title":"MainEventsCleared","text":"<p>tauri::RunEvent::MainEventsCleared</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.MenuEvent","title":"MenuEvent","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::RunEvent::MenuEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.TrayIconEvent","title":"TrayIconEvent","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::RunEvent::TrayIconEvent</p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Manager","title":"Manager","text":"<p>tauri::Manager</p> <p>Methods:</p> Name Description <code>app_handle</code> <p>The application handle associated with this manager.</p> <code>get_webview_window</code> <p>Fetch a single webview window from the manager.</p> <code>webview_windows</code> <p>Fetch all managed webview windows.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Manager.app_handle","title":"app_handle  <code>staticmethod</code>","text":"<pre><code>app_handle(slf: ImplManager) -&gt; AppHandle\n</code></pre> <p>The application handle associated with this manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef app_handle(slf: \"ImplManager\", /) -&gt; AppHandle:\n    \"\"\"The application handle associated with this manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Manager.get_webview_window","title":"get_webview_window  <code>staticmethod</code>","text":"<pre><code>get_webview_window(slf: ImplManager, label: str) -&gt; Optional[WebviewWindow]\n</code></pre> <p>Fetch a single webview window from the manager.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef get_webview_window(\n    slf: \"ImplManager\", label: str, /\n) -&gt; Optional[webview.WebviewWindow]:\n    \"\"\"Fetch a single webview window from the manager.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Manager.webview_windows","title":"webview_windows  <code>staticmethod</code>","text":"<pre><code>webview_windows(slf: ImplManager) -&gt; dict[str, WebviewWindow]\n</code></pre> <p>Fetch all managed webview windows.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef webview_windows(slf: \"ImplManager\", /) -&gt; dict[str, webview.WebviewWindow]:\n    \"\"\"Fetch all managed webview windows.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Event","title":"Event","text":"<p>tauri::Event</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>EventId</code> <p>The <code>EventId</code> of the handler that was triggered.</p> <code>payload</code> <code>str</code> <p>The event payload.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Event.id","title":"id  <code>property</code>","text":"<pre><code>id: EventId\n</code></pre> <p>The <code>EventId</code> of the handler that was triggered.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Event.payload","title":"payload  <code>property</code>","text":"<pre><code>payload: str\n</code></pre> <p>The event payload.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener","title":"Listener","text":"<p>tauri::Listener</p> <p>See also: https://tauri.app/develop/calling-rust/#event-system</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener--example","title":"Example","text":"<pre><code>from pytauri import AppHandle, Event, Listener\n\n\ndef listen(app_handle: AppHandle) -&gt; None:\n    def handler(event: Event):\n        print(event.id, event.payload)\n\n    Listener.listen(app_handle, \"event_name\", handler)\n</code></pre> <p>Methods:</p> Name Description <code>listen</code> <p>Listen to an emitted event on this manager.</p> <code>once</code> <p>Listen to an event on this manager only once.</p> <code>unlisten</code> <p>Remove an event listener.</p> <code>listen_any</code> <p>Listen to an emitted event to any target.</p> <code>once_any</code> <p>Listens once to an emitted event to any target .</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener.listen","title":"listen  <code>staticmethod</code>","text":"<pre><code>listen(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event on this manager.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event on this manager.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener.once","title":"once  <code>staticmethod</code>","text":"<pre><code>once(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an event on this manager only once.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an event on this manager only once.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener.unlisten","title":"unlisten  <code>staticmethod</code>","text":"<pre><code>unlisten(slf: ImplListener, id: EventId) -&gt; None\n</code></pre> <p>Remove an event listener.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef unlisten(\n    slf: \"ImplListener\",\n    id: \"EventId\",  # noqa: A002\n    /,\n) -&gt; None:\n    \"\"\"Remove an event listener.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener.listen_any","title":"listen_any  <code>staticmethod</code>","text":"<pre><code>listen_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listen to an emitted event to any target.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef listen_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listen to an emitted event to any target.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Listener.once_any","title":"once_any  <code>staticmethod</code>","text":"<pre><code>once_any(slf: ImplListener, event: str, handler: _EventHandlerType) -&gt; EventId\n</code></pre> <p>Listens once to an emitted event to any target .</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@staticmethod\ndef once_any(\n    slf: \"ImplListener\",\n    event: str,\n    handler: _EventHandlerType,\n    /,\n) -&gt; \"EventId\":\n    \"\"\"Listens once to an emitted event to any target .\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Position","title":"Position","text":"<p>tauri::Position</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Position::Physical</p> <code>Logical</code> <p>tauri::Position::Logical</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Position.Physical","title":"Physical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Position::Physical</p> <p><code>[x, y]</code></p> <p>Warning</p> <p>This is actually a <code>Class</code> disguised as an <code>NamedTuple</code>. See also: https://pyo3.rs/v0.23.4/class.html#pyclass-enums.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Position.Logical","title":"Logical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Position::Logical</p> <p><code>[x, y]</code></p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Size","title":"Size","text":"<p>tauri::Size</p> <p>Classes:</p> Name Description <code>Physical</code> <p>tauri::Size::Physical</p> <code>Logical</code> <p>tauri::Size::Logical</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Size.Physical","title":"Physical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Size::Physical</p> <p><code>[width, height]</code></p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Size.Logical","title":"Logical","text":"<p>               Bases: <code>NamedTuple</code></p> <p>tauri::Size::Logical</p> <p><code>[width, height]</code></p> <p>Warning</p> <p>See pytauri.ffi.lib.Position.Physical.</p>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Rect","title":"Rect","text":"<p>tauri::Rect</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Attributes:</p> Name Type Description <code>position</code> <code>PositionType</code> <code>size</code> <code>SizeType</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Rect.position","title":"position  <code>property</code>","text":"<pre><code>position: PositionType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Rect.size","title":"size  <code>property</code>","text":"<pre><code>size: SizeType\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Rect.__new__","title":"__new__","text":"<pre><code>__new__(*, position: PositionType, size: SizeType) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    position: \"PositionType\",\n    size: \"SizeType\",\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Assets","title":"Assets","text":"<p>               Bases: <code>ABC</code></p> <p>tauri::Assets</p> <p>This is an abstract class that you can subclass to implement a custom asset loader.</p> <p>See <code>tauri::Assets</code> rust docs for more details.</p> <p>Warning</p> <p>The implement has the same restrictions as App.run.</p> <p>Methods:</p> Name Description <code>get</code> <code>iter</code> <code>setup</code>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Assets.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key: _AssetKey) -&gt; Optional[bytes]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef get(self, key: _AssetKey, /) -&gt; Optional[bytes]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Assets.iter","title":"iter  <code>abstractmethod</code>","text":"<pre><code>iter() -&gt; Iterator[tuple[str, bytes]]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>@abstractmethod\ndef iter(self, /) -&gt; Iterator[tuple[str, bytes]]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.Assets.setup","title":"setup","text":"<pre><code>setup(_app: AppHandle) -&gt; object\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def setup(self, _app: AppHandle, /) -&gt; object:\n    return None\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.builder_factory","title":"builder_factory","text":"<pre><code>builder_factory(*args: Any, **kwargs: Any) -&gt; Builder\n</code></pre> <p>A factory function for creating a <code>Builder</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def builder_factory(*args: Any, **kwargs: Any) -&gt; Builder:\n    \"\"\"A factory function for creating a `Builder` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/lib/#pytauri.ffi.lib.context_factory","title":"context_factory","text":"<pre><code>context_factory(*args: Any, **kwargs: Any) -&gt; Context\n</code></pre> <p>A factory function for creating a <code>Context</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def context_factory(*args: Any, **kwargs: Any) -&gt; Context:\n    \"\"\"A factory function for creating a `Context` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/","title":"menu","text":""},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu","title":"pytauri.ffi.menu","text":"<p>tauri::menu</p> <p>Classes:</p> Name Description <code>Menu</code> <p>tauri::menu::Menu</p> <code>MenuItem</code> <p>tauri::menu::MenuItem</p> <code>Submenu</code> <p>tauri::menu::Submenu</p> <code>PredefinedMenuItem</code> <p>tauri::menu::PredefinedMenuItem</p> <code>CheckMenuItem</code> <p>tauri::menu::CheckMenuItem</p> <code>AboutMetadata</code> <p>tauri::menu::AboutMetadata</p> <code>IconMenuItem</code> <p>tauri::menu::IconMenuItem</p> <code>NativeIcon</code> <p>tauri::menu::NativeIcon</p> <code>ContextMenu</code> <p>tauri::menu::ContextMenu</p> <p>Attributes:</p> Name Type Description <code>MenuID</code> <p>tauri::menu::MenuID</p> <code>MenuEvent</code> <p>tauri::menu::MenuEvent</p> <code>MenuItemKind</code> <p>tauri::menu::MenuItemKind</p> <code>ImplContextMenu</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['AboutMetadata', 'CheckMenuItem', 'ContextMenu', 'IconMenuItem', 'ImplContextMenu', 'Menu', 'MenuEvent', 'MenuID', 'MenuItem', 'MenuItemKind', 'NativeIcon', 'PredefinedMenuItem', 'Submenu']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuID","title":"MenuID  <code>module-attribute</code>","text":"<pre><code>MenuID = TypeAliasType('MenuID', str)\n</code></pre> <p>tauri::menu::MenuID</p>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuEvent","title":"MenuEvent  <code>module-attribute</code>","text":"<pre><code>MenuEvent = TypeAliasType('MenuEvent', MenuID)\n</code></pre> <p>tauri::menu::MenuEvent</p>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.HELP_SUBMENU_ID","title":"HELP_SUBMENU_ID  <code>module-attribute</code>","text":"<pre><code>HELP_SUBMENU_ID: LiteralString\n</code></pre> <p>tauri::menu::HELP_SUBMENU_ID</p>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.WINDOW_SUBMENU_ID","title":"WINDOW_SUBMENU_ID  <code>module-attribute</code>","text":"<pre><code>WINDOW_SUBMENU_ID: LiteralString\n</code></pre> <p>tauri::menu::WINDOW_SUBMENU_ID</p>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItemKind","title":"MenuItemKind  <code>module-attribute</code>","text":"<pre><code>MenuItemKind = TypeAliasType('MenuItemKind', Union[MenuItem, Submenu, PredefinedMenuItem, CheckMenuItem, IconMenuItem])\n</code></pre> <p>tauri::menu::MenuItemKind</p>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.ImplContextMenu","title":"ImplContextMenu  <code>module-attribute</code>","text":"<pre><code>ImplContextMenu = TypeAliasType('ImplContextMenu', Union[Menu, Submenu])\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu","title":"Menu","text":"<p>tauri::menu::Menu</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_items</code> <code>with_id_and_items</code> <code>default</code> <code>app_handle</code> <code>id</code> <code>append</code> <code>append_items</code> <code>prepend</code> <code>prepend_items</code> <code>insert</code> <code>insert_items</code> <code>remove</code> <code>remove_at</code> <code>get</code> <code>items</code> <code>set_as_app_menu</code> <code>set_as_window_menu</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(cls, manager: ImplManager, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(manager: ImplManager, id: MenuID, /) -&gt; \"Menu\": ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.with_items","title":"with_items  <code>staticmethod</code>","text":"<pre><code>with_items(manager: ImplManager, items: Sequence[MenuItemKind]) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_items(\n    manager: ImplManager, items: Sequence[\"MenuItemKind\"], /\n) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.with_id_and_items","title":"with_id_and_items  <code>staticmethod</code>","text":"<pre><code>with_id_and_items(manager: ImplManager, id: MenuID, items: Sequence[MenuItemKind]) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_items(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.default","title":"default  <code>staticmethod</code>","text":"<pre><code>default(app_handle: AppHandle) -&gt; Menu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef default(app_handle: AppHandle, /) -&gt; \"Menu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.append","title":"append","text":"<pre><code>append(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.append_items","title":"append_items","text":"<pre><code>append_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.prepend","title":"prepend","text":"<pre><code>prepend(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.prepend_items","title":"prepend_items","text":"<pre><code>prepend_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.insert","title":"insert","text":"<pre><code>insert(item: MenuItemKind, position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert(self, item: \"MenuItemKind\", position: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.insert_items","title":"insert_items","text":"<pre><code>insert_items(items: Sequence[MenuItemKind], position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert_items(\n    self, items: Sequence[\"MenuItemKind\"], position: int, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.remove","title":"remove","text":"<pre><code>remove(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.remove_at","title":"remove_at","text":"<pre><code>remove_at(position: int) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove_at(self, position: int, /) -&gt; Optional[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.get","title":"get","text":"<pre><code>get(id: MenuID) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def get(self, id: MenuID, /) -&gt; Optional[\"MenuItemKind\"]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.items","title":"items","text":"<pre><code>items() -&gt; list[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def items(self, /) -&gt; list[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.set_as_app_menu","title":"set_as_app_menu","text":"<pre><code>set_as_app_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_as_app_menu(self, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Menu.set_as_window_menu","title":"set_as_window_menu","text":"<pre><code>set_as_window_menu(window: Window) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_as_window_menu(self, window: Window, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem","title":"MenuItem","text":"<p>tauri::menu::MenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, accelerator: Optional[str] = None) -&gt; MenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"MenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.MenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu","title":"Submenu","text":"<p>tauri::menu::Submenu</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_items</code> <code>with_id_and_items</code> <code>app_handle</code> <code>id</code> <code>append</code> <code>append_items</code> <code>prepend</code> <code>prepend_items</code> <code>insert</code> <code>insert_items</code> <code>remove</code> <code>remove_at</code> <code>get</code> <code>items</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(cls, manager: ImplManager, text: str, enabled: bool, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.with_items","title":"with_items  <code>staticmethod</code>","text":"<pre><code>with_items(manager: ImplManager, text: str, enabled: bool, items: Sequence[MenuItemKind]) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_items(\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.with_id_and_items","title":"with_id_and_items  <code>staticmethod</code>","text":"<pre><code>with_id_and_items(manager: ImplManager, id: MenuID, text: str, enabled: bool, items: Sequence[MenuItemKind]) -&gt; Submenu\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_items(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    items: Sequence[\"MenuItemKind\"],\n    /,\n) -&gt; \"Submenu\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.append","title":"append","text":"<pre><code>append(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.append_items","title":"append_items","text":"<pre><code>append_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def append_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.prepend","title":"prepend","text":"<pre><code>prepend(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.prepend_items","title":"prepend_items","text":"<pre><code>prepend_items(items: Sequence[MenuItemKind]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def prepend_items(self, items: Sequence[\"MenuItemKind\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.insert","title":"insert","text":"<pre><code>insert(item: MenuItemKind, position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert(self, item: \"MenuItemKind\", position: int, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.insert_items","title":"insert_items","text":"<pre><code>insert_items(items: Sequence[MenuItemKind], position: int) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def insert_items(\n    self, items: Sequence[\"MenuItemKind\"], position: int, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.remove","title":"remove","text":"<pre><code>remove(item: MenuItemKind) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove(self, item: \"MenuItemKind\", /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.remove_at","title":"remove_at","text":"<pre><code>remove_at(position: int) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def remove_at(self, position: int, /) -&gt; Optional[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.get","title":"get","text":"<pre><code>get(id: MenuID) -&gt; Optional[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def get(self, id: MenuID, /) -&gt; Optional[\"MenuItemKind\"]: ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.items","title":"items","text":"<pre><code>items() -&gt; list[MenuItemKind]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def items(self, /) -&gt; list[\"MenuItemKind\"]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.Submenu.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem","title":"PredefinedMenuItem","text":"<p>tauri::menu::PredefinedMenuItem</p> <p>Methods:</p> Name Description <code>separator</code> <code>copy</code> <code>cut</code> <code>paste</code> <code>select_all</code> <code>undo</code> <code>redo</code> <code>minimize</code> <code>maximize</code> <code>fullscreen</code> <code>hide</code> <code>hide_others</code> <code>show_all</code> <code>close_window</code> <code>quit</code> <code>about</code> <code>services</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.separator","title":"separator  <code>staticmethod</code>","text":"<pre><code>separator(manager: ImplManager) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef separator(manager: ImplManager, /) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.copy","title":"copy  <code>staticmethod</code>","text":"<pre><code>copy(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef copy(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.cut","title":"cut  <code>staticmethod</code>","text":"<pre><code>cut(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef cut(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.paste","title":"paste  <code>staticmethod</code>","text":"<pre><code>paste(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef paste(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.select_all","title":"select_all  <code>staticmethod</code>","text":"<pre><code>select_all(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef select_all(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.undo","title":"undo  <code>staticmethod</code>","text":"<pre><code>undo(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef undo(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.redo","title":"redo  <code>staticmethod</code>","text":"<pre><code>redo(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef redo(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.minimize","title":"minimize  <code>staticmethod</code>","text":"<pre><code>minimize(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef minimize(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.maximize","title":"maximize  <code>staticmethod</code>","text":"<pre><code>maximize(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef maximize(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.fullscreen","title":"fullscreen  <code>staticmethod</code>","text":"<pre><code>fullscreen(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef fullscreen(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.hide","title":"hide  <code>staticmethod</code>","text":"<pre><code>hide(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef hide(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.hide_others","title":"hide_others  <code>staticmethod</code>","text":"<pre><code>hide_others(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef hide_others(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.show_all","title":"show_all  <code>staticmethod</code>","text":"<pre><code>show_all(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef show_all(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.close_window","title":"close_window  <code>staticmethod</code>","text":"<pre><code>close_window(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef close_window(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.quit","title":"quit  <code>staticmethod</code>","text":"<pre><code>quit(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef quit(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.about","title":"about  <code>staticmethod</code>","text":"<pre><code>about(manager: ImplManager, text: Optional[str] = None, metadata: Optional[AboutMetadata] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef about(\n    manager: ImplManager,\n    text: Optional[str] = None,\n    metadata: Optional[\"AboutMetadata\"] = None,\n    /,\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.services","title":"services  <code>staticmethod</code>","text":"<pre><code>services(manager: ImplManager, text: Optional[str] = None) -&gt; PredefinedMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef services(\n    manager: ImplManager, text: Optional[str] = None, /\n) -&gt; \"PredefinedMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.PredefinedMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem","title":"CheckMenuItem","text":"<p>tauri::menu::CheckMenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code> <code>is_checked</code> <code>set_checked</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, checked: bool, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    checked: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, checked: bool, accelerator: Optional[str] = None) -&gt; CheckMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    checked: bool,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"CheckMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.is_checked","title":"is_checked","text":"<pre><code>is_checked() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_checked(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.CheckMenuItem.set_checked","title":"set_checked","text":"<pre><code>set_checked(checked: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_checked(self, checked: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.AboutMetadata","title":"AboutMetadata","text":"<p>tauri::menu::AboutMetadata</p> <p>Methods:</p> Name Description <code>__new__</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.AboutMetadata.__new__","title":"__new__","text":"<pre><code>__new__(*, name: Optional[str] = None, version: Optional[str] = None, short_version: Optional[str] = None, authors: Optional[Sequence[str]] = None, comments: Optional[str] = None, copyright: Optional[str] = None, license: Optional[str] = None, website: Optional[str] = None, website_label: Optional[str] = None, credits: Optional[str] = None, icon: Optional[Image] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    name: Optional[str] = None,\n    version: Optional[str] = None,\n    short_version: Optional[str] = None,\n    authors: Optional[Sequence[str]] = None,\n    comments: Optional[str] = None,\n    copyright: Optional[str] = None,  # noqa: A002\n    license: Optional[str] = None,  # noqa: A002\n    website: Optional[str] = None,\n    website_label: Optional[str] = None,\n    credits: Optional[str] = None,  # noqa: A002\n    icon: Optional[\"Image\"] = None,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem","title":"IconMenuItem","text":"<p>tauri::menu::IconMenuItem</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>with_native_icon</code> <code>with_id_and_native_icon</code> <code>app_handle</code> <code>id</code> <code>text</code> <code>set_text</code> <code>is_enabled</code> <code>set_enabled</code> <code>set_accelerator</code> <code>set_icon</code> <code>set_native_icon</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager, text: str, enabled: bool, icon: Optional[Image] = None, accelerator: Optional[str] = None) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def __new__(\n    cls,\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    icon: Optional[\"Image\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: MenuID, text: str, enabled: bool, icon: Optional[Image] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    icon: Optional[\"Image\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.with_native_icon","title":"with_native_icon  <code>staticmethod</code>","text":"<pre><code>with_native_icon(manager: ImplManager, text: str, enabled: bool, native_icon: Optional[NativeIcon] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_native_icon(\n    manager: ImplManager,\n    text: str,\n    enabled: bool,\n    native_icon: Optional[\"NativeIcon\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.with_id_and_native_icon","title":"with_id_and_native_icon  <code>staticmethod</code>","text":"<pre><code>with_id_and_native_icon(manager: ImplManager, id: MenuID, text: str, enabled: bool, native_icon: Optional[NativeIcon] = None, accelerator: Optional[str] = None) -&gt; IconMenuItem\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef with_id_and_native_icon(\n    manager: ImplManager,\n    id: MenuID,  # noqa: A002\n    text: str,\n    enabled: bool,\n    native_icon: Optional[\"NativeIcon\"] = None,\n    accelerator: Optional[str] = None,\n    /,\n) -&gt; \"IconMenuItem\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.id","title":"id","text":"<pre><code>id() -&gt; MenuID\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def id(self, /) -&gt; MenuID: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def text(self, /) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.set_text","title":"set_text","text":"<pre><code>set_text(text: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_text(self, text: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def is_enabled(self, /) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.set_accelerator","title":"set_accelerator","text":"<pre><code>set_accelerator(accelerator: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_accelerator(self, accelerator: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Optional[Image]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_icon(self, icon: Optional[\"Image\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.IconMenuItem.set_native_icon","title":"set_native_icon","text":"<pre><code>set_native_icon(native_icon: Optional[NativeIcon]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>def set_native_icon(self, native_icon: Optional[\"NativeIcon\"], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon","title":"NativeIcon","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::menu::NativeIcon</p> <p>Warning</p> <p>This is actually a <code>Class</code> disguised as an <code>Enum</code>. The order of fields is not guaranteed. See also: https://pyo3.rs/v0.23.4/class.html#pyclass-enums.</p> <p>Attributes:</p> Name Type Description <code>Add</code> <code>Advanced</code> <code>Bluetooth</code> <code>Bookmarks</code> <code>Caution</code> <code>ColorPanel</code> <code>ColumnView</code> <code>Computer</code> <code>EnterFullScreen</code> <code>Everyone</code> <code>ExitFullScreen</code> <code>FlowView</code> <code>Folder</code> <code>FolderBurnable</code> <code>FolderSmart</code> <code>FollowLinkFreestanding</code> <code>FontPanel</code> <code>GoLeft</code> <code>GoRight</code> <code>Home</code> <code>IChatTheater</code> <code>IconView</code> <code>Info</code> <code>InvalidDataFreestanding</code> <code>LeftFacingTriangle</code> <code>ListView</code> <code>LockLocked</code> <code>LockUnlocked</code> <code>MenuMixedState</code> <code>MenuOnState</code> <code>MobileMe</code> <code>MultipleDocuments</code> <code>Network</code> <code>Path</code> <code>PreferencesGeneral</code> <code>QuickLook</code> <code>RefreshFreestanding</code> <code>Refresh</code> <code>Remove</code> <code>RevealFreestanding</code> <code>RightFacingTriangle</code> <code>Share</code> <code>Slideshow</code> <code>SmartBadge</code> <code>StatusAvailable</code> <code>StatusNone</code> <code>StatusPartiallyAvailable</code> <code>StatusUnavailable</code> <code>StopProgressFreestanding</code> <code>StopProgress</code> <code>TrashEmpty</code> <code>TrashFull</code> <code>User</code> <code>UserAccounts</code> <code>UserGroup</code> <code>UserGuest</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Add","title":"Add  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Add = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Advanced","title":"Advanced  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Advanced = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Bluetooth","title":"Bluetooth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Bluetooth = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Bookmarks","title":"Bookmarks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Bookmarks = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Caution","title":"Caution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Caution = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.ColorPanel","title":"ColorPanel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ColorPanel = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.ColumnView","title":"ColumnView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ColumnView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Computer","title":"Computer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Computer = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.EnterFullScreen","title":"EnterFullScreen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EnterFullScreen = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Everyone","title":"Everyone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Everyone = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.ExitFullScreen","title":"ExitFullScreen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ExitFullScreen = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.FlowView","title":"FlowView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FlowView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Folder","title":"Folder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Folder = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.FolderBurnable","title":"FolderBurnable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FolderBurnable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.FolderSmart","title":"FolderSmart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FolderSmart = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.FollowLinkFreestanding","title":"FollowLinkFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FollowLinkFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.FontPanel","title":"FontPanel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FontPanel = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.GoLeft","title":"GoLeft  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GoLeft = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.GoRight","title":"GoRight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GoRight = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Home","title":"Home  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Home = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.IChatTheater","title":"IChatTheater  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IChatTheater = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.IconView","title":"IconView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IconView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Info","title":"Info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Info = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.InvalidDataFreestanding","title":"InvalidDataFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>InvalidDataFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.LeftFacingTriangle","title":"LeftFacingTriangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LeftFacingTriangle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.ListView","title":"ListView  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ListView = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.LockLocked","title":"LockLocked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LockLocked = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.LockUnlocked","title":"LockUnlocked  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LockUnlocked = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.MenuMixedState","title":"MenuMixedState  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MenuMixedState = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.MenuOnState","title":"MenuOnState  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MenuOnState = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.MobileMe","title":"MobileMe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MobileMe = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.MultipleDocuments","title":"MultipleDocuments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MultipleDocuments = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Network","title":"Network  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Network = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Path","title":"Path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Path = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.PreferencesGeneral","title":"PreferencesGeneral  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PreferencesGeneral = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.QuickLook","title":"QuickLook  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QuickLook = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.RefreshFreestanding","title":"RefreshFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RefreshFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Refresh","title":"Refresh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Refresh = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Remove","title":"Remove  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Remove = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.RevealFreestanding","title":"RevealFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RevealFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.RightFacingTriangle","title":"RightFacingTriangle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RightFacingTriangle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Share","title":"Share  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Share = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.Slideshow","title":"Slideshow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Slideshow = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.SmartBadge","title":"SmartBadge  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SmartBadge = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StatusAvailable","title":"StatusAvailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusAvailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StatusNone","title":"StatusNone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusNone = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StatusPartiallyAvailable","title":"StatusPartiallyAvailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusPartiallyAvailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StatusUnavailable","title":"StatusUnavailable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StatusUnavailable = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StopProgressFreestanding","title":"StopProgressFreestanding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StopProgressFreestanding = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.StopProgress","title":"StopProgress  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>StopProgress = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.TrashEmpty","title":"TrashEmpty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TrashEmpty = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.TrashFull","title":"TrashFull  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TrashFull = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.User","title":"User  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>User = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.UserAccounts","title":"UserAccounts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserAccounts = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.UserGroup","title":"UserGroup  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserGroup = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.NativeIcon.UserGuest","title":"UserGuest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UserGuest = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.ContextMenu","title":"ContextMenu","text":"<p>tauri::menu::ContextMenu</p> <p>Methods:</p> Name Description <code>popup</code> <code>popup_at</code>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.ContextMenu.popup","title":"popup  <code>staticmethod</code>","text":"<pre><code>popup(slf: ImplContextMenu, window: Window) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef popup(slf: \"ImplContextMenu\", window: Window, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/menu/#pytauri.ffi.menu.ContextMenu.popup_at","title":"popup_at  <code>staticmethod</code>","text":"<pre><code>popup_at(slf: ImplContextMenu, window: Window, position: PositionType) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/menu.py</code> <pre><code>@staticmethod\ndef popup_at(\n    slf: \"ImplContextMenu\", window: Window, position: PositionType, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/","title":"tray","text":""},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray","title":"pytauri.ffi.tray","text":"<p>tauri::tray</p> <p>Classes:</p> Name Description <code>TrayIcon</code> <p>tauri::tray::TrayIcon</p> <code>TrayIconEvent</code> <p>tauri::tray::TrayIconEvent</p> <code>MouseButton</code> <p>tauri::tray::MouseButton</p> <code>MouseButtonState</code> <p>tauri::tray::MouseButtonState</p> <p>Attributes:</p> Name Type Description <code>TrayIconId</code> <p>tauri::tray::TrayIconId</p> <code>TrayIconEventType</code> <p>See TrayIconEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['MouseButton', 'MouseButtonState', 'TrayIcon', 'TrayIconEvent', 'TrayIconEventType', 'TrayIconId']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconId","title":"TrayIconId  <code>module-attribute</code>","text":"<pre><code>TrayIconId = TypeAliasType('TrayIconId', str)\n</code></pre> <p>tauri::tray::TrayIconId</p>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEventType","title":"TrayIconEventType  <code>module-attribute</code>","text":"<pre><code>TrayIconEventType = TypeAliasType('TrayIconEventType', Union[Click, DoubleClick, Enter, Move, Leave])\n</code></pre> <p>See TrayIconEvent for details.</p>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon","title":"TrayIcon","text":"<p>tauri::tray::TrayIcon</p> <p>Methods:</p> Name Description <code>__new__</code> <code>with_id</code> <code>app_handle</code> <code>on_menu_event</code> <p>This is an alias for pytauri.ffi.AppHandle.on_menu_event.</p> <code>on_tray_icon_event</code> <p>Set a handler for this tray icon events.</p> <code>id</code> <code>set_icon</code> <code>set_menu</code> <code>set_tooltip</code> <code>set_title</code> <code>set_visible</code> <code>set_temp_dir_path</code> <code>set_icon_as_template</code> <code>set_show_menu_on_left_click</code> <code>rect</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.__new__","title":"__new__","text":"<pre><code>__new__(manager: ImplManager) -&gt; Self\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def __new__(cls, manager: ImplManager, /) -&gt; Self: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.with_id","title":"with_id  <code>staticmethod</code>","text":"<pre><code>with_id(manager: ImplManager, id: TrayIconId) -&gt; TrayIcon\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>@staticmethod\ndef with_id(manager: ImplManager, id: TrayIconId, /) -&gt; \"TrayIcon\": ...  # noqa: A002\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.app_handle","title":"app_handle","text":"<pre><code>app_handle() -&gt; AppHandle\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def app_handle(self, /) -&gt; AppHandle: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[AppHandle, MenuEvent], None]) -&gt; None\n</code></pre> <p>This is an alias for pytauri.ffi.AppHandle.on_menu_event.</p> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[AppHandle, MenuEvent], None], /\n) -&gt; None:\n    \"\"\"This is an alias for [pytauri.ffi.AppHandle.on_menu_event][].\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.on_tray_icon_event","title":"on_tray_icon_event","text":"<pre><code>on_tray_icon_event(handler: Callable[[Self, TrayIconEventType], None]) -&gt; None\n</code></pre> <p>Set a handler for this tray icon events.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def on_tray_icon_event(\n    self, handler: Callable[[Self, \"TrayIconEventType\"], None], /\n) -&gt; None:\n    \"\"\"Set a handler for this tray icon events.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.id","title":"id","text":"<pre><code>id() -&gt; TrayIconId\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def id(self, /) -&gt; TrayIconId: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Optional[Image]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_icon(self, icon: Optional[Image], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Optional[ImplContextMenu]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_menu(self, menu: Optional[ImplContextMenu], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_tooltip","title":"set_tooltip","text":"<pre><code>set_tooltip(tooltip: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_tooltip(self, tooltip: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_title","title":"set_title","text":"<pre><code>set_title(title: Optional[str]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_title(self, title: Optional[str], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_visible","title":"set_visible","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_visible(self, visible: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_temp_dir_path","title":"set_temp_dir_path","text":"<pre><code>set_temp_dir_path(path: Optional[_ToPyo3Path]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_temp_dir_path(self, path: Optional[_ToPyo3Path], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_icon_as_template","title":"set_icon_as_template","text":"<pre><code>set_icon_as_template(is_template: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_icon_as_template(self, is_template: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.set_show_menu_on_left_click","title":"set_show_menu_on_left_click","text":"<pre><code>set_show_menu_on_left_click(enable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def set_show_menu_on_left_click(self, enable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIcon.rect","title":"rect","text":"<pre><code>rect() -&gt; Optional[Rect]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/tray.py</code> <pre><code>def rect(self, /) -&gt; Optional[Rect]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent","title":"TrayIconEvent","text":"<p>tauri::tray::TrayIconEvent</p> <p>Classes:</p> Name Description <code>Click</code> <p>tauri::tray::TrayIconEvent::Click</p> <code>DoubleClick</code> <p>tauri::tray::TrayIconEvent::DoubleClick</p> <code>Enter</code> <p>tauri::tray::TrayIconEvent::Enter</p> <code>Move</code> <p>tauri::tray::TrayIconEvent::Move</p> <code>Leave</code> <p>tauri::tray::TrayIconEvent::Leave</p>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click","title":"Click","text":"<p>tauri::tray::TrayIconEvent::Click</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PyPhysicalPositionF64</code> <code>rect</code> <code>Rect</code> <code>button</code> <code>MouseButton</code> <code>button_state</code> <code>MouseButtonState</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click.position","title":"position  <code>property</code>","text":"<pre><code>position: _PyPhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click.button","title":"button  <code>property</code>","text":"<pre><code>button: MouseButton\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Click.button_state","title":"button_state  <code>property</code>","text":"<pre><code>button_state: MouseButtonState\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.DoubleClick","title":"DoubleClick","text":"<p>tauri::tray::TrayIconEvent::DoubleClick</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PyPhysicalPositionF64</code> <code>rect</code> <code>Rect</code> <code>button</code> <code>MouseButton</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.DoubleClick.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.DoubleClick.position","title":"position  <code>property</code>","text":"<pre><code>position: _PyPhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.DoubleClick.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.DoubleClick.button","title":"button  <code>property</code>","text":"<pre><code>button: MouseButton\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Enter","title":"Enter","text":"<p>tauri::tray::TrayIconEvent::Enter</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PyPhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Enter.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Enter.position","title":"position  <code>property</code>","text":"<pre><code>position: _PyPhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Enter.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Move","title":"Move","text":"<p>tauri::tray::TrayIconEvent::Move</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PyPhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Move.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Move.position","title":"position  <code>property</code>","text":"<pre><code>position: _PyPhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Move.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Leave","title":"Leave","text":"<p>tauri::tray::TrayIconEvent::Leave</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>TrayIconId</code> <code>position</code> <code>_PyPhysicalPositionF64</code> <code>rect</code> <code>Rect</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Leave.id","title":"id  <code>property</code>","text":"<pre><code>id: TrayIconId\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Leave.position","title":"position  <code>property</code>","text":"<pre><code>position: _PyPhysicalPositionF64\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.TrayIconEvent.Leave.rect","title":"rect  <code>property</code>","text":"<pre><code>rect: Rect\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButton","title":"MouseButton","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::tray::MouseButton</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Left</code> <code>Right</code> <code>Middle</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButton.Left","title":"Left  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Left = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButton.Right","title":"Right  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Right = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButton.Middle","title":"Middle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Middle = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButtonState","title":"MouseButtonState","text":"<p>               Bases: <code>Enum</code></p> <p>tauri::tray::MouseButtonState</p> <p>Warning</p> <p>See pytauri.ffi.menu.NativeIcon.</p> <p>Attributes:</p> Name Type Description <code>Up</code> <code>Down</code>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButtonState.Up","title":"Up  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Up = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/tray/#pytauri.ffi.tray.MouseButtonState.Down","title":"Down  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Down = auto()\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/","title":"webview","text":""},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview","title":"pytauri.ffi.webview","text":"<p>tauri::webview</p> <p>Classes:</p> Name Description <code>WebviewWindow</code> <p>tauri::webview::WebviewWindow</p> <code>Webview</code> <p>tauri::webview::Webview</p>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Webview', 'WebviewWindow']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow","title":"WebviewWindow","text":"<p>tauri::webview::WebviewWindow</p> <p>Methods:</p> Name Description <code>run_on_main_thread</code> <p>Runs the given closure on the main thread.</p> <code>label</code> <code>on_menu_event</code> <p>Registers a global menu event listener.</p> <code>menu</code> <code>set_menu</code> <code>remove_menu</code> <code>hide_menu</code> <code>show_menu</code> <code>is_menu_visible</code> <code>popup_menu</code> <code>popup_menu_at</code> <code>is_fullscreen</code> <code>is_minimized</code> <code>is_maximized</code> <code>is_focused</code> <code>is_decorated</code> <code>is_resizable</code> <code>is_enabled</code> <code>is_maximizable</code> <code>is_minimizable</code> <code>is_closable</code> <code>is_visible</code> <code>title</code> <code>center</code> <code>set_resizable</code> <code>set_enabled</code> <code>set_maximizable</code> <code>set_minimizable</code> <code>set_closable</code> <code>set_title</code> <code>maximize</code> <code>unmaximize</code> <code>minimize</code> <code>unminimize</code> <code>show</code> <code>hide</code> <code>close</code> <code>destroy</code> <code>set_decorations</code> <code>set_shadow</code> <code>set_always_on_bottom</code> <code>set_always_on_top</code> <code>set_visible_on_all_workspaces</code> <code>set_content_protected</code> <code>set_fullscreen</code> <code>set_focus</code> <code>set_icon</code> <code>set_skip_taskbar</code> <code>set_cursor_grab</code> <code>set_cursor_visible</code> <code>set_ignore_cursor_events</code> <code>start_dragging</code> <code>set_badge_count</code> <code>print</code> <code>url</code> <code>eval</code> <code>set_zoom</code> <code>clear_all_browsing_data</code> <code>as_ref_webview</code>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.run_on_main_thread","title":"run_on_main_thread","text":"<pre><code>run_on_main_thread(handler: Callable[[], object]) -&gt; None\n</code></pre> <p>Runs the given closure on the main thread.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def run_on_main_thread(self, handler: Callable[[], object], /) -&gt; None:\n    \"\"\"Runs the given closure on the main thread.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.label","title":"label","text":"<pre><code>label() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def label(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.on_menu_event","title":"on_menu_event","text":"<pre><code>on_menu_event(handler: Callable[[Self, MenuEvent], None]) -&gt; None\n</code></pre> <p>Registers a global menu event listener.</p> <p>Warning</p> <p><code>handler</code> has the same restrictions as App.run.</p> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def on_menu_event(\n    self, handler: Callable[[\"Self\", \"MenuEvent\"], None], /\n) -&gt; None:\n    \"\"\"Registers a global menu event listener.\n\n    !!! warning\n        `handler` has the same restrictions as [App.run][pytauri.App.run].\n    \"\"\"\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.menu","title":"menu","text":"<pre><code>menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_menu","title":"set_menu","text":"<pre><code>set_menu(menu: Menu) -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_menu(self, menu: Menu, /) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.remove_menu","title":"remove_menu","text":"<pre><code>remove_menu() -&gt; Optional[Menu]\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def remove_menu(self) -&gt; Optional[Menu]: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.hide_menu","title":"hide_menu","text":"<pre><code>hide_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def hide_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.show_menu","title":"show_menu","text":"<pre><code>show_menu() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def show_menu(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_menu_visible","title":"is_menu_visible","text":"<pre><code>is_menu_visible() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_menu_visible(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.popup_menu","title":"popup_menu","text":"<pre><code>popup_menu(menu: ImplContextMenu) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def popup_menu(self, menu: ImplContextMenu, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.popup_menu_at","title":"popup_menu_at","text":"<pre><code>popup_menu_at(menu: ImplContextMenu, position: PositionType) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def popup_menu_at(\n    self, menu: ImplContextMenu, position: PositionType, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_fullscreen","title":"is_fullscreen","text":"<pre><code>is_fullscreen() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_fullscreen(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_minimized","title":"is_minimized","text":"<pre><code>is_minimized() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_minimized(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_maximized","title":"is_maximized","text":"<pre><code>is_maximized() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_maximized(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_focused","title":"is_focused","text":"<pre><code>is_focused() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_focused(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_decorated","title":"is_decorated","text":"<pre><code>is_decorated() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_decorated(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_resizable","title":"is_resizable","text":"<pre><code>is_resizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_resizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_enabled(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_maximizable","title":"is_maximizable","text":"<pre><code>is_maximizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_maximizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_minimizable","title":"is_minimizable","text":"<pre><code>is_minimizable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_minimizable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_closable","title":"is_closable","text":"<pre><code>is_closable() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_closable(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.is_visible","title":"is_visible","text":"<pre><code>is_visible() -&gt; bool\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def is_visible(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.title","title":"title","text":"<pre><code>title() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def title(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.center","title":"center","text":"<pre><code>center() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def center(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_resizable","title":"set_resizable","text":"<pre><code>set_resizable(resizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_resizable(self, resizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_enabled","title":"set_enabled","text":"<pre><code>set_enabled(enabled: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_enabled(self, enabled: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_maximizable","title":"set_maximizable","text":"<pre><code>set_maximizable(maximizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_maximizable(self, maximizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_minimizable","title":"set_minimizable","text":"<pre><code>set_minimizable(minimizable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_minimizable(self, minimizable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_closable","title":"set_closable","text":"<pre><code>set_closable(closable: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_closable(self, closable: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_title","title":"set_title","text":"<pre><code>set_title(title: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_title(self, title: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.maximize","title":"maximize","text":"<pre><code>maximize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def maximize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.unmaximize","title":"unmaximize","text":"<pre><code>unmaximize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def unmaximize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.minimize","title":"minimize","text":"<pre><code>minimize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def minimize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.unminimize","title":"unminimize","text":"<pre><code>unminimize() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def unminimize(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def show(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def hide(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def close(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.destroy","title":"destroy","text":"<pre><code>destroy() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def destroy(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_decorations","title":"set_decorations","text":"<pre><code>set_decorations(decorations: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_decorations(self, decorations: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_shadow","title":"set_shadow","text":"<pre><code>set_shadow(shadow: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_shadow(self, shadow: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_always_on_bottom","title":"set_always_on_bottom","text":"<pre><code>set_always_on_bottom(always_on_bottom: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_always_on_bottom(self, always_on_bottom: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_always_on_top","title":"set_always_on_top","text":"<pre><code>set_always_on_top(always_on_top: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_always_on_top(self, always_on_top: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_visible_on_all_workspaces","title":"set_visible_on_all_workspaces","text":"<pre><code>set_visible_on_all_workspaces(visible_on_all_workspaces: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_visible_on_all_workspaces(\n    self, visible_on_all_workspaces: bool, /\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_content_protected","title":"set_content_protected","text":"<pre><code>set_content_protected(protected: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_content_protected(self, protected: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_fullscreen","title":"set_fullscreen","text":"<pre><code>set_fullscreen(fullscreen: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_fullscreen(self, fullscreen: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_focus","title":"set_focus","text":"<pre><code>set_focus() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_focus(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_icon","title":"set_icon","text":"<pre><code>set_icon(icon: Image) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_icon(self, icon: Image, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_skip_taskbar","title":"set_skip_taskbar","text":"<pre><code>set_skip_taskbar(skip: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_skip_taskbar(self, skip: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_cursor_grab","title":"set_cursor_grab","text":"<pre><code>set_cursor_grab(grab: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_cursor_grab(self, grab: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_cursor_visible","title":"set_cursor_visible","text":"<pre><code>set_cursor_visible(visible: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_cursor_visible(self, visible: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_ignore_cursor_events","title":"set_ignore_cursor_events","text":"<pre><code>set_ignore_cursor_events(ignore: bool) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_ignore_cursor_events(self, ignore: bool, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.start_dragging","title":"start_dragging","text":"<pre><code>start_dragging() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def start_dragging(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_badge_count","title":"set_badge_count","text":"<pre><code>set_badge_count(count: Optional[int]) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_badge_count(self, count: Optional[int], /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.print","title":"print","text":"<pre><code>print() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def print(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.url","title":"url","text":"<pre><code>url() -&gt; str\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def url(self) -&gt; str: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.eval","title":"eval","text":"<pre><code>eval(js: str) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def eval(self, js: str, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.set_zoom","title":"set_zoom","text":"<pre><code>set_zoom(scale_factor: float) -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def set_zoom(self, scale_factor: float, /) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.clear_all_browsing_data","title":"clear_all_browsing_data","text":"<pre><code>clear_all_browsing_data() -&gt; None\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def clear_all_browsing_data(self) -&gt; None: ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.WebviewWindow.as_ref_webview","title":"as_ref_webview","text":"<pre><code>as_ref_webview() -&gt; Webview\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def as_ref_webview(self) -&gt; \"Webview\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.Webview","title":"Webview","text":"<p>tauri::webview::Webview</p> <p>Methods:</p> Name Description <code>window</code>"},{"location":"reference/py/pytauri/ffi/webview/#pytauri.ffi.webview.Webview.window","title":"window","text":"<pre><code>window() -&gt; Window\n</code></pre> Source code in <code>python/pytauri/src/pytauri/ffi/webview.py</code> <pre><code>def window(self) -&gt; \"Window\": ...\n</code></pre>"},{"location":"reference/py/pytauri/ffi/window/","title":"window","text":""},{"location":"reference/py/pytauri/ffi/window/#pytauri.ffi.window","title":"pytauri.ffi.window","text":"<p>tauri::window</p> <p>Classes:</p> Name Description <code>Window</code> <p>tauri::Window</p>"},{"location":"reference/py/pytauri/ffi/window/#pytauri.ffi.window.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Window']\n</code></pre>"},{"location":"reference/py/pytauri/ffi/window/#pytauri.ffi.window.Window","title":"Window","text":"<p>tauri::Window</p>"},{"location":"reference/py/pytauri_plugin_notification/","title":"pytauri_plugin_notification","text":""},{"location":"reference/py/pytauri_plugin_notification/#pytauri_plugin_notification","title":"pytauri_plugin_notification","text":"<p>tauri_plugin_notification::self</p> <p>Modules:</p> Name Description <code>ffi</code> <p>Original FFI interface module.</p> <p>Classes:</p> Name Description <code>NotificationBuilder</code> <p>tauri_plugin_notification::NotificationBuilder</p> <code>NotificationExt</code> <p>tauri_plugin_notification::NotificationExt</p> <p>Attributes:</p> Name Type Description <code>ImplNotificationExt</code> <code>TypeAlias</code> <p>The implementors of <code>NotificationExt</code>.</p>"},{"location":"reference/py/pytauri_plugin_notification/#pytauri_plugin_notification.ImplNotificationExt","title":"ImplNotificationExt  <code>module-attribute</code>","text":"<pre><code>ImplNotificationExt: TypeAlias = ImplManager\n</code></pre> <p>The implementors of <code>NotificationExt</code>.</p>"},{"location":"reference/py/pytauri_plugin_notification/#pytauri_plugin_notification.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ImplNotificationExt', 'NotificationBuilder', 'NotificationExt']\n</code></pre>"},{"location":"reference/py/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationBuilder","title":"NotificationBuilder","text":"<p>tauri_plugin_notification::NotificationBuilder</p> <p>Methods:</p> Name Description <code>show</code> <p>Consume this builder and show the notification.</p>"},{"location":"reference/py/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationBuilder.show","title":"show","text":"<pre><code>show(*, id: Optional[int] = None, channel_id: Optional[str] = None, title: Optional[str] = None, body: Optional[str] = None, large_body: Optional[str] = None, summary: Optional[str] = None, action_type_id: Optional[str] = None, group: Optional[str] = None, group_summary: bool = False, sound: Optional[str] = None, inbox_line: Optional[str] = None, icon: Optional[str] = None, large_icon: Optional[str] = None, icon_color: Optional[str] = None, ongoing: bool = False, auto_cancel: bool = False, silent: bool = False) -&gt; None\n</code></pre> <p>Consume this builder and show the notification.</p>"},{"location":"reference/py/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationBuilder.show--fixme-xxx-todo","title":"FIXME, XXX, TODO:","text":"<p>See: https://github.com/tauri-apps/tauri/issues/3700</p> <p>On windows, you must install the package via the <code>.msi</code> or <code>nsis</code>, or <code>tauri-plugin-notification</code> will not work.</p> <p>Tracker issue: https://github.com/tauri-apps/plugins-workspace/issues/2156</p> Source code in <code>python/pytauri-plugin-notification/src/pytauri_plugin_notification/ffi.py</code> <pre><code>def show(\n    self,\n    /,\n    *,\n    id: Optional[int] = None,  # noqa: A002\n    channel_id: Optional[str] = None,\n    title: Optional[str] = None,\n    body: Optional[str] = None,\n    large_body: Optional[str] = None,\n    summary: Optional[str] = None,\n    action_type_id: Optional[str] = None,\n    group: Optional[str] = None,\n    group_summary: bool = False,\n    sound: Optional[str] = None,\n    inbox_line: Optional[str] = None,\n    icon: Optional[str] = None,\n    large_icon: Optional[str] = None,\n    icon_color: Optional[str] = None,\n    ongoing: bool = False,\n    auto_cancel: bool = False,\n    silent: bool = False,\n) -&gt; None:\n    \"\"\"Consume this builder and show the notification.\n\n    # FIXME, XXX, TODO:\n\n    See: &lt;https://github.com/tauri-apps/tauri/issues/3700&gt;\n\n    On windows, you must install the package via the `.msi` or `nsis`, or `tauri-plugin-notification` will not work.\n\n    Tracker issue: &lt;https://github.com/tauri-apps/plugins-workspace/issues/2156&gt;\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationExt","title":"NotificationExt","text":"<p>tauri_plugin_notification::NotificationExt</p> <p>Methods:</p> Name Description <code>builder</code> <p>Create a new notification builder.</p>"},{"location":"reference/py/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationExt.builder","title":"builder  <code>staticmethod</code>","text":"<pre><code>builder(slf: ImplNotificationExt) -&gt; NotificationBuilder\n</code></pre> <p>Create a new notification builder.</p> Source code in <code>python/pytauri-plugin-notification/src/pytauri_plugin_notification/ffi.py</code> <pre><code>@staticmethod\ndef builder(slf: \"ImplNotificationExt\", /) -&gt; NotificationBuilder:\n    \"\"\"Create a new notification builder.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri_plugin_notification/ffi/","title":"ffi","text":""},{"location":"reference/py/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi","title":"pytauri_plugin_notification.ffi","text":"<p>Original FFI interface module.</p> <p>Warning</p> <p>All APIs under this module should not be considered stable. You should use the re-exported APIs under the top-level module.</p> <p>Classes:</p> Name Description <code>NotificationBuilder</code> <p>tauri_plugin_notification::NotificationBuilder</p> <code>NotificationExt</code> <p>tauri_plugin_notification::NotificationExt</p> <p>Attributes:</p> Name Type Description <code>ImplNotificationExt</code> <code>TypeAlias</code> <p>The implementors of <code>NotificationExt</code>.</p>"},{"location":"reference/py/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ImplNotificationExt', 'NotificationBuilder', 'NotificationExt']\n</code></pre>"},{"location":"reference/py/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.ImplNotificationExt","title":"ImplNotificationExt  <code>module-attribute</code>","text":"<pre><code>ImplNotificationExt: TypeAlias = ImplManager\n</code></pre> <p>The implementors of <code>NotificationExt</code>.</p>"},{"location":"reference/py/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationBuilder","title":"NotificationBuilder","text":"<p>tauri_plugin_notification::NotificationBuilder</p> <p>Methods:</p> Name Description <code>show</code> <p>Consume this builder and show the notification.</p>"},{"location":"reference/py/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationBuilder.show","title":"show","text":"<pre><code>show(*, id: Optional[int] = None, channel_id: Optional[str] = None, title: Optional[str] = None, body: Optional[str] = None, large_body: Optional[str] = None, summary: Optional[str] = None, action_type_id: Optional[str] = None, group: Optional[str] = None, group_summary: bool = False, sound: Optional[str] = None, inbox_line: Optional[str] = None, icon: Optional[str] = None, large_icon: Optional[str] = None, icon_color: Optional[str] = None, ongoing: bool = False, auto_cancel: bool = False, silent: bool = False) -&gt; None\n</code></pre> <p>Consume this builder and show the notification.</p>"},{"location":"reference/py/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationBuilder.show--fixme-xxx-todo","title":"FIXME, XXX, TODO:","text":"<p>See: https://github.com/tauri-apps/tauri/issues/3700</p> <p>On windows, you must install the package via the <code>.msi</code> or <code>nsis</code>, or <code>tauri-plugin-notification</code> will not work.</p> <p>Tracker issue: https://github.com/tauri-apps/plugins-workspace/issues/2156</p> Source code in <code>python/pytauri-plugin-notification/src/pytauri_plugin_notification/ffi.py</code> <pre><code>def show(\n    self,\n    /,\n    *,\n    id: Optional[int] = None,  # noqa: A002\n    channel_id: Optional[str] = None,\n    title: Optional[str] = None,\n    body: Optional[str] = None,\n    large_body: Optional[str] = None,\n    summary: Optional[str] = None,\n    action_type_id: Optional[str] = None,\n    group: Optional[str] = None,\n    group_summary: bool = False,\n    sound: Optional[str] = None,\n    inbox_line: Optional[str] = None,\n    icon: Optional[str] = None,\n    large_icon: Optional[str] = None,\n    icon_color: Optional[str] = None,\n    ongoing: bool = False,\n    auto_cancel: bool = False,\n    silent: bool = False,\n) -&gt; None:\n    \"\"\"Consume this builder and show the notification.\n\n    # FIXME, XXX, TODO:\n\n    See: &lt;https://github.com/tauri-apps/tauri/issues/3700&gt;\n\n    On windows, you must install the package via the `.msi` or `nsis`, or `tauri-plugin-notification` will not work.\n\n    Tracker issue: &lt;https://github.com/tauri-apps/plugins-workspace/issues/2156&gt;\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/py/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationExt","title":"NotificationExt","text":"<p>tauri_plugin_notification::NotificationExt</p> <p>Methods:</p> Name Description <code>builder</code> <p>Create a new notification builder.</p>"},{"location":"reference/py/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationExt.builder","title":"builder  <code>staticmethod</code>","text":"<pre><code>builder(slf: ImplNotificationExt) -&gt; NotificationBuilder\n</code></pre> <p>Create a new notification builder.</p> Source code in <code>python/pytauri-plugin-notification/src/pytauri_plugin_notification/ffi.py</code> <pre><code>@staticmethod\ndef builder(slf: \"ImplNotificationExt\", /) -&gt; NotificationBuilder:\n    \"\"\"Create a new notification builder.\"\"\"\n    ...\n</code></pre>"},{"location":"usage/concepts/ipc/","title":"IPC","text":""},{"location":"usage/concepts/ipc/#calling-python-from-the-frontend","title":"Calling Python from the Frontend","text":"<p>Ref:</p> <ul> <li>https://tauri.app/develop/calling-rust/</li> <li>pytauri.ipc.Commands</li> </ul> <p>pytauri implements IPC API consistent with rust tauri. Reading tauri's documentation is like reading pytauri's documentation.</p>"},{"location":"usage/concepts/ipc/#commands","title":"Commands","text":""},{"location":"usage/concepts/ipc/#registering-commands","title":"Registering Commands","text":"<p>You can register a command handler using the decorator @Commands.command.</p> <p>Similar to <code>tauri::command!</code>, the <code>handler</code> signature can be arbitrary. We will use inspect.signature to inspect its signature and dynamically pass the required parameters.</p> <p>Info</p> <p>You might have seen this pattern in <code>FastAPI</code>\ud83e\udd13.</p> <p>The currently supported signature pattern is ArgumentsType. You must ensure that the parameter names and type annotations are correct, and <code>@Commands.command</code> will check them.</p> <pre><code># pyright: reportRedeclaration=none\n# ruff: noqa: F811\n\nfrom pytauri import AppHandle, Commands\n\ncommands = Commands()\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: bytes) -&gt; bytes: ...\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: bytes, app_handle: AppHandle) -&gt; bytes: ...\n\n\n# \ud83d\udca5 ERROR: missing/wrong type annotation\n@commands.command()\nasync def command(\n    body: bytes,\n    app_handle,  # pyright: ignore[reportUnknownParameterType, reportMissingParameterType]  # noqa: ANN001\n) -&gt; bytes: ...\n\n\n# \ud83d\udca5 ERROR: wrong parameter name\n@commands.command()\nasync def command(body: bytes, foo: AppHandle) -&gt; bytes: ...\n\n\n# \ud83d\udca5 ERROR: not an async function\n@commands.command()  # pyright: ignore[reportArgumentType, reportUntypedFunctionDecorator]\ndef command(body: bytes) -&gt; bytes: ...\n</code></pre>"},{"location":"usage/concepts/ipc/#deserializing-the-body","title":"Deserializing the Body","text":"<p>For the <code>body</code> argument, it is of type <code>bytes</code>, allowing you to pass binary data such as files between the frontend and backend.</p> <p>However, in most cases, we want strong type checking when calling. Rust <code>tauri</code> achieves this through <code>serde</code>, while <code>pytauri</code> uses pydantic.</p> <p>Info</p> <p><code>pydantic</code> is a super-fast Python validation and serialization library written in <code>rust</code>/<code>pyo3</code> \ud83e\udd13.</p> <p>If you use BaseModel/RootModel as the type annotation for the <code>body</code> parameter/return value, pytauri will automatically serialize/deserialize it for you:</p> <pre><code># pyright: reportRedeclaration=none\n# ruff: noqa: F811\n\nfrom pydantic import BaseModel, RootModel\nfrom pytauri import AppHandle, Commands\n\ncommands = Commands()\n\n\nclass Input(BaseModel):\n    foo: str\n    bar: int\n\n\nOutput = RootModel[list[str]]\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: Input, app_handle: AppHandle) -&gt; Output: ...\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: Input) -&gt; bytes: ...\n\n\n# \u2b50 OK\n@commands.command()\nasync def command(body: bytes) -&gt; Output: ...\n</code></pre>"},{"location":"usage/concepts/ipc/#generate-invoke-handler-for-app","title":"Generate Invoke Handler for App","text":"<p>To execute async commands, we need an async runtime. We use anyio.from_thread.BlockingPortal as the async runtime in a child thread (the main thread is used for the Tauri app's event loop).</p> <p>Refer to the anyio docs for more information.</p> <p>You can obtain a <code>BlockingPortal</code> as follows:</p> <ul> <li>anyio.from_thread.start_blocking_portal</li> <li>anyio.from_thread.BlockingPortalProvider</li> </ul> <p>After that, you generate an <code>invoke_handler</code> and pass it to the <code>App</code>, similar to Rust's <code>tauri::generate_handler</code>:</p> <pre><code>from anyio.from_thread import start_blocking_portal\nfrom pytauri import BuilderArgs, Commands, builder_factory, context_factory\n\ncommands = Commands()\n\n\nwith start_blocking_portal(\"asyncio\") as portal:  # or \"trio\"\n    builder = builder_factory()\n    app = builder.build(\n        BuilderArgs(\n            context_factory(),\n            # \ud83d\udc47\n            invoke_handler=commands.generate_handler(portal),\n        )\n    )\n    app.run()\n</code></pre> <p>The key point here is that you must not close the <code>BlockingPortal</code> (i.e., do not <code>exit</code> the context manager) while App.run is still running.</p> <p>If you want to obtain this <code>invoke_handler</code> and keep the <code>BlockingPortal</code> running, you can use contextlib.ExitStack to achieve this:</p> <pre><code>from contextlib import ExitStack\nfrom sys import exc_info\n\nfrom anyio.from_thread import start_blocking_portal\nfrom pytauri import Commands\n\ncommands = Commands()\n\nexit_stack = ExitStack()\nportal = exit_stack.enter_context(start_blocking_portal(\"asyncio\"))\n\n\n# \ud83d\udc49 the `invoke_handler` will keep available until the `ExitStack` is closed\ninvoke_handler = commands.generate_handler(portal)\n\n\"\"\"do some stuff ...\"\"\"\n\n# \ud83d\udc49 then remember to close the `ExitStack` to exit the portal\nexit_stack.__exit__(*exc_info())\n</code></pre> <p>You can also spawn tasks in the async runtime (in the child thread) from the main thread in a thread-safe manner using the <code>portal</code>: https://anyio.readthedocs.io/en/stable/threads.html#spawning-tasks-from-worker-threads</p>"},{"location":"usage/concepts/ipc/#calling-commands","title":"Calling Commands","text":"<pre><code>import { pyInvoke, rawPyInvoke } from \"tauri-plugin-pytauri-api\";\n// or if tauri config `app.withGlobalTauri = true`:\n//\n// ```js\n// const { pyInvoke, rawPyInvoke } = window.__TAURI__.pytauri;\n// ```\n\nconst output = await pyInvoke&lt;[string]&gt;(\"command\", { foo: \"foo\", bar: 42 });\n</code></pre> <p>The difference between <code>rawPyInvoke</code> and <code>pyInvoke</code> is that the input and output of <code>rawPyInvoke</code> are both <code>ArrayBuffer</code>, allowing you to pass binary data.</p>"},{"location":"usage/concepts/ipc/#returning-errors-to-the-frontend","title":"Returning Errors to the Frontend","text":"<p>Similar to <code>FastAPI</code>, as long as you throw an InvokeException in the <code>command</code>, the promise will reject with the error message.</p> <pre><code>from pytauri import Commands\nfrom pytauri.ipc import InvokeException\n\ncommands = Commands()\n\n\n@commands.command()\nasync def command() -&gt; bytes:\n    raise InvokeException(\"error message\")\n</code></pre>"},{"location":"usage/concepts/ipc/#calling-frontend-from-python","title":"Calling Frontend from Python","text":"<p>Ref:</p> <ul> <li>https://tauri.app/develop/calling-frontend/</li> <li>pytauri.ipc.JavaScriptChannelId and pytauri.ipc.Channel</li> <li>pytauri.webview.WebviewWindow.eval</li> </ul>"},{"location":"usage/concepts/ipc/#channels","title":"Channels","text":"<p>Channels are designed to be fast and deliver ordered data. They are used internally for streaming operations such as download progress, child process output, and WebSocket messages.</p> <p>To use a <code>channel</code>, you only need to add the JavaScriptChannelId field to the <code>BaseModel</code>/<code>RootModel</code>, and then use JavaScriptChannelId.channel_on to get a Channel instance.</p> <p>Info</p> <p><code>JavaScriptChannelId</code> itself is a <code>RootModel</code>, so you can directly use it as the <code>body</code> parameter.</p> <pre><code>from pydantic import RootModel\nfrom pytauri import Commands\nfrom pytauri.ipc import Channel, JavaScriptChannelId\nfrom pytauri.webview import WebviewWindow\n\ncommands = Commands()\n\nMsg = RootModel[str]\n\n\n@commands.command()\nasync def command(\n    body: JavaScriptChannelId[Msg], webview_window: WebviewWindow\n) -&gt; bytes:\n    channel: Channel[Msg] = body.channel_on(webview_window.as_ref_webview())\n\n    # \ud83d\udc47 you should do this as background task, here just keep it simple as a example\n    channel.send(b'\"message\"')\n    channel.send_model(Msg(\"message\"))\n\n    return b\"null\"\n</code></pre> <pre><code>import { pyInvoke, Channel } from \"tauri-plugin-pytauri-api\";\n// const { pyInvoke, Channel } = window.__TAURI__.pytauri;\n\nconst channel = new Channel&lt;string&gt;();\nchannel.addJsonListener((msg) =&gt; console.log(msg));\n\nawait pyInvoke(\"command\", channel);\n</code></pre> <p>Info</p> <p>The <code>Channel</code> in <code>tauri-plugin-pytauri-api</code> is just a subclass of the <code>Channel</code> in <code>@tauri-apps/api/event</code>.</p> <p>It adds the <code>addJsonListener</code> method to help serialize data. You can use <code>Channel.onmessage</code> to handle raw <code>ArrayBuffer</code> data.</p>"},{"location":"usage/concepts/ipc/#evaluating-javascript","title":"Evaluating JavaScript","text":"<p>You can use WebviewWindow.eval to evaluate JavaScript code in the frontend.</p>"},{"location":"usage/concepts/ipc/#event-system","title":"Event System","text":"<p>Ref:</p> <ul> <li>https://tauri.app/develop/calling-frontend/#event-system</li> <li>https://tauri.app/develop/calling-rust/#event-system</li> <li>pytauri.Listener</li> <li><code>pytauri.Emitter</code>: blocked on #61</li> </ul> <p>Tauri ships a simple event system you can use to have bi-directional communication between Rust and your frontend.</p> <p>The event system was designed for situations where small amounts of data need to be streamed or you need to implement a multi consumer multi producer pattern (e.g. push notification system).</p> <p>The event system is not designed for low latency or high throughput situations. See the channels section for the implementation optimized for streaming data.</p> <p>The major differences between a Tauri command and a Tauri event are that events have no strong type support, event payloads are always JSON strings making them not suitable for bigger messages and there is no support of the capabilities system to fine grain control event data and channels.</p> <p>See pytauri.Listener--example</p>"},{"location":"usage/concepts/mutiprocessing/","title":"Using multiprocessing","text":"<p>When building as a <code>standalone</code> app, <code>pytauri</code> will automatically configure the following to support the use of multiprocessing:</p> <p>ref: pytauri::standalone::PythonInterpreterBuilder</p> <ul> <li>Set <code>sys.frozen</code> to <code>True</code></li> <li>Call multiprocessing.set_start_method with<ul> <li>windows: <code>spawn</code></li> <li>unix: <code>fork</code></li> </ul> </li> <li>Call multiprocessing.set_executable with <code>std::env::current_exe()</code></li> </ul> <p>What you need to do is call multiprocessing.freeze_support in <code>__main__.py</code> or in the <code>if __name__ == \"__main__\":</code> block.</p> <p>If you don't do this, you will get an endless spawn loop of your application process.</p> <p>See: https://pyinstaller.org/en/v6.11.1/common-issues-and-pitfalls.html#multi-processing.</p>"},{"location":"usage/tutorial/","title":"Prerequisites","text":""},{"location":"usage/tutorial/#platforms","title":"Platforms","text":"<ul> <li>Tier 1: my(author's) primary development environment<ul> <li>Windows 10</li> </ul> </li> <li>Tier 2: will got bugs fixed and tested on ci<ul> <li>Linux (WSL2)</li> </ul> </li> <li>Tier 3: will not be tested, may not work<ul> <li>MacOS</li> <li>Windows 7</li> </ul> </li> </ul> <p>Info</p> <p>I do not have MacOS, so I cannot debug issues on MacOS. That is why it is in Tier 3.</p> <p>If you would like better support for MacOS, please consider becoming a maintainer.</p>"},{"location":"usage/tutorial/#python","title":"Python","text":"<p>We support all Python versions that are currently in their lifecycle. The current version is <code>&gt;= 3.9</code>.</p> <p>https://www.python.org/downloads/</p> <p>Warning</p> <p>For linux development, you need to ensure that your Python installation contains a shared library.</p> <p>To install the Python shared library on Ubuntu: <code>sudo apt install python3-dev</code>.</p> <p>To install the Python shared library on RPM based distributions (e.g. Fedora, Red Hat, SuSE), install the <code>python3-devel</code> package.</p>"},{"location":"usage/tutorial/#rust","title":"Rust","text":"<p>The latest stable version.</p> <p>https://www.rust-lang.org/tools/install</p> <p>for python developers</p> <p>You can upgrade your existing Rust version by running <code>rustup update stable</code>.</p>"},{"location":"usage/tutorial/#system-dependencies","title":"System Dependencies","text":"<ul> <li>Tauri Prerequisites</li> </ul>"},{"location":"usage/tutorial/build-sdist/","title":"Build python source (sdist) distribution","text":""},{"location":"usage/tutorial/build-sdist/#setuptools-rust","title":"setuptools-rust","text":"<p>When you want to distribute your app in Python format, you need to compile pytauri into a Python extension module file, instead of providing it in memory through <code>pytauri::standalone::append_ext_mod</code> in the <code>main.rs</code> executable.</p> <p>To do this, we need to use setuptools-rust.</p> <p>Add it to <code>[build-system]</code>:</p> src-tauri/pyproject.toml<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61\", \"setuptools-rust==1.*\"]\nbuild-backend = \"setuptools.build_meta\"\n</code></pre> <p>And add the following file:</p> src-tauri/setup.py<pre><code>\"\"\"See: &lt;https://setuptools-rust.readthedocs.io/en/latest/setuppy_tutorial.html&gt;\"\"\"\n\nfrom os import getenv\n\nfrom setuptools import setup\nfrom setuptools_rust import RustExtension\n\nPYTAURI_STANDALONE = getenv(\"PYTAURI_STANDALONE\") == \"1\"\n\"\"\"Instead of building pytauri as an extension module file, it will be loaded in memory through Rust's `append_ext_mod`\"\"\"\n\nsetup(\n    rust_extensions=[\n        RustExtension(\n            # set `target` the same as `[project.entry-points.pytauri.ext_mod]` in `pyproject.toml`\n            target=\"tauri_app.ext_mod\",\n            # It is recommended to set other features in `Cargo.toml`, except the following features:\n            features=[\n                # see: &lt;https://pyo3.rs/v0.23.3/building-and-distribution.html#the-extension-module-feature&gt;,\n                # required to build the extension module\n                \"pyo3/extension-module\",\n                # This feature tells Tauri to use embedded frontend assets instead of using a frontend development server.\n                # Usually, this feature is enabled by `tauri-cli`, here we enable it manually.\n                \"tauri/custom-protocol\",\n            ],\n        )\n    ]\n    if not PYTAURI_STANDALONE\n    else [],\n)\n</code></pre>"},{"location":"usage/tutorial/build-sdist/#include-frontend-assets","title":"Include frontend assets","text":"<p>You need to include the frontend assets in the sdist so that users can build your app from the source.</p> <p>Configure Vite to output the frontend assets to <code>src-tauri/frontend</code>:</p> vite.config.ts<pre><code>// https://vitejs.dev/config/\nexport default defineConfig(async () =&gt; ({\n  build: {\n    // build dist into `src-tauri/` so that we can include it in Python sdist\n    outDir: \"src-tauri/frontend\",\n  },\n}));\n</code></pre> <p>Also, let tauri-cli know where the frontend assets are:</p> src-tauri/tauri.conf.json<pre><code>{\n  \"build\": {\n    \"frontendDist\": \"./frontend\"\n  },\n}\n</code></pre> <p>Include the frontend assets in the sdist:</p> <p>ref: https://setuptools.pypa.io/en/latest/userguide/miscellaneous.html</p> src-tauri/MANIFEST.in<pre><code>graft frontend/\n</code></pre>"},{"location":"usage/tutorial/build-sdist/#include-rust-files","title":"Include rust files","text":"<p>You will also need to tell Setuptools that the Rust files are required to build your project from the source distribution. That can be done either via <code>MANIFEST.in</code> or via a plugin like setuptools-scm.</p> setuptools-scmMANIFEST.in <p>Use <code>setuptools-scm</code> to include all files tracked by <code>git</code> (just add it as a dependency):</p> src-tauri/pyproject.toml<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61\", \"setuptools-rust==1.*\", \"setuptools_scm&gt;=8\"]\nbuild-backend = \"setuptools.build_meta\"\n</code></pre> <p>Info</p> <p>Normally, we do not track <code>src-tauri/frontend</code>, which is why we use <code>MANIFEST.in</code> to include it.</p> src-tauri/MANIFEST.in<pre><code>graft frontend/\ngraft capabilities/\ngraft icons/\ngraft src/\ninclude Cargo.toml\ninclude Cargo.lock\ninclude build.rs\ninclude tauri.conf.json\n</code></pre>"},{"location":"usage/tutorial/build-sdist/#build-sdist","title":"Build sdist","text":"<ul> <li> <p>Build frontend assets first: <code>pnpm build</code> (see <code>build.beforeBuildCommand</code> in <code>tau.conf.json</code>).</p> </li> <li> <p>Now you can build only sdist: <code>uv build src-tauri --sdist</code>.</p> <ul> <li>Or build both wheel and sdist: <code>uv build src-tauri</code>.</li> </ul> <p>Tip</p> <p>As long as you can build the wheel with <code>uv build src-tauri</code>, it means your Python sdist can be used normally. Otherwise, you might have forgotten to include some Rust files.</p> </li> </ul>"},{"location":"usage/tutorial/build-standalone/","title":"Build standalone binary","text":"<p>pytauri can be distributed as a Python wheel or compiled into a standalone executable (a regular Tauri application).</p> <p>Unlike packaging with <code>pyinstaller</code> after building as a wheel, compiling pytauri into an executable allows you to enjoy all the benefits brought by <code>tauri-cli</code>.</p>"},{"location":"usage/tutorial/build-standalone/#get-portable-python","title":"Get portable Python","text":"<p>We will bundle python-build-standalone as a portable Python for distribution.</p> <p>Please download the Python version you need. Usually, you will use these versions:</p> <ul> <li><code>cpython-*-x86_64-pc-windows-msvc-install_only_stripped.tar.gz</code></li> <li><code>cpython-*-x86_64-unknown-linux-gnu-install_only_stripped.tar.gz</code></li> <li><code>cpython-*-x86_64-apple-darwin-install_only_stripped.tar.gz</code></li> </ul> <p>Extract it to <code>src-tauri/pyembed</code>, make sure the file layout is as follows:</p> windowsunix <pre><code>\u251c\u2500\u2500 src-tauri/pyembed/python\n    \u251c\u2500\u2500 python.exe\n    \u251c\u2500\u2500 python3.dll\n    \u2514\u2500\u2500 ...\n</code></pre> <pre><code>\u251c\u2500\u2500 src-tauri/pyembed/python\n    \u251c\u2500\u2500 bin/\n    \u251c\u2500\u2500 include/\n    \u251c\u2500\u2500 lib/\n    \u2514\u2500\u2500 share/\n</code></pre> <p>Tell <code>tauri-cli</code> to ignore it during <code>tauri dev</code>:</p> src-tauri/.taurignore<pre><code># ...\n/pyembed/\n</code></pre> <p>Tip</p> <p>If you are using an IDE based on <code>pyright</code>/<code>pylance</code>, please create a <code>pyproject.toml</code> file in the root directory of your project (not <code>src-tauri/pyproject.toml</code>) and add the following configuration to tell <code>pyright</code> not to analyze <code>src-tauri/pyembed</code>, as it will consume a large amount of memory:</p> pyproject.toml<pre><code>[tool.pyright]\n# see: &lt;https://github.com/microsoft/pyright/blob/1.1.391/docs/configuration.md#environment-options&gt;\nexclude = [\n    \"**/node_modules\",\n    \"**/__pycache__\",\n    # \ud83d\udc47 necessary, because when `tauri-cli bundles python,\n    # it will copy `pyembed` to the target directory (i.e., rust output dir).\n    \"**/target\",\n    # \ud83d\udc46\n    \"**/dist\",\n    \"**/.venv\",\n    \"**/.*\",\n    \"src-tauri/pyembed/\",\n    \"src-tauri/frontend/\",\n]\n</code></pre>"},{"location":"usage/tutorial/build-standalone/#install-your-project-into-the-embedded-python-environment","title":"Install your project into the embedded Python environment","text":"windowsunix <pre><code>$env:PYTAURI_STANDALONE=\"1\"  # see `setup.py`\n\n# `tauri-app` is your python package name.\nuv pip install `\n    --exact `\n    --python=\".\\src-tauri\\pyembed\\python\\python.exe\" `\n    --reinstall-package=tauri-app `\n    .\\src-tauri\n</code></pre> <pre><code>export PYTAURI_STANDALONE=\"1\"  # see `setup.py`\n\n# `tauri-app` is your python package name.\nuv pip install \\\n    --exact \\\n    --python=\"./src-tauri/pyembed/python/bin/python3\" \\\n    --reinstall-package=tauri-app \\\n    ./src-tauri\n</code></pre> <p>Warning</p> <p>Unlike <code>editable install</code> during development, you need to reinstall your project every time you modify the Python code.</p>"},{"location":"usage/tutorial/build-standalone/#configure-tauri-cli","title":"Configure <code>tauri-cli</code>","text":"<p>ref: https://tauri.app/reference/config/#bundle</p> <p>Create following <code>tauri-cli</code> configuration file:</p> src-tauri/tauri.bundle.json<pre><code>{\n    \"bundle\": {\n        \"active\": true,\n        \"targets\": \"all\",\n        \"resources\": {\n            \"pyembed/python\": \"./\"\n        }\n    }\n}\n</code></pre> <p>ref: https://doc.rust-lang.org/cargo/reference/profiles.html</p> <p>Add the following configuration to <code>Cargo.toml</code>:</p> src-tauri/Cargo.toml<pre><code># ...\n\n[profile.bundle-dev]\ninherits = \"dev\"\n\n[profile.bundle-release]\ninherits = \"release\"\n</code></pre>"},{"location":"usage/tutorial/build-standalone/#build-and-bundle","title":"Build and bundle","text":"<p>ref: https://pyo3.rs/v0.23.3/building-and-distribution.html#configuring-the-python-version</p> <p>Indicate pyo3 to use the embedded Python interpreter through environment variables, so it does not mistakenly use the system Python interpreter.</p> windowsunix <pre><code>$env:PYO3_PYTHON = (Resolve-Path -LiteralPath \".\\src-tauri\\pyembed\\python\\python.exe\").Path\n</code></pre> <pre><code>export PYO3_PYTHON=$(realpath ./src-tauri/pyembed/python/bin/python3)\n</code></pre> <p>Configure <code>RUSTFLAGS</code>:</p> windowsunix <p>Nothing you need to do. Only unix need to set <code>RUSTFLAGS</code>.</p> <ul> <li>There is currently an issue with the <code>sysconfig</code> of <code>python-build-standalone</code>,     which causes <code>pyo3</code> to fail to automatically find <code>libpython3</code> during compilation, so we need to set it manually.</li> <li>We use tauri's <code>resource_dir</code> to bundle the portable Python,     so we need to set <code>rpath</code> to tell our binary how to find the bundled <code>libpython3</code> at runtime.</li> </ul> linuxmacos <pre><code># `tauri-app` is your app `productName` in `tauri.conf.json`.\nexport RUSTFLAGS=\" \\\n    -C link-arg=-Wl,-rpath,\\$ORIGIN/../lib/tauri-app/lib \\\n    -L $(realpath ./src-tauri/pyembed/python/lib)\"\n</code></pre> <pre><code>export RUSTFLAGS=\" \\\n    -C link-arg=-Wl,-rpath,@executable_path/../Resources/lib \\\n    -L $(realpath ./src-tauri/pyembed/python/lib)\"\n</code></pre> <p>Finally, use <code>tauri-cli</code> to bundle:</p> <pre><code>pnpm -- tauri build --config=\"src-tauri/tauri.bundle.json\" -- --profile bundle-release\n</code></pre> <p>Warning</p> <p>DO NOT set <code>bundle.resources</code> in <code>tauri.conf.json</code> directly.</p> <p>The <code>tauri-cli</code> will copy <code>bundle.resources</code> to <code>target/release(debug)</code>, which is in the same location as your executable. This will incorrectly cause the copied Python environment to be the Python environment linked at runtime during <code>tauri dev</code>. However, during development, you should use a <code>venv</code> virtual environment.</p> <p>By using <code>--profile bundle-release</code>, we ensure that <code>target/release(debug)</code> is not affected, allowing you to use <code>tauri dev</code> normally.</p>"},{"location":"usage/tutorial/build-wheel/","title":"Build python Wheel distribution","text":"<p>Although you have built the sdist in the previous step and can build the wheel using <code>setuptools-rust</code>, take a look at the output wheel file name <code>tauri-app-0.1.0-cp39-cp39-linux_x86_64.whl</code>.</p> <p>According to https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/, this indicates that the wheel can only be used on <code>CPython == 3.9</code>.</p> <p>This means that if you want to distribute the wheel built in this way, you need to build a wheel for each CPython version.</p> <p>Additionally, PyPI will not allow you to upload wheels with the <code>linux*</code> tag because such a tag does not specify the libc version required to run the wheel. PyPI only allows manylinux and musllinux.</p> <p>Info</p> <p>This is not an issue for users who use your sdist, as they will build the wheel in their own environment and do not need to distribute that wheel.</p>"},{"location":"usage/tutorial/build-wheel/#maturin","title":"Maturin","text":"<p>To make it easier to build distributable wheels, we recommend using maturin, which is a <code>setuptools-rust</code> with batteries included.</p> <p>First, install it (<code>v1.8.0</code>) using uv:</p> windows or macoslinux <pre><code>uv pip install maturin\n</code></pre> <pre><code>uv pip install maturin[patchelf]\n</code></pre> <p>Add the following configuration, which is the same as the configuration for <code>setuptools-rust</code>:</p> src-tauri/pyproject.toml<pre><code># see: &lt;https://www.maturin.rs/config&gt;\n[tool.maturin]\n# the same as [tool.setuptools.packages.find.where]\npython-source = \"python\"\n# the same as `[project.entry-points.pytauri.ext_mod]`,\n# i.e., `target` in `setup.py`\nmodule-name = \"tauri_app.ext_mod\"\n# see `setup.py`\nfeatures = [\"pyo3/extension-module\", \"tauri/custom-protocol\"]\n# equivalent to `setuptools_scm`\nsdist-generator = \"git\"\n# equivalent to `MANIFEST.in`\ninclude = [{ path = \"frontend/**/*\", format = \"sdist\" }]\n</code></pre>"},{"location":"usage/tutorial/build-wheel/#build-manylinux-wheel","title":"Build manylinux wheel","text":"<p>ref: https://www.maturin.rs/distribution#build-wheels</p> <p>Maturin can automatically detect the current system's glibc version and assign the appropriate tag to the built wheel. Use the following command to build a manylinux wheel:</p> <pre><code>cd src-tauri\npnpm build  # build frontend assets\nmaturin build --release  # `--strip` &lt;-- optional to reduce the size\ncd ..\n</code></pre> <p>When you build on <code>ubuntu 22.04 (glibc 2.35)</code>, you will get a wheel file named <code>*-manylinux_2_35_*.whl</code>. The <code>manylinux_2_35</code> tag indicates that the wheel can run on systems with <code>glibc &gt;= 2.35</code>.</p> <p>If you want to support as many systems as possible, you should build the wheel on an older system. However, please note that the dependencies of <code>tauri v2</code> require you to use <code>ubuntu 22+</code>.</p>"},{"location":"usage/tutorial/build-wheel/#bundle-system-dependencies-with-the-wheel","title":"Bundle system dependencies with the wheel","text":"<p>According to PEP513, the manylinux wheel you built in the previous step can only link to a limited set of system libraries at runtime. To meet this requirement, maturin will copy and bundle these system libraries (including tauri's dependencies) during the build process, similar to how AppImage works.</p> <p>Tip</p> <p>Not all linked libraries will be bundled. Some libraries commonly found in various Linux distributions will be whitelisted. See more:</p> <ul> <li>https://github.com/pypa/auditwheel/issues/78</li> <li>https://github.com/kuelumbus/rdkit-pypi/issues/75</li> <li>https://github.com/PyO3/maturin/blob/f5b807eaf3f576ea08e6a574d699fc6f54e2be46/src/auditwheel/manylinux-policy.json#L454</li> </ul> <p>Building the wheel in this way means your users will no longer need to manually install dependencies. However, note that this will increase your wheel size from 10MB to 100MB.</p> <p>If you do not want this behavior, skip patching and manually specify the manylinux tag:</p> <pre><code>maturin build --release --auditwheel skip --manylinux 2_35 # &lt;-- your glibc version\n</code></pre> <p>Then, require your users to install these dependencies before running the wheel:</p> <p>ref: https://tauri.app/distribute/debian/#debian</p> <ul> <li>libwebkit2gtk-4.1-0</li> <li>libgtk-3-0</li> <li>libappindicator3-1 (if your app uses the system tray)</li> </ul>"},{"location":"usage/tutorial/build-wheel/#build-abi3-wheel","title":"Build abi3 wheel","text":"<p>ref: https://www.maturin.rs/bindings.html#py_limited_apiabi3</p> <p>add pyo3 feature <code>pyo3/abi3-py3*</code>:</p> src-tauri/pyproject.toml<pre><code>[tool.maturin]\n# ...\nfeatures = [\"pyo3/extension-module\", \"tauri/custom-protocol\", \"pyo3/abi3-py39\"]\n</code></pre> <p>then build your wheel:</p> <pre><code>maturin build --release  # your maturin args\n</code></pre> <p>you will get a wheel file named <code>*-cp39-abi3-*.whl</code>, which means that the wheel can run on <code>CPython &gt;= 3.9</code>.</p> <p>Info</p> <p>The <code>pytauri/standalone</code> feature is incompatible with the <code>pyo3/abi3</code> feature, which is why we only enable it in <code>[[bin]]</code> target.</p>"},{"location":"usage/tutorial/build-wheel/#whats-projectentry-pointspytauri-mean","title":"What's <code>project.entry-points.pytauri</code> mean?","text":"<p>Now it's time to explain <code>[project.entry-points.pytauri]</code>.</p> <p>Looking at the contents of the <code>.whl</code>, you will see the following structure:</p> <pre><code>\u2514\u2500\u2500 tauri_app-0.1.0-*.whl\n    \u251c\u2500\u2500 tauri_app\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 __main__.py\n    \u2502   \u2514\u2500\u2500 ext_mod.*.so/pyd\n    \u2514\u2500\u2500 ...\n</code></pre> <p>We indicate the extension module <code>mod ext_mod</code> in <code>lib.rs</code> to be compiled into the <code>tauri_app/ext_mod.*.so/pyd</code> file by:</p> <ul> <li><code>setup.py (setuptools-rust)</code>: <code>target=\"tauri_app.ext_mod\"</code></li> <li><code>pyproject.toml (maturin)</code>: <code>module-name = \"tauri_app.ext_mod\"</code></li> </ul> <p>Warning</p> <p><code>pytauri</code> does not have any opinion on where you place the extension module, but note that in <code>lib.rs</code> we specified the extension module name with <code>#[pyo3(name = \"ext_mod\")]</code>, so your extension module file name must match this name.</p> <p>Finally, we tell pytauri how to find it through <code>project.entry-points.pytauri.ext_mod = \"tauri_app.ext_mod\"</code> in <code>pyproject.toml</code>.</p>"},{"location":"usage/tutorial/getting-started/","title":"Getting Started","text":"<p>Before starting the tutorial, we recommend installing the following tools, which are considered best practices for initializing a pytauri project. We will use these tools throughout the tutorial.</p> <ul> <li>create-tauri-app: <code>v4.5.9</code></li> <li>uv: <code>v0.5.11</code></li> <li>tauri-cli: <code>v2.1.0</code></li> </ul> <p>Note</p> <p>The specified versions above are the ones used when writing this tutorial. You can use other versions, but the usage might differ from the examples in this tutorial.</p>"},{"location":"usage/tutorial/getting-started/#full-example","title":"Full Example","text":"<p>https://github.com/WSH032/pytauri/tree/main/examples/tauri-app</p>"},{"location":"usage/tutorial/getting-started/#create-a-new-tauri-project","title":"Create a new tauri project","text":"<p>ref: https://tauri.app/start/create-project/#using-create-tauri-app</p> <p>Note</p> <p>In this tutorial, we will use pnpm to manage the frontend.</p> <p>However, pytauri does not have any opinion on which frontend framework you use. You can even serve the frontend resources via a server using a URL.</p> <pre><code>pnpm create tauri-app\n\n? Project name (tauri-app) \u203a\n? Identifier (com.tauri-app.app) \u203a\n? Choose which language to use for your frontend \u203a\n    \u276f TypeScript / JavaScript  (pnpm, yarn, npm, deno, bun)\n? Choose your package manager \u203a\n    \u276f pnpm\n? Choose your UI template \u203a\n    \u276f Vanilla\n? Choose your UI flavor \u203a\n    \u276f TypeScript\n</code></pre> <p>You will get the following directory structure:</p> <pre><code>\u2514\u2500\u2500 tauri-app\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 index.html\n    \u251c\u2500\u2500 package.json\n    \u251c\u2500\u2500 src\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 assets\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 main.ts\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 styles.css\n    \u251c\u2500\u2500 src-tauri\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.toml\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 build.rs\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 capabilities\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 icons\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 tauri.conf.json\n    \u251c\u2500\u2500 tsconfig.json\n    \u2514\u2500\u2500 vite.config.ts\n</code></pre> <ul> <li><code>/tauri-app</code>: for the frontend</li> <li><code>/tauri-app/src-tauri</code>: for rust and python backend</li> </ul>"},{"location":"usage/tutorial/getting-started/#launch-the-tauri-app","title":"Launch the tauri app","text":"<pre><code>cd tauri-app\npnpm install  # (1)!\npnpm tauri dev  # (2)!\n</code></pre> <ol> <li>This command will install <code>tuari-cli</code></li> <li>use <code>tauri-cli</code> to start the app</li> </ol> <p>Info</p> <p>The first run will take some time to compile the dependencies, subsequent launches will be much faster.</p> <p>Congratulations! When you finally see a window with web content appear, you have successfully created a Tauri application.</p>"},{"location":"usage/tutorial/getting-started/#next-steps","title":"Next Steps","text":"<p>Next, we will demonstrate how to integrate Python into the Tauri application using pytauri.</p>"},{"location":"usage/tutorial/py-js-ipc/","title":"IPC between Python and JavaScript","text":"<p>See concepts/ipc for more information.</p> <p>pytauri implements the same IPC API as tauri. You can use it through pytauri.Commands.</p> <p>This tutorial will demonstrate how to use pytauri's IPC API by rewriting the <code>fn greet</code> command in <code>src-tauri/src/lib.rs</code> in Python.</p>"},{"location":"usage/tutorial/py-js-ipc/#enable-pytauri-ipc-permission","title":"Enable pytauri ipc permission","text":"<p>pytauri internally implements IPC through <code>tauri-plugin-pytauri</code>. You need to add it to the dependencies so that you can enable its permission in tauri.</p> src-tauri/Cargo.toml<pre><code># ...\n\n[dependencies]\n# ...\ntauri-plugin-pytauri = { version = \"0.3\" }  # (1)!\n</code></pre> <ol> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> </ol> <p>Refer to https://tauri.app/security/capabilities/ to add the permission:</p> src-tauri/capabilities/default.json<pre><code>{\n    // ...\n    \"permissions\": [\n        // ...\n        \"pytauri:default\"\n    ]\n}\n</code></pre>"},{"location":"usage/tutorial/py-js-ipc/#ipc-in-python","title":"IPC in python","text":""},{"location":"usage/tutorial/py-js-ipc/#install-dependencies","title":"install dependencies","text":"<p>pytauri relies on pydantic for serialization and validation, and on anyio for <code>asyncio</code>/<code>trio</code> support.</p> <p>Therefore, you need to install these dependencies:</p> src-tauri/pyproject.toml<pre><code># ...\n\n[project]\n# ...\ndependencies = [\n    # ...\n    \"pydantic == 2.*\",\n    \"anyio == 4.*\"\n]\n</code></pre> <p>Tip</p> <p>After adding dependencies, you need to use commands like <code>uv sync</code> or <code>uv pip install</code> to synchronize your dependency environment.</p>"},{"location":"usage/tutorial/py-js-ipc/#add-command","title":"add command","text":"<p>see concepts/ipc for more information.</p> src-tauri/python/__init__.py<pre><code>import sys\n\nfrom anyio.from_thread import start_blocking_portal\nfrom pydantic import BaseModel\nfrom pytauri import (\n    BuilderArgs,\n    Commands,\n    builder_factory,\n    context_factory,\n)\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person) -&gt; Greeting:\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n</code></pre>"},{"location":"usage/tutorial/py-js-ipc/#generate-invoke-handler-for-app","title":"generate invoke handler for app","text":"src-tauri/python/__init__.py<pre><code># --8&lt;-- [start:command]\n\nimport sys\n\nfrom anyio.from_thread import start_blocking_portal\nfrom pydantic import BaseModel\nfrom pytauri import (\n    BuilderArgs,\n    Commands,\n    builder_factory,\n    context_factory,\n)\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person) -&gt; Greeting:\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n\n\n# --8&lt;-- [end:command]\n\n\ndef main() -&gt; None:\n    with start_blocking_portal(\"asyncio\") as portal:  # or `trio`\n        app = builder_factory().build(\n            BuilderArgs(\n                context=context_factory(),\n                # \ud83d\udc47\n                invoke_handler=commands.generate_handler(portal),\n                # \ud83d\udc46\n            )\n        )\n        app.run()\n</code></pre>"},{"location":"usage/tutorial/py-js-ipc/#ipc-in-javascript","title":"IPC in JavaScript","text":"<p>pytauri provides an API similar to the <code>invoke</code> function in <code>@tauri-apps/api/core</code> through <code>tauri-plugin-pytauri-api</code>.</p> <p>First, install it: <code>pnpm add tauri-plugin-pytauri-api</code>.</p> <p>Now, you can invoke the command from your JavaScript code:</p> src/main.ts<pre><code>import { invoke } from \"@tauri-apps/api/core\";\nimport { pyInvoke } from \"tauri-plugin-pytauri-api\";\n// or if tauri config `app.withGlobalTauri = true`:\n//\n// ```js\n// const { pyInvoke } = window.__TAURI__.pytauri;\n// ```\n\ninterface Greeting {\n  message: string;\n}\n\nasync function greet() {\n  if (greetMsgEl &amp;&amp; greetInputEl) {\n    // Learn more about Tauri commands at https://tauri.app/develop/calling-rust/\n    const rsGreeting = await invoke&lt;string&gt;(\"greet\", {\n      name: greetInputEl.value,\n    });\n    const pyGreeting = await pyInvoke&lt;Greeting&gt;(\"greet\", {\n      name: greetInputEl.value,\n    });\n    greetMsgEl.textContent = rsGreeting + \"\\n\" + pyGreeting.message;\n  }\n}\n</code></pre>"},{"location":"usage/tutorial/using-plugins/","title":"Using tauri plugins","text":"<p>The Tauri team and community have developed some plugins, you can use them by:</p> <ol> <li>Official Tauri plugins usually provide corresponding JavaScript APIs, which you can use directly on the frontend.</li> <li>Write your own Rust functions using pyo3 and expose them to Python.</li> </ol> <p>PyTauri has provided Python APIs for some Tauri plugins using the second method, and they are called <code>pytauri-plugin-*</code>.</p> <p>Below, we use <code>pytauri-plugin-notification</code> as an example to demonstrate how to use pytauri plugins.</p>"},{"location":"usage/tutorial/using-plugins/#using-the-plugin","title":"Using the plugin","text":""},{"location":"usage/tutorial/using-plugins/#install-tauri-plugin","title":"install tauri plugin","text":"<p>All PyTauri plugins are just Python bindings, which means you need to initialize the underlying Tauri extensions normally:</p> <pre><code>pnpm tauri add notification\n</code></pre>"},{"location":"usage/tutorial/using-plugins/#expose-the-pyo3-bingings-to-python","title":"expose the pyo3 bingings to python","text":"<p>PyTauri plugins usually export their pyo3 API with the following conventions:</p> <ol> <li>Export a Rust <code>mod</code> with the same name as the plugin at the top level.</li> <li>Export a function named <code>pymodule_export</code> at the top level.<ul> <li>The pyo3 API of <code>pytauri</code> itself is exported in this way: <code>pytauri::pymodule_export</code></li> </ul> </li> </ol> <p><code>pytauri-plugin-notification</code> uses the first method.</p> <p>Add the rust dependency:</p> <pre><code>cd src-tauri\ncargo add pytauri-plugin-notification@0.3  # (1)!\ncd ..\n</code></pre> <ol> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> </ol> <p>ref to https://pyo3.rs/v0.23.3/module.html to export the pyo3 bindings:</p> src-tauri/src/lib.rs<pre><code>use pyo3::prelude::*;\n// ...\n\n#[pymodule(gil_used = false)]\n#[pyo3(name = \"ext_mod\")]\npub mod ext_mod {\n\n    #[pymodule_export]\n    use pytauri_plugin_notification::notification;\n\n    // ...\n}\n</code></pre>"},{"location":"usage/tutorial/using-plugins/#use-plugin-api-from-python","title":"use plugin api from python","text":"<p>Add the python dependency:</p> src-tauri/pyproject.toml<pre><code># ...\n\n[project]\n# ...\ndependencies = [\n    # ...\n    \"pytauri-plugin-notification == 0.3.*\",  # (1)!\n]\n</code></pre> <ol> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> </ol> <p>Tip</p> <p>After adding dependencies, you need to use commands like <code>uv sync</code> or <code>uv pip install</code> to synchronize your dependency environment.</p> <p>The PyTauri API maps very well to the original Rust API of the plugin. You can refer to the Rust documentation to understand how to use it:</p> src-tauri/python/__init__.py<pre><code>import sys\n\nfrom pydantic import BaseModel\nfrom pytauri import AppHandle, Commands\nfrom pytauri_plugin_notification import NotificationExt\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person, app_handle: AppHandle) -&gt; Greeting:\n    notification_builder = NotificationExt.builder(app_handle)\n    notification_builder.show(title=\"Greeting\", body=f\"Hello, {body.name}!\")\n\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/","title":"Using pytauri","text":"<p>Note</p> <p>The dependency versions specified in the following tutorial are the versions at the time of writing. There may be newer versions available when you use it.</p>"},{"location":"usage/tutorial/using-pytauri/#create-venv","title":"Create venv","text":"<p>Create a virtual environment using <code>uv</code>:</p> <pre><code>uv venv --python-preference only-system\n</code></pre> <p>Warning</p> <p><code>--python-preference only-system</code> is necessary. Using <code>uv</code>'s managed Python may result in not finding dynamic libraries.</p> <p>activate the virtual environment:</p> bashpowershell <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\Activate.ps1\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/#init-pyproject","title":"Init pyproject","text":"<p>Create the <code>src-tauri/python/tauri_app</code> folder to store Python code, and add the following file:</p> <p>ref: https://packaging.python.org/en/latest/guides/writing-pyproject-toml/</p> src-tauri/pyproject.toml<pre><code>[project]\nname = \"tauri-app\"  # (1)!\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \"&gt;=3.9\"\ndependencies = [\"pytauri == 0.3.*\"]  # (2)!\n\n[project.entry-points.pytauri]\next_mod = \"tauri_app.ext_mod\"\n\n[build-system]\nrequires = [\"setuptools&gt;=61\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools.packages]\nfind = { where = [\"python\"] }  # (3)!\n</code></pre> <ol> <li>your python package name.</li> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> <li>the folder where your python code is stored, i.e., <code>src-tauri/python</code>.</li> </ol> <p>Tip</p> <p>Note the highlighted <code>project.entry-points</code>. We will explain its specific meaning when building the Wheel. For now, let's continue with the tutorial.</p>"},{"location":"usage/tutorial/using-pytauri/#install-your-project","title":"Install your project","text":"<p>Use <code>uv</code> to install your Python package in editable mode:</p> <pre><code>uv pip install -e src-tauri\n</code></pre> <p>Add following code:</p> src-tauri/python/tauri_app/__init__.py<pre><code>\"\"\"The tauri-app.\"\"\"\n\nfrom pytauri import (\n    BuilderArgs,\n    builder_factory,\n    context_factory,\n)\n\n\ndef main() -&gt; None:\n    \"\"\"Run the tauri-app.\"\"\"\n    app = builder_factory().build(\n        BuilderArgs(\n            context=context_factory(),\n        )\n    )\n    app.run()\n</code></pre> src-tauri/python/tauri_app/__main__.py<pre><code>\"\"\"The main entry point for the Tauri app.\"\"\"\n\nfrom multiprocessing import freeze_support\n\nfrom tauri_app import main\n\n# - If you don't use `multiprocessing`, you can remove this line.\n# - If you do use `multiprocessing` but without this line,\n#   you will get endless spawn loop of your application process.\n#   See: &lt;https://pyinstaller.org/en/v6.11.1/common-issues-and-pitfalls.html#multi-processing&gt;.\nfreeze_support()\n\nmain()\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/#run-pytauri-from-rust","title":"Run pytauri from rust","text":"<p>Add following dependencies to <code>Cargo.toml</code>:</p> <p>ref: https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries</p> src-tauri/Cargo.toml<pre><code># ...\n\n[[bin]]\n# the same as the package name\nname = \"tauri-app\"\npath = \"src/main.rs\"\nrequired-features = [\"pytauri/standalone\"]\n\n[dependencies]\n# ...\npyo3 = { version = \"0.23\" }\npytauri = { version = \"0.3\" }  # (1)!\n</code></pre> <ol> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> </ol> <p>Also, enable the <code>pytauri/standalone</code> feature:</p> src-tauri/tauri.conf.json<pre><code>{\n    \"build\": {\n        \"features\": [\"pytauri/standalone\"]\n    }\n}\n</code></pre> <p>Warning</p> <p>If you do not enable <code>required-features</code> in <code>tauri-cli</code>, cargo will silently skip building your <code>main.rs</code> executable file.</p> <p>Change following rust code:</p> src-tauri/src/lib.rs<pre><code>use pyo3::prelude::*;\n\n// Learn more about Tauri commands at https://tauri.app/develop/calling-rust/\n#[tauri::command]\nfn greet(name: &amp;str) -&gt; String {\n    format!(\"Hello, {}! You've been greeted from Rust!\", name)\n}\n\npub fn tauri_generate_context() -&gt; tauri::Context {\n    tauri::generate_context!()\n}\n\n#[pymodule(gil_used = false)]\n#[pyo3(name = \"ext_mod\")]\npub mod ext_mod {\n    use super::*;\n\n    #[pymodule_init]\n    fn init(module: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {\n        pytauri::pymodule_export(\n            module,\n            // i.e., `context_factory` function of python binding\n            |_args, _kwargs| Ok(tauri_generate_context()),\n            // i.e., `builder_factory` function of python binding\n            |_args, _kwargs| {\n                let builder = tauri::Builder::default()\n                    .plugin(tauri_plugin_opener::init())\n                    .invoke_handler(tauri::generate_handler![greet]);\n                Ok(builder)\n            },\n        )\n    }\n}\n</code></pre> src-tauri/src/main.rs<pre><code>// Prevents additional console window on Windows in release, DO NOT REMOVE!!\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::{convert::Infallible, env::var, error::Error, path::PathBuf};\n\nuse pyo3::wrap_pymodule;\nuse pytauri::standalone::{\n    dunce::simplified, PythonInterpreterBuilder, PythonInterpreterEnv, PythonScript,\n};\nuse tauri::{Builder, Manager as _};\n\nuse tauri_app_lib::{ext_mod, tauri_generate_context};\n\nfn main() -&gt; Result&lt;Infallible, Box&lt;dyn Error&gt;&gt; {\n    let py_env = if cfg!(dev) {\n        // `cfg(dev)` is set by `tauri-build` in `build.rs`, which means running with `tauri dev`,\n        // see: &lt;https://github.com/tauri-apps/tauri/pull/8937&gt;.\n\n        let venv_dir = var(\"VIRTUAL_ENV\").map_err(|err| {\n            format!(\n                \"The app is running in tauri dev mode, \\\n                please activate the python virtual environment first \\\n                or set the `VIRTUAL_ENV` environment variable: {err}\",\n            )\n        })?;\n        PythonInterpreterEnv::Venv(PathBuf::from(venv_dir).into())\n    } else {\n        // embedded Python, i.e., bundle mode with `tauri build`.\n\n        // Actually, we don't use this app, we just use it to get the resource directory\n        let sample_app = Builder::default()\n            .build(tauri_generate_context())\n            .map_err(|err| format!(\"failed to build sample app: {err}\"))?;\n        let resource_dir = sample_app\n            .path()\n            .resource_dir()\n            .map_err(|err| format!(\"failed to get resource dir: {err}\"))?;\n\n        // \ud83d\udc49 Remove the UNC prefix `\\\\?\\`, Python ecosystems don't like it.\n        let resource_dir = simplified(&amp;resource_dir).to_owned();\n\n        // \ud83d\udc49 When bundled as a standalone App, we will put python in the resource directory\n        PythonInterpreterEnv::Standalone(resource_dir.into())\n    };\n\n    // \ud83d\udc49 Equivalent to `python -m tauri_app`,\n    // i.e, run the `src-tauri/python/tauri_app/__main__.py`\n    let py_script = PythonScript::Module(\"tauri_app\".into());\n\n    // \ud83d\udc49 `ext_mod` is your extension module, we export it from memory,\n    // so you don't need to compile it into a binary file (.pyd/.so).\n    let builder =\n        PythonInterpreterBuilder::new(py_env, py_script, |py| wrap_pymodule!(ext_mod)(py));\n    let interpreter = builder.build()?;\n\n    let exit_code = interpreter.run();\n    std::process::exit(exit_code);\n}\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/#launch-the-app-in-dev-mode","title":"Launch the app in dev mode","text":"<p>The <code>tauri-cli</code> has the ability to watch code changes and hot reload. Before starting, we need to add the following file to tell <code>tauri-cli</code> to ignore the python bytecode:</p> <p>ref: https://tauri.app/develop/#reacting-to-source-code-changes</p> src-tauri/.taurignore<pre><code>__pycache__\n</code></pre> <p>Also, we need tell <code>vite</code> to ignore <code>.venv</code>:</p> vite.config.ts<pre><code>// https://vitejs.dev/config/\nexport default defineConfig(async () =&gt; ({\n  server: {\n    watch: {\n      // 3. tell vite to ignore watching `src-tauri`\n      ignored: [\"**/src-tauri/**\", \"**/.venv/**\"],\n    },\n  },\n}));\n</code></pre> <p>Run <code>pnpm tauri dev</code>, and after recompiling, you will see a window similar to the previous step.</p> <p>Try modifying the Python code, and you will notice that the Python code is quickly reloaded without needing to recompile the Rust code.</p>"},{"location":"usage/tutorial/using-pytauri/#next-steps","title":"Next Steps","text":"<p>Next, we will demonstrate how to package your application.</p>"}]}